function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _inheritsLoose(a,b){a.prototype=Object.create(b.prototype),a.prototype.constructor=a,a.__proto__=b}/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */ /* eslint-disable sort-keys, no-magic-numbers, react/forbid-prop-types */ /* eslint-disable react/require-default-props, complexity, prefer-destructuring */ /* eslint-disable no-restricted-properties */import Immutable from"immutable";import PropTypes from"prop-types";import React from"react";import{CanvasOverlay}from"react-map-gl";import{kmToPixels,MILES_PER_KM}from"./utils/geo";import roundDecimal from"./utils/roundDecimal";import luminanceFromRGB from"./utils/luminanceFromRGB";import"mapbox-gl/dist/mapbox-gl.css";var propTypes={aggregation:PropTypes.string,compositeOperation:PropTypes.string,dotRadius:PropTypes.number,lngLatAccessor:PropTypes.func,locations:PropTypes.instanceOf(Immutable.List).isRequired,pointRadiusUnit:PropTypes.string,renderWhileDragging:PropTypes.bool,rgb:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.number])),zoom:PropTypes.number},defaultProps={// Same as browser default.
compositeOperation:"source-over",dotRadius:4,lngLatAccessor:function b(a){return[a.get(0),a.get(1)]},renderWhileDragging:!0},computeClusterLabel=function(a,b){var c=a.get("point_count");if(!b)return c;if("sum"===b||"min"===b||"max"===b)return a.get(b);var d=a.get("sum");if("mean"===b)return Math.round(100*(d/c))/100;var e=a.get("squaredSum"),f=e/c-Math.pow(d/c,2);if("var"===b)return Math.round(100*f)/100;// fallback to point_count, this really shouldn't happen
return"stdev"===b?Math.round(100*Math.sqrt(f))/100:c},ScatterPlotGlowOverlay=/*#__PURE__*/function(a){function b(b){var c;return c=a.call(this,b)||this,c.redraw=c.redraw.bind(_assertThisInitialized(c)),c}_inheritsLoose(b,a);var c=b.prototype;return c.drawText=function s(a,b,c){void 0===c&&(c={});var d=110,e=c,f=e.fontHeight,g=void 0===f?0:f,h=e.label,i=void 0===h?"":h,j=e.radius,k=void 0===j?0:j,l=e.rgb,m=void 0===l?[0,0,0]:l,n=e.shadow,o=1.8*k,p=luminanceFromRGB(m[1],m[2],m[3]);a.globalCompositeOperation="source-over",a.fillStyle=p<=d?"white":"black",a.font=g+"px sans-serif",a.textAlign="center",a.textBaseline="middle",void 0!==n&&n&&(a.shadowBlur=15,a.shadowColor=p<=d?"black":"");var q=a.measureText(i).width;if(q>o){a.font=g/q*o+"px sans-serif"}var r=this.props.compositeOperation;a.fillText(i,b[0],b[1]),a.globalCompositeOperation=r,a.shadowBlur=0,a.shadowColor=""}// Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js
,c.redraw=function t(a){var b=a.width,c=a.height,d=a.ctx,e=a.isDragging,f=a.project,g=this.props,h=g.aggregation,i=g.compositeOperation,j=g.dotRadius,k=g.lngLatAccessor,l=g.locations,m=g.pointRadiusUnit,n=g.renderWhileDragging,o=g.rgb,p=g.zoom,q=j,r=[];l.forEach(function(a,b){a.get("properties").get("cluster")&&(r[b]=computeClusterLabel(a.get("properties"),h))},this);var s=Math.max.apply(Math,r.filter(function(a){return!Number.isNaN(a)}));d.clearRect(0,0,b,c),d.globalCompositeOperation=i,(n||!e)&&l&&l.forEach(function(a,e){var g=f(k(a)),h=[roundDecimal(g[0],1),roundDecimal(g[1],1)];if(0<=h[0]+q&&h[0]-q<b&&0<=h[1]+q&&h[1]-q<c)if(d.beginPath(),a.get("properties").get("cluster")){var i=r[e],j=roundDecimal(Math.pow(i/s,.5)*q,1),l=roundDecimal(.5*j,1),n=h[0],t=h[1],u=d.createRadialGradient(n,t,j,n,t,0);u.addColorStop(1,"rgba("+o[1]+", "+o[2]+", "+o[3]+", 0.8)"),u.addColorStop(0,"rgba("+o[1]+", "+o[2]+", "+o[3]+", 0)"),d.arc(h[0],h[1],j,0,2*Math.PI),d.fillStyle=u,d.fill(),Number.isFinite(parseFloat(i))&&(1e4<=i?i=Math.round(i/1e3)+"k":1e3<=i&&(i=Math.round(i/100)/10+"k"),this.drawText(d,h,{fontHeight:l,label:i,radius:j,rgb:o,shadow:!0}))}else{var v,w=q/6,x=a.get("properties").get("radius"),y=a.get("properties").get("metric"),z=null===x?w:x;if(null!==x){var A=k(a)[1];"Kilometers"===m?(v=roundDecimal(z,2)+"km",z=kmToPixels(z,A,p)):"Miles"===m&&(v=roundDecimal(z,2)+"mi",z=kmToPixels(z*MILES_PER_KM,A,p))}null!==y&&(v=Number.isFinite(parseFloat(y))?roundDecimal(y,2):y),z||(z=w),d.arc(h[0],h[1],roundDecimal(z,1),0,2*Math.PI),d.fillStyle="rgb("+o[1]+", "+o[2]+", "+o[3]+")",d.fill(),void 0!==v&&this.drawText(d,h,{fontHeight:roundDecimal(z,1),label:v,radius:z,rgb:o,shadow:!1})}},this)},c.render=function a(){return React.createElement(CanvasOverlay,{redraw:this.redraw})},b}(React.PureComponent);ScatterPlotGlowOverlay.propTypes=propTypes,ScatterPlotGlowOverlay.defaultProps=defaultProps;export default ScatterPlotGlowOverlay;