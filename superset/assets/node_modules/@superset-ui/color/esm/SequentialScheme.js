function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _inheritsLoose(a,b){a.prototype=Object.create(b.prototype),a.prototype.constructor=a,a.__proto__=b}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}import{scaleLinear}from"d3-scale";import ColorScheme from"./ColorScheme";function range(a){for(var b=[],c=0;c<a;c+=1)b.push(c);return b}var SequentialScheme=/*#__PURE__*/function(a){function b(b){var c;c=a.call(this,b)||this,_defineProperty(_assertThisInitialized(c),"isDiverging",void 0);var d=b.isDiverging;return c.isDiverging=void 0!==d&&d,c}_inheritsLoose(b,a);var c=b.prototype;return c.createLinearScale=function e(a){void 0===a&&(a=[0,1]);// Create matching domain
// because D3 continuous scale uses piecewise mapping
// between domain and range.
var b=scaleLinear().range(a),c=this.colors.length-1,d=range(this.colors.length).map(function(a){return b(a/c)});return scaleLinear().domain(d).range(this.colors).clamp(!0)},c.getColors=function d(a){if(void 0===a&&(a=this.colors.length),a===this.colors.length)return this.colors;var b=this.createLinearScale(),c=a-1;return range(a).map(function(a){return b(a/c)})},b}(ColorScheme);export{SequentialScheme as default};