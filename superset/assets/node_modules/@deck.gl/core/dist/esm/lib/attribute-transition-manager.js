function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { GL, Buffer, experimental } from 'luma.gl';
import { getShaders, getBuffers, padBuffer } from './attribute-transition-utils';
import Transition from '../transitions/transition';
import log from '../utils/log';
import assert from '../utils/assert';
var Transform = experimental.Transform;

var noop = function noop() {};

var AttributeTransitionManager =
/*#__PURE__*/
function () {
  function AttributeTransitionManager(gl, _ref) {
    var id = _ref.id;

    _classCallCheck(this, AttributeTransitionManager);

    this.id = id;
    this.gl = gl;
    this.attributeTransitions = {};
    this.needsRedraw = false;
    this.transform = null;
    this.numInstances = 0;

    if (Transform.isSupported(gl)) {
      this.isSupported = true;
    } else {
      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();
    }
  }

  _createClass(AttributeTransitionManager, [{
    key: "finalize",
    value: function finalize() {
      if (this.transform) {
        this.transform.delete();
      }

      for (var attributeName in this.attributeTransitions) {
        this._removeTransition(attributeName);
      }
    }
    /* Public methods */
    // Called when attribute manager updates
    // Check the latest attributes for updates.

  }, {
    key: "update",
    value: function update(_ref2) {
      var attributes = _ref2.attributes,
          _ref2$transitions = _ref2.transitions,
          transitions = _ref2$transitions === void 0 ? {} : _ref2$transitions,
          numInstances = _ref2.numInstances;
      this.opts = transitions;
      this.numInstances = numInstances;

      if (!this.isSupported) {
        return;
      }

      var attributeTransitions = this.attributeTransitions;
      var changedTransitions = {};

      for (var attributeName in attributes) {
        var hasChanged = this._updateAttribute(attributeName, attributes[attributeName]);

        if (hasChanged) {
          changedTransitions[attributeName] = attributeTransitions[attributeName];
        }
      }

      for (var _attributeName in attributeTransitions) {
        var attribute = attributes[_attributeName];

        if (!attribute || !attribute.supportsTransition()) {
          // Animated attribute has been removed
          this._removeTransition(_attributeName);
        }
      }

      if (!this.transform) {
        this._createModel();
      } else if (this.transform) {
        var _getBuffers = getBuffers(changedTransitions),
            sourceBuffers = _getBuffers.sourceBuffers,
            destinationBuffers = _getBuffers.destinationBuffers;

        this.transform.update({
          elementCount: this.numInstances,
          sourceBuffers: sourceBuffers,
          destinationBuffers: destinationBuffers
        });
      }
    } // Returns `true` if attribute is transition-enabled

  }, {
    key: "hasAttribute",
    value: function hasAttribute(attributeName) {
      return attributeName in this.attributeTransitions;
    } // Get all the animated attributes

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      var animatedAttributes = {};

      for (var attributeName in this.attributeTransitions) {
        var transition = this.attributeTransitions[attributeName];

        if (transition.buffer) {
          animatedAttributes[attributeName] = transition.buffer;
        }
      }

      return animatedAttributes;
    }
    /* eslint-disable max-statements */
    // Called every render cycle, run transform feedback
    // Returns `true` if anything changes

  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(currentTime) {
      if (!this.transform) {
        return false;
      }

      var uniforms = {};
      var needsRedraw = this.needsRedraw;
      this.needsRedraw = false;

      for (var attributeName in this.attributeTransitions) {
        var transition = this.attributeTransitions[attributeName];
        var updated = transition.update(currentTime);

        if (updated) {
          uniforms["".concat(attributeName, "Time")] = transition.time;
          needsRedraw = true;
        }
      }

      if (needsRedraw) {
        this.transform.run({
          uniforms: uniforms
        });
      }

      return needsRedraw;
    }
    /* eslint-enable max-statements */

    /* Private methods */

  }, {
    key: "_createTransition",
    value: function _createTransition(attributeName, attribute) {
      var transition = this.attributeTransitions[attributeName];

      if (!transition) {
        transition = new Transition({
          name: attributeName,
          attribute: attribute
        });
        this.attributeTransitions[attributeName] = transition;

        this._invalidateModel();

        return transition;
      }

      return null;
    }
  }, {
    key: "_removeTransition",
    value: function _removeTransition(attributeName) {
      var transition = this.attributeTransitions[attributeName];

      if (transition) {
        if (transition.buffer) {
          transition.buffer.delete();
        }

        if (transition._swapBuffer) {
          transition._swapBuffer.delete();
        }

        delete this.attributeTransitions[attributeName];

        this._invalidateModel();
      }
    } // Check an attributes for updates
    // Returns a transition object if a new transition is triggered.

  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(attributeName, attribute) {
      var settings = this._getTransitionSettings(attribute);

      if (settings) {
        var hasChanged;
        var transition = this.attributeTransitions[attributeName];

        if (transition) {
          hasChanged = attribute.needsRedraw();
        } else {
          // New animated attributes have been added
          transition = this._createTransition(attributeName, attribute);
          hasChanged = true;
        }

        if (hasChanged) {
          this._triggerTransition(transition, settings);

          return true;
        }
      }

      return false;
    } // Invalidates the current model

  }, {
    key: "_invalidateModel",
    value: function _invalidateModel() {
      if (this.transform) {
        this.transform.delete();
        this.transform = null;
      }
    } // Create a model for the transform feedback

  }, {
    key: "_createModel",
    value: function _createModel() {
      if (Object.keys(this.attributeTransitions).length === 0) {
        // no transitions
        return;
      }

      this.transform = new Transform(this.gl, Object.assign({
        elementCount: this.numInstances
      }, getBuffers(this.attributeTransitions), getShaders(this.attributeTransitions)));
    } // get current values of an attribute, clipped/padded to the size of the new buffer

  }, {
    key: "_getNextTransitionStates",
    value: function _getNextTransitionStates(transition) {
      var attribute = transition.attribute;
      var size = attribute.size;
      var toState;

      if (attribute.isGeneric) {
        toState = {
          isGeneric: true,
          value: attribute.value,
          size: size
        };
      } else {
        toState = {
          isGeneric: false,
          buffer: attribute.getBuffer(),
          size: size
        };
      }

      var fromState = transition.buffer || toState;
      var toLength = this.numInstances * size;
      var fromLength = fromState.data && fromState.data.length || toLength; // Alternate between two buffers when new transitions start.
      // Last destination buffer is used as an attribute (from state),
      // And the other buffer is now the destination buffer.

      var buffer = transition._swapBuffer;
      transition._swapBuffer = transition.buffer;

      if (!buffer) {
        buffer = new Buffer(this.gl, {
          size: size,
          data: new Float32Array(toLength),
          usage: GL.DYNAMIC_COPY
        });
      } // Pad buffers to be the same length


      if (buffer.data.length < toLength) {
        buffer.setData({
          data: new Float32Array(toLength)
        });
      }

      padBuffer({
        fromState: fromState,
        toState: toState,
        fromLength: fromLength,
        toLength: toLength
      });
      return {
        fromState: fromState,
        toState: toState,
        buffer: buffer
      };
    } // Returns transition settings object if transition is enabled, otherwise `null`

  }, {
    key: "_getTransitionSettings",
    value: function _getTransitionSettings(attribute) {
      var opts = this.opts;
      var _attribute$userData = attribute.userData,
          transition = _attribute$userData.transition,
          accessor = _attribute$userData.accessor;

      if (!transition) {
        return null;
      }

      return Array.isArray(accessor) ? accessor.map(function (a) {
        return opts[a];
      }).find(Boolean) : opts[accessor];
    } // Normalizes transition settings object, merge with default settings

  }, {
    key: "_normalizeTransitionSettings",
    value: function _normalizeTransitionSettings(settings) {
      // Shorthand: use duration instead of parameter object
      if (Number.isFinite(settings)) {
        settings = {
          duration: settings
        };
      } // Check if settings is valid


      assert(settings && settings.duration > 0);
      return {
        duration: settings.duration,
        easing: settings.easing || function (t) {
          return t;
        },
        onStart: settings.onStart || noop,
        onEnd: settings.onEnd || noop,
        onInterrupt: settings.onInterrupt || noop
      };
    } // Start a new transition using the current settings
    // Updates transition state and from/to buffer

  }, {
    key: "_triggerTransition",
    value: function _triggerTransition(transition, settings) {
      this.needsRedraw = true;

      var transitionSettings = this._normalizeTransitionSettings(settings); // Attribute descriptor to transition from


      transition.start(Object.assign({}, this._getNextTransitionStates(transition), transitionSettings));
    }
  }]);

  return AttributeTransitionManager;
}();

export { AttributeTransitionManager as default };
//# sourceMappingURL=attribute-transition-manager.js.map