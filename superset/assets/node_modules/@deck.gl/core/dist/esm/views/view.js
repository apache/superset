function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import Viewport from '../viewports/viewport';
import { parsePosition, getPosition } from '../utils/positions';
import { deepEqual } from '../utils/deep-equal';
import assert from '../utils/assert';

var View =
/*#__PURE__*/
function () {
  function View() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, View);

    var _props$id = props.id,
        id = _props$id === void 0 ? null : _props$id,
        _props$x = props.x,
        x = _props$x === void 0 ? 0 : _props$x,
        _props$y = props.y,
        y = _props$y === void 0 ? 0 : _props$y,
        _props$width = props.width,
        width = _props$width === void 0 ? '100%' : _props$width,
        _props$height = props.height,
        height = _props$height === void 0 ? '100%' : _props$height,
        _props$projectionMatr = props.projectionMatrix,
        projectionMatrix = _props$projectionMatr === void 0 ? null : _props$projectionMatr,
        _props$fovy = props.fovy,
        fovy = _props$fovy === void 0 ? 75 : _props$fovy,
        _props$near = props.near,
        near = _props$near === void 0 ? 0.1 : _props$near,
        _props$far = props.far,
        far = _props$far === void 0 ? 1000 : _props$far,
        _props$modelMatrix = props.modelMatrix,
        modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix,
        _props$viewportInstan = props.viewportInstance,
        viewportInstance = _props$viewportInstan === void 0 ? null : _props$viewportInstan,
        _props$type = props.type,
        type = _props$type === void 0 ? Viewport : _props$type;
    assert(!viewportInstance || _instanceof(viewportInstance, Viewport));
    this.viewportInstance = viewportInstance; // Id

    this.id = id || this.constructor.displayName || 'view';
    this.type = type;
    this.props = Object.assign({}, props, {
      projectionMatrix: projectionMatrix,
      fovy: fovy,
      near: near,
      far: far,
      modelMatrix: modelMatrix
    }); // Extents

    this._parseDimensions({
      x: x,
      y: y,
      width: width,
      height: height
    }); // Bind methods for easy access


    this.equals = this.equals.bind(this);
    Object.seal(this);
  }

  _createClass(View, [{
    key: "equals",
    value: function equals(view) {
      if (this === view) {
        return true;
      } // if `viewportInstance` is set, it is the only prop that is used
      // Delegate to `Viewport.equals`


      if (this.viewportInstance) {
        return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);
      } // TODO - implement deep equal on view descriptors


      var viewChanged = deepEqual(this, view);
      return viewChanged;
    } // Build a `Viewport` from a view descriptor
    // TODO - add support for autosizing viewports using width and height

  }, {
    key: "makeViewport",
    value: function makeViewport(_ref) {
      var width = _ref.width,
          height = _ref.height,
          viewState = _ref.viewState;

      if (this.viewportInstance) {
        return this.viewportInstance;
      } // Resolve relative viewport dimensions


      var viewportDimensions = this.getDimensions({
        width: width,
        height: height
      });
      var props = Object.assign({
        viewState: viewState
      }, viewState, this.props, viewportDimensions);
      return this._getViewport(props);
    } // Resolve relative viewport dimensions into actual dimensions (y='50%', width=800 => y=400)

  }, {
    key: "getDimensions",
    value: function getDimensions(_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return {
        x: getPosition(this._x, width),
        y: getPosition(this._y, height),
        width: getPosition(this._width, width),
        height: getPosition(this._height, height)
      };
    } // Overridable method

  }, {
    key: "_getViewport",
    value: function _getViewport(props) {
      // Get the type of the viewport
      var ViewportType = this.type;
      return new ViewportType(props);
    } // Parse relative viewport dimension descriptors (e.g {y: '50%', height: '50%'})

  }, {
    key: "_parseDimensions",
    value: function _parseDimensions(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          width = _ref3.width,
          height = _ref3.height;
      this._x = parsePosition(x);
      this._y = parsePosition(y);
      this._width = parsePosition(width);
      this._height = parsePosition(height);
    }
  }]);

  return View;
}();

export { View as default };
//# sourceMappingURL=view.js.map