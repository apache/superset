"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _attribute = _interopRequireDefault(require("./attribute"));

var _log = _interopRequireDefault(require("../utils/log"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _attributeTransitionManager = _interopRequireDefault(require("./attribute-transition-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var LOG_START_END_PRIORITY = 2;
var LOG_DETAIL_PRIORITY = 3;

function noop() {} // Default loggers


var logFunctions = {
  savedMessages: null,
  timeStart: null,
  onLog: function onLog(_ref) {
    var level = _ref.level,
        message = _ref.message;

    _log.default.log(level, message)();
  },
  onUpdateStart: function onUpdateStart(_ref2) {
    var level = _ref2.level,
        numInstances = _ref2.numInstances;
    logFunctions.savedMessages = [];
    logFunctions.timeStart = new Date();
  },
  onUpdate: function onUpdate(_ref3) {
    var level = _ref3.level,
        message = _ref3.message;

    if (logFunctions.savedMessages) {
      logFunctions.savedMessages.push(message);
    }
  },
  onUpdateEnd: function onUpdateEnd(_ref4) {
    var level = _ref4.level,
        id = _ref4.id,
        numInstances = _ref4.numInstances;
    var timeMs = Math.round(new Date() - logFunctions.timeStart);
    var time = "".concat(timeMs, "ms");

    _log.default.group(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time), {
      collapsed: true
    })();

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var message = _step.value;

        _log.default.log(level, message)();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    _log.default.groupEnd(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time))();

    logFunctions.savedMessages = null;
  }
};

var AttributeManager =
/*#__PURE__*/
function () {
  _createClass(AttributeManager, null, [{
    key: "setDefaultLogFunctions",

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses deck logger.
     *
     * `onLog` is called for each attribute.
     *
     * To enable detailed control of timming and e.g. hierarchical logging,
     * hooks are also provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [onLog=] - called to print
     * @param {String} [onUpdateStart=] - called before update() starts
     * @param {String} [onUpdateEnd=] - called after update() ends
     */
    value: function setDefaultLogFunctions() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref5.onLog,
          onUpdateStart = _ref5.onUpdateStart,
          onUpdate = _ref5.onUpdate,
          onUpdateEnd = _ref5.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }

      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }

      if (onUpdate !== undefined) {
        logFunctions.onUpdate = onUpdate || noop;
      }

      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }
    /**
     * @classdesc
     * Automated attribute generation and management. Suitable when a set of
     * vertex shader attributes are generated by iteration over a data array,
     * and updates to these attributes are needed either when the data itself
     * changes, or when other data relevant to the calculations change.
     *
     * - First the application registers descriptions of its dynamic vertex
     *   attributes using AttributeManager.add().
     * - Then, when any change that affects attributes is detected by the
     *   application, the app will call AttributeManager.invalidate().
     * - Finally before it renders, it calls AttributeManager.update() to
     *   ensure that attributes are automatically rebuilt if anything has been
     *   invalidated.
     *
     * The application provided update functions describe how attributes
     * should be updated from a data array and are expected to traverse
     * that data array (or iterable) and fill in the attribute's typed array.
     *
     * Note that the attribute manager intentionally does not do advanced
     * change detection, but instead makes it easy to build such detection
     * by offering the ability to "invalidate" each attribute separately.
     */

  }]);

  function AttributeManager(gl) {
    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref6$id = _ref6.id,
        id = _ref6$id === void 0 ? 'attribute-manager' : _ref6$id,
        stats = _ref6.stats;

    _classCallCheck(this, AttributeManager);

    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.accessors = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
      id: "".concat(id, "-transitions")
    }); // For debugging sanity, prevent uninitialized members

    Object.seal(this);
  }

  _createClass(AttributeManager, [{
    key: "finalize",
    value: function finalize() {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }

      this.attributeTransitionManager.finalize();
    } // Returns the redraw flag, optionally clearing it.
    // Redraw flag will be set if any attributes attributes changed since
    // flag was last cleared.
    //
    // @param {String} [clearRedrawFlags=false] - whether to clear the flag
    // @return {false|String} - reason a redraw is needed.

  }, {
    key: "getNeedsRedraw",
    value: function getNeedsRedraw() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,
          clearRedrawFlags = _ref7$clearRedrawFlag === void 0 ? false : _ref7$clearRedrawFlag;

      var redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw && this.id;
    } // Sets the redraw flag.
    // @param {Boolean} redraw=true
    // @return {AttributeManager} - for chaining

  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.needsRedraw = true;
      return this;
    } // Adds attributes

  }, {
    key: "add",
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    } // Adds attributes

  }, {
    key: "addInstanced",
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, {
        instanced: 1
      });
    }
    /**
     * Removes attributes
     * Takes an array of attribute names and delete them from
     * the attribute map if they exists
     *
     * @example
     * attributeManager.remove(['position']);
     *
     * @param {Object} attributeNameArray - attribute name array (see above)
     */

  }, {
    key: "remove",
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];

        if (this.attributes[name] !== undefined) {
          this.attributes[name].delete();
          delete this.attributes[name];
        }
      }
    } // Marks an attribute for update

  }, {
    key: "invalidate",
    value: function invalidate(triggerName) {
      var invalidatedAttributes = this._invalidateTrigger(triggerName); // For performance tuning


      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated attributes ".concat(invalidatedAttributes, " (").concat(triggerName, ") for ").concat(this.id)
      });
    }
  }, {
    key: "invalidateAll",
    value: function invalidateAll() {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate();
      } // For performance tuning


      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated all attributes for ".concat(this.id)
      });
    } // Ensure all attribute buffers are updated from props or data.

  }, {
    key: "update",
    value: function update() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref8.data,
          numInstances = _ref8.numInstances,
          transitions = _ref8.transitions,
          _ref8$props = _ref8.props,
          props = _ref8$props === void 0 ? {} : _ref8$props,
          _ref8$buffers = _ref8.buffers,
          buffers = _ref8$buffers === void 0 ? {} : _ref8$buffers,
          _ref8$context = _ref8.context,
          context = _ref8$context === void 0 ? {} : _ref8$context,
          _ref8$ignoreUnknownAt = _ref8.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref8$ignoreUnknownAt === void 0 ? false : _ref8$ignoreUnknownAt;

      // First apply any application provided buffers
      this._checkExternalBuffers({
        buffers: buffers,
        ignoreUnknownAttributes: ignoreUnknownAttributes
      });

      this._setExternalBuffers(buffers); // Apply constant accessors


      this._setGenericAttributes({
        data: data,
        props: props,
        context: context
      }); // Only initiate alloc/update (and logging) if actually needed


      if (this._checkIfBuffersNeedUpdating({
        numInstances: numInstances
      })) {
        logFunctions.onUpdateStart({
          level: LOG_START_END_PRIORITY,
          id: this.id,
          numInstances: numInstances
        });

        if (this.stats) {
          this.stats.timeStart('attribute updates', this.id);
        }

        this._allocateBuffers({
          numInstances: numInstances,
          data: data,
          props: props,
          context: context
        });

        this._updateBuffers({
          numInstances: numInstances,
          data: data,
          props: props,
          context: context
        });

        if (this.stats) {
          this.stats.timeEnd('attribute updates', this.id);
        }

        logFunctions.onUpdateEnd({
          level: LOG_START_END_PRIORITY,
          id: this.id,
          numInstances: numInstances
        });
      }

      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances: numInstances,
        transitions: transitions
      });
    } // Update attribute transition to the current timestamp
    // Returns `true` if any transition is in progress

  }, {
    key: "updateTransition",
    value: function updateTransition() {
      var attributeTransitionManager = this.attributeTransitionManager;
      var transitionUpdated = attributeTransitionManager.setCurrentTime(Date.now());
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.attributes;
    }
    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: "getChangedAttributes",
    value: function getChangedAttributes(_ref9) {
      var _ref9$transition = _ref9.transition,
          transition = _ref9$transition === void 0 ? false : _ref9$transition,
          _ref9$clearChangedFla = _ref9.clearChangedFlags,
          clearChangedFlags = _ref9$clearChangedFla === void 0 ? false : _ref9$clearChangedFla;
      var attributes = this.attributes,
          attributeTransitionManager = this.attributeTransitionManager;

      if (transition) {
        return attributeTransitionManager.getAttributes();
      }

      var changedAttributes = {};

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        if (attribute.needsRedraw({
          clearChangedFlags: true
        })) {
          // Only return non-transition attributes
          if (!attributeTransitionManager.hasAttribute(attributeName)) {
            changedAttributes[attributeName] = attribute;
          }
        }
      }

      return changedAttributes;
    } // PROTECTED METHODS - Only to be used by collaborating classes, not by apps
    // Returns object containing all accessors as keys, with non-null values
    // @return {Object} - accessors object

  }, {
    key: "getAccessors",
    value: function getAccessors() {
      return this.updateTriggers;
    } // PRIVATE METHODS
    // Used to register an attribute

  }, {
    key: "_add",
    value: function _add(attributes, updaters) {
      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (updaters) {
        _log.default.removed('AttributeManager.add({updaters}) - updater map no longer supported');
      }

      var newAttributes = {};

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName]; // Initialize the attribute descriptor, with WebGL and metadata fields

        newAttributes[attributeName] = new _attribute.default(this.gl, Object.assign({}, attribute, {
          id: attributeName,
          // Luma fields
          isGeneric: attribute.isGeneric || false,
          isIndexed: attribute.isIndexed || attribute.elements,
          size: attribute.elements && 1 || attribute.size,
          value: attribute.value || null,
          instanced: attribute.instanced || extraProps.instanced
        }));
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }
    /* eslint-enable max-statements */
    // build updateTrigger name to attribute name mapping

  }, {
    key: "_mapUpdateTriggersToAttributes",
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach(function (triggerName) {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }

          triggers[triggerName].push(attributeName);
        });
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: "_invalidateTrigger",
    value: function _invalidateTrigger(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;
      var invalidatedAttributes = updateTriggers[triggerName];

      if (!invalidatedAttributes) {
        var message = "invalidating non-existent trigger ".concat(triggerName, " for ").concat(this.id, "\n");
        message += "Valid triggers: ".concat(Object.keys(attributes).join(', '));

        _log.default.warn(message, invalidatedAttributes)();
      } else {
        invalidatedAttributes.forEach(function (name) {
          var attribute = attributes[name];

          if (attribute) {
            attribute.setNeedsUpdate();
          }
        });
      }

      return invalidatedAttributes;
    } // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation

    /* eslint-disable max-statements, max-depth */

  }, {
    key: "_setExternalBuffers",
    value: function _setExternalBuffers(bufferMap) {
      // Copy the refs of any supplied buffers in the props
      for (var attributeName in this.attributes) {
        var attribute = this.attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.setExternalBuffer(buffer, this.numInstances);
        this.needsRedraw |= attribute.needsRedraw();
      }
    } // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: "_checkExternalBuffers",
    value: function _checkExternalBuffers() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref10$buffers = _ref10.buffers,
          buffers = _ref10$buffers === void 0 ? {} : _ref10$buffers,
          _ref10$ignoreUnknownA = _ref10.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref10$ignoreUnknownA === void 0 ? false : _ref10$ignoreUnknownA;

      var attributes = this.attributes;

      for (var attributeName in buffers) {
        var attribute = attributes[attributeName];

        if (!attribute && !ignoreUnknownAttributes) {
          throw new Error("Unknown attribute prop ".concat(attributeName));
        }
      }
    }
    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: "_checkIfBuffersNeedUpdating",
    value: function _checkIfBuffersNeedUpdating(_ref11) {
      var numInstances = _ref11.numInstances;
      (0, _assert.default)(numInstances !== undefined, 'numInstances not defined'); // Track whether any allocations or updates are needed

      var needsUpdate = false;

      for (var attributeName in this.attributes) {
        var attribute = this.attributes[attributeName];
        attribute.setNumInstances(numInstances);
        needsUpdate = needsUpdate || attribute.needsUpdate();
      }

      return needsUpdate;
    }
  }, {
    key: "_setGenericAttributes",
    value: function _setGenericAttributes(_ref12) {
      var data = _ref12.data,
          props = _ref12.props,
          context = _ref12.context;
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        attribute.setGenericValue({
          props: props
        });
      }
    } // Calls update on any buffers that need update
    // TODO? - If app supplied all attributes, no need to iterate over data
    //
    // @param {Object} data - data (iterable object)
    // @param {Object} numInstances - count of data
    // @param {Object} props - passed to updaters
    // @param {Object} context - Used as "this" context for updaters

  }, {
    key: "_allocateBuffers",
    value: function _allocateBuffers(_ref13) {
      var numInstances = _ref13.numInstances,
          data = _ref13.data,
          props = _ref13.props,
          context = _ref13.context;
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        if (attribute.allocate(numInstances)) {
          logFunctions.onUpdate({
            level: LOG_DETAIL_PRIORITY,
            message: "".concat(attributeName, " allocated ").concat(numInstances),
            id: this.id
          });
        }
      }
    } // Calls update on any buffers that need update

  }, {
    key: "_updateBuffers",
    value: function _updateBuffers(_ref14) {
      var numInstances = _ref14.numInstances,
          data = _ref14.data,
          props = _ref14.props,
          context = _ref14.context;

      for (var attributeName in this.attributes) {
        var attribute = this.attributes[attributeName]; // Call updater function if needed

        var timeStart = Date.now();
        var updated = attribute.updateBuffer({
          numInstances: numInstances,
          data: data,
          props: props,
          context: context
        });

        if (updated) {
          this.needsRedraw = true;
          var timeMs = Math.round(Date.now() - timeStart);
          logFunctions.onUpdate({
            level: LOG_DETAIL_PRIORITY,
            message: "".concat(attributeName, " updated ").concat(numInstances, " in ").concat(timeMs, "ms")
          });
        }
      }
    }
  }]);

  return AttributeManager;
}();

exports.default = AttributeManager;
//# sourceMappingURL=attribute-manager.js.map