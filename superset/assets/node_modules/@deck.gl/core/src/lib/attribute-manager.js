// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable guard-for-in */
import Attribute from './attribute';
import log from '../utils/log';
import assert from '../utils/assert';

import AttributeTransitionManager from './attribute-transition-manager';

const LOG_START_END_PRIORITY = 2;
const LOG_DETAIL_PRIORITY = 3;

function noop() {}

// Default loggers
const logFunctions = {
  savedMessages: null,
  timeStart: null,
  onLog: ({level, message}) => {
    log.log(level, message)();
  },
  onUpdateStart: ({level, numInstances}) => {
    logFunctions.savedMessages = [];
    logFunctions.timeStart = new Date();
  },
  onUpdate: ({level, message}) => {
    if (logFunctions.savedMessages) {
      logFunctions.savedMessages.push(message);
    }
  },
  onUpdateEnd: ({level, id, numInstances}) => {
    const timeMs = Math.round(new Date() - logFunctions.timeStart);
    const time = `${timeMs}ms`;
    log.group(level, `Updated attributes for ${numInstances} instances in ${id} in ${time}`, {
      collapsed: true
    })();
    for (const message of logFunctions.savedMessages) {
      log.log(level, message)();
    }
    log.groupEnd(level, `Updated attributes for ${numInstances} instances in ${id} in ${time}`)();
    logFunctions.savedMessages = null;
  }
};

export default class AttributeManager {
  /**
   * Sets log functions to help trace or time attribute updates.
   * Default logging uses deck logger.
   *
   * `onLog` is called for each attribute.
   *
   * To enable detailed control of timming and e.g. hierarchical logging,
   * hooks are also provided for update start and end.
   *
   * @param {Object} [opts]
   * @param {String} [onLog=] - called to print
   * @param {String} [onUpdateStart=] - called before update() starts
   * @param {String} [onUpdateEnd=] - called after update() ends
   */
  static setDefaultLogFunctions({onLog, onUpdateStart, onUpdate, onUpdateEnd} = {}) {
    if (onLog !== undefined) {
      logFunctions.onLog = onLog || noop;
    }
    if (onUpdateStart !== undefined) {
      logFunctions.onUpdateStart = onUpdateStart || noop;
    }
    if (onUpdate !== undefined) {
      logFunctions.onUpdate = onUpdate || noop;
    }
    if (onUpdateEnd !== undefined) {
      logFunctions.onUpdateEnd = onUpdateEnd || noop;
    }
  }

  /**
   * @classdesc
   * Automated attribute generation and management. Suitable when a set of
   * vertex shader attributes are generated by iteration over a data array,
   * and updates to these attributes are needed either when the data itself
   * changes, or when other data relevant to the calculations change.
   *
   * - First the application registers descriptions of its dynamic vertex
   *   attributes using AttributeManager.add().
   * - Then, when any change that affects attributes is detected by the
   *   application, the app will call AttributeManager.invalidate().
   * - Finally before it renders, it calls AttributeManager.update() to
   *   ensure that attributes are automatically rebuilt if anything has been
   *   invalidated.
   *
   * The application provided update functions describe how attributes
   * should be updated from a data array and are expected to traverse
   * that data array (or iterable) and fill in the attribute's typed array.
   *
   * Note that the attribute manager intentionally does not do advanced
   * change detection, but instead makes it easy to build such detection
   * by offering the ability to "invalidate" each attribute separately.
   */
  constructor(gl, {id = 'attribute-manager', stats} = {}) {
    this.id = id;
    this.gl = gl;

    this.attributes = {};

    this.updateTriggers = {};
    this.accessors = {};
    this.needsRedraw = true;

    this.userData = {};
    this.stats = stats;

    this.attributeTransitionManager = new AttributeTransitionManager(gl, {
      id: `${id}-transitions`
    });

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }
    this.attributeTransitionManager.finalize();
  }

  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw({clearRedrawFlags = false} = {}) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
    return redraw && this.id;
  }

  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  // @return {AttributeManager} - for chaining
  setNeedsRedraw(redraw = true) {
    this.needsRedraw = true;
    return this;
  }

  // Adds attributes
  add(attributes, updaters = {}) {
    this._add(attributes, updaters);
  }

  // Adds attributes
  addInstanced(attributes, updaters = {}) {
    this._add(attributes, updaters, {instanced: 1});
  }

  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(attributeNameArray) {
    for (let i = 0; i < attributeNameArray.length; i++) {
      const name = attributeNameArray[i];
      if (this.attributes[name] !== undefined) {
        this.attributes[name].delete();
        delete this.attributes[name];
      }
    }
  }

  // Marks an attribute for update
  invalidate(triggerName) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName);
    // For performance tuning
    logFunctions.onLog({
      level: LOG_DETAIL_PRIORITY,
      message: `invalidated attributes ${invalidatedAttributes} (${triggerName}) for ${this.id}`
    });
  }

  invalidateAll() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate();
    }
    // For performance tuning
    logFunctions.onLog({
      level: LOG_DETAIL_PRIORITY,
      message: `invalidated all attributes for ${this.id}`
    });
  }

  // Ensure all attribute buffers are updated from props or data.
  update({
    data,
    numInstances,
    transitions,
    props = {},
    buffers = {},
    context = {},
    ignoreUnknownAttributes = false
  } = {}) {
    // First apply any application provided buffers
    this._checkExternalBuffers({buffers, ignoreUnknownAttributes});
    this._setExternalBuffers(buffers);

    // Apply constant accessors
    this._setGenericAttributes({data, props, context});

    // Only initiate alloc/update (and logging) if actually needed
    if (this._checkIfBuffersNeedUpdating({numInstances})) {
      logFunctions.onUpdateStart({level: LOG_START_END_PRIORITY, id: this.id, numInstances});
      if (this.stats) {
        this.stats.timeStart('attribute updates', this.id);
      }
      this._allocateBuffers({numInstances, data, props, context});
      this._updateBuffers({numInstances, data, props, context});
      if (this.stats) {
        this.stats.timeEnd('attribute updates', this.id);
      }
      logFunctions.onUpdateEnd({level: LOG_START_END_PRIORITY, id: this.id, numInstances});
    }

    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }

  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const {attributeTransitionManager} = this;
    const transitionUpdated = attributeTransitionManager.setCurrentTime(Date.now());
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }

  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return this.attributes;
  }

  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuggers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes({transition = false, clearChangedFlags = false}) {
    const {attributes, attributeTransitionManager} = this;

    if (transition) {
      return attributeTransitionManager.getAttributes();
    }

    const changedAttributes = {};
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      if (attribute.needsRedraw({clearChangedFlags: true})) {
        // Only return non-transition attributes
        if (!attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }
    }
    return changedAttributes;
  }

  // PROTECTED METHODS - Only to be used by collaborating classes, not by apps

  // Returns object containing all accessors as keys, with non-null values
  // @return {Object} - accessors object
  getAccessors() {
    return this.updateTriggers;
  }

  // PRIVATE METHODS

  // Used to register an attribute
  _add(attributes, updaters, extraProps = {}) {
    if (updaters) {
      log.removed('AttributeManager.add({updaters}) - updater map no longer supported');
    }

    const newAttributes = {};

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];

      // Initialize the attribute descriptor, with WebGL and metadata fields
      newAttributes[attributeName] = new Attribute(
        this.gl,
        Object.assign({}, attribute, {
          id: attributeName,
          // Luma fields
          isGeneric: attribute.isGeneric || false,
          isIndexed: attribute.isIndexed || attribute.elements,
          size: (attribute.elements && 1) || attribute.size,
          value: attribute.value || null,
          instanced: attribute.instanced || extraProps.instanced
        })
      );
    }

    Object.assign(this.attributes, newAttributes);

    this._mapUpdateTriggersToAttributes();
  }
  /* eslint-enable max-statements */

  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const triggers = {};

    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach(triggerName => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }
        triggers[triggerName].push(attributeName);
      });
    }

    this.updateTriggers = triggers;
  }

  _invalidateTrigger(triggerName) {
    const {attributes, updateTriggers} = this;
    const invalidatedAttributes = updateTriggers[triggerName];

    if (!invalidatedAttributes) {
      let message = `invalidating non-existent trigger ${triggerName} for ${this.id}\n`;
      message += `Valid triggers: ${Object.keys(attributes).join(', ')}`;
      log.warn(message, invalidatedAttributes)();
    } else {
      invalidatedAttributes.forEach(name => {
        const attribute = attributes[name];
        if (attribute) {
          attribute.setNeedsUpdate();
        }
      });
    }
    return invalidatedAttributes;
  }

  // Set the buffers for the supplied attributes
  // Update attribute buffers from any attributes in props
  // Detach any previously set buffers, marking all
  // Attributes for auto allocation
  /* eslint-disable max-statements, max-depth */
  _setExternalBuffers(bufferMap) {
    // Copy the refs of any supplied buffers in the props
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];

      const buffer = bufferMap[attributeName];
      attribute.setExternalBuffer(buffer, this.numInstances);
      this.needsRedraw |= attribute.needsRedraw();
    }
  }

  // Checks that any attribute buffers in props are valid
  // Note: This is just to help app catch mistakes
  _checkExternalBuffers({buffers = {}, ignoreUnknownAttributes = false} = {}) {
    const {attributes} = this;
    for (const attributeName in buffers) {
      const attribute = attributes[attributeName];
      if (!attribute && !ignoreUnknownAttributes) {
        throw new Error(`Unknown attribute prop ${attributeName}`);
      }
    }
  }

  /* Checks that typed arrays for attributes are big enough
   * sets alloc flag if not
   * @return {Boolean} whether any updates are needed
   */
  _checkIfBuffersNeedUpdating({numInstances}) {
    assert(numInstances !== undefined, 'numInstances not defined');

    // Track whether any allocations or updates are needed
    let needsUpdate = false;

    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.setNumInstances(numInstances);
      needsUpdate = needsUpdate || attribute.needsUpdate();
    }

    return needsUpdate;
  }

  _setGenericAttributes({data, props, context}) {
    const {attributes} = this;

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      attribute.setGenericValue({props});
    }
  }

  // Calls update on any buffers that need update
  // TODO? - If app supplied all attributes, no need to iterate over data
  //
  // @param {Object} data - data (iterable object)
  // @param {Object} numInstances - count of data
  // @param {Object} props - passed to updaters
  // @param {Object} context - Used as "this" context for updaters
  _allocateBuffers({numInstances, data, props, context}) {
    const {attributes} = this;

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];

      if (attribute.allocate(numInstances)) {
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: `${attributeName} allocated ${numInstances}`,
          id: this.id
        });
      }
    }
  }

  // Calls update on any buffers that need update
  _updateBuffers({numInstances, data, props, context}) {
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];

      // Call updater function if needed
      const timeStart = Date.now();

      const updated = attribute.updateBuffer({numInstances, data, props, context});
      if (updated) {
        this.needsRedraw = true;

        const timeMs = Math.round(Date.now() - timeStart);
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: `${attributeName} updated ${numInstances} in ${timeMs}ms`
        });
      }
    }
  }
}
