import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { whichButtons, getOffsetPosition } from './event-utils';

var EventRegistrar =
/*#__PURE__*/
function () {
  function EventRegistrar(eventManager) {
    _classCallCheck(this, EventRegistrar);

    this.eventManager = eventManager;
    this.handlers = []; // Element -> handler map

    this.handlersByElement = new Map();
    this.handleEvent = this.handleEvent.bind(this);
  }

  _createClass(EventRegistrar, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.handlers.length === 0;
    }
  }, {
    key: "add",
    value: function add(type, handler) {
      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'root';
      var handlers = this.handlers,
          handlersByElement = this.handlersByElement;

      if (!handlersByElement.has(srcElement)) {
        handlersByElement.set(srcElement, []);
      }

      var entry = {
        type: type,
        handler: handler,
        srcElement: srcElement
      };
      handlers.push(entry);
      handlersByElement.get(srcElement).push(entry);
    }
  }, {
    key: "remove",
    value: function remove(type, handler) {
      var handlers = this.handlers,
          handlersByElement = this.handlersByElement;

      for (var i = handlers.length - 1; i >= 0; i--) {
        var entry = handlers[i];

        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i, 1);
          var entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);

          if (entries.length === 0) {
            handlersByElement.delete(entry.srcElement);
          }
        }
      }
    }
    /**
     * Handles hammerjs event
     */

  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (this.isEmpty()) {
        return;
      }

      var mjolnirEvent = this._normalizeEvent(event);

      var target = event.srcEvent.target;

      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);

        if (mjolnirEvent.handled) {
          return;
        }

        target = target.parentNode;
      }

      this._emit(mjolnirEvent, 'root');
    }
    /**
     * Invoke handlers on a particular element
     */

  }, {
    key: "_emit",
    value: function _emit(event, srcElement) {
      var entries = this.handlersByElement.get(srcElement);

      if (entries) {
        var immediatePropagationStopped = false; // Prevents the current event from bubbling up

        var stopPropagation = function stopPropagation() {
          event.handled = true;
        }; // Prevent any remaining listeners from being called


        var stopImmediatePropagation = function stopImmediatePropagation() {
          event.handled = true;
          immediatePropagationStopped = true;
        };

        for (var i = 0; i < entries.length; i++) {
          var _entries$i = entries[i],
              type = _entries$i.type,
              handler = _entries$i.handler;
          handler(Object.assign({}, event, {
            type: type,
            stopPropagation: stopPropagation,
            stopImmediatePropagation: stopImmediatePropagation
          }));

          if (immediatePropagationStopped) {
            break;
          }
        }
      }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */

  }, {
    key: "_normalizeEvent",
    value: function _normalizeEvent(event) {
      var rootElement = this.eventManager.element;
      return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {
        handled: false,
        rootElement: rootElement
      });
    }
  }]);

  return EventRegistrar;
}();

export { EventRegistrar as default };