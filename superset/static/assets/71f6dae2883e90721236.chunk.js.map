{"version":3,"file":"71f6dae2883e90721236.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/path-layer/path.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"],"sourcesContent":["import { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({\n    startRow,\n    endRow\n  }) {\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value));\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        geometry = this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = geometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n      }, startRow, endRow);\n\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n\n    this._forEachGeometry((geometry, dataIndex) => {\n      geometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(geometry, context);\n    }, startRow, endRow);\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n\n}\n//# sourceMappingURL=tesselator.js.map","import { Tesselator } from '@deck.gl/core';\nimport { normalizePath } from './path';\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\nexport default class PathTesselator extends Tesselator {\n  constructor(opts) {\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        }\n      }\n    });\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return () => null;\n  }\n\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n\n    return path;\n  }\n\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  getGeometrySize(path) {\n    if (Array.isArray(path[0])) {\n      let size = 0;\n\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n\n      return size;\n    }\n\n    const numPoints = this.getPathLength(path);\n\n    if (numPoints < 2) {\n      return 0;\n    }\n\n    if (this.isClosed(path)) {\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n\n    return numPoints;\n  }\n\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n\n    if (path && Array.isArray(path[0])) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n\n      this._updatePositions(path, context);\n    }\n  }\n\n  _updateSegmentTypes(path, context) {\n    const {\n      segmentTypes\n    } = this.attributes;\n    const isPathClosed = this.isClosed(path);\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  _updatePositions(path, context) {\n    const {\n      positions\n    } = this.attributes;\n\n    if (!positions) {\n      return;\n    }\n\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    const p = new Array(3);\n\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n\n  getPointOnPath(path, index, target = []) {\n    const {\n      positionSize\n    } = this;\n\n    if (index * positionSize >= path.length) {\n      index += 1 - path.length / positionSize;\n    }\n\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = positionSize === 3 && path[i + 2] || 0;\n    return target;\n  }\n\n  isClosed(path) {\n    if (!this.normalize) {\n      return this.opts.loop;\n    }\n\n    const {\n      positionSize\n    } = this;\n    const lastPointIndex = path.length - positionSize;\n    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);\n  }\n\n}\n//# sourceMappingURL=path-tesselator.js.map","import { cutPolylineByGrid, cutPolylineByMercatorBounds } from '@math.gl/polygon';\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath = path;\n\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  }\n\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {\n      size,\n      gridResolution\n    });\n  }\n\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {\n      size\n    });\n  }\n\n  return flatPath;\n}\n//# sourceMappingURL=path.js.map","export default \"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute float instanceTypes;\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec3 instanceLeftPositions64Low;\\nattribute vec3 instanceStartPositions64Low;\\nattribute vec3 instanceEndPositions64Low;\\nattribute vec3 instanceRightPositions64Low;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float capType;\\nuniform float miterLimit;\\nuniform bool billboard;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\nvec3 lineJoin(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  vec2 width\\n) {\\n  bool isEnd = positions.x > 0.0;\\n  float sideOfPath = positions.y;\\n  float isJoint = float(sideOfPath == 0.0);\\n\\n  vec3 deltaA3 = (currPoint - prevPoint);\\n  vec3 deltaB3 = (nextPoint - currPoint);\\n\\n  mat3 rotationMatrix;\\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\\n  if (needsRotation) {\\n    deltaA3 = deltaA3 * rotationMatrix;\\n    deltaB3 = deltaB3 * rotationMatrix;\\n  }\\n  vec2 deltaA = deltaA3.xy / width;\\n  vec2 deltaB = deltaB3.xy / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = dirA + dirB;\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 dir = isEnd ? dirA : dirB;\\n  vec2 perp = isEnd ? perpA : perpB;\\n  float L = isEnd ? lenA : lenB;\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\\n  float cornerPosition = sideOfPath * turnDirection;\\n\\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\\n  miterSize = mix(\\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\\n    miterSize,\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\\n    * (sideOfPath + isJoint * turnDirection);\\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\\n  bool isCap = isStartCap || isEndCap;\\n  if (isCap) {\\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\\n    vJointType = capType;\\n  } else {\\n    vJointType = jointType;\\n  }\\n  vPathLength = L;\\n  vCornerOffset = offsetVec;\\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\\n  vMiterLength = isCap ? isJoint : vMiterLength;\\n\\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\\n  vPathPosition = vec2(\\n    dot(offsetFromStartOfPath, perp),\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n  geometry.uv = vPathPosition;\\n\\n  float isValid = step(instanceTypes, 3.5);\\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\\n\\n  if (needsRotation) {\\n    offset = rotationMatrix * offset;\\n  }\\n  return currPoint + offset;\\n}\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  geometry.worldPosition = instanceStartPositions;\\n  geometry.worldPositionAlt = instanceEndPositions;\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n  vec3 width;\\n\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\\n\\n  if (billboard) {\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    width = vec3(widthPixels, 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec3 pos = lineJoin(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w,\\n      project_pixel_size_to_clipspace(width.xy)\\n    );\\n\\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    prevPosition = project_position(prevPosition, prevPosition64Low);\\n    currPosition = project_position(currPosition, currPosition64Low);\\n    nextPosition = project_position(nextPosition, nextPosition64Low);\\n\\n    width = vec3(project_pixel_size(widthPixels), 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec4 pos = vec4(\\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\\n      1.0);\\n    geometry.position = pos;\\n    gl_Position = project_common_position_to_clipspace(pos);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-vertex.glsl.js.map","import { Layer, project32, picking, log } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  jointRounded: false,\n  capRounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  billboard: false,\n  _pathType: null,\n  getPath: {\n    type: 'accessor',\n    value: object => object.path\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  rounded: {\n    deprecatedFor: ['jointRounded', 'capRounded']\n  }\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nexport default class PathLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      positions: {\n        size: 3,\n        vertexOffset: 1,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: 5121,\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: 5121,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n\n    if (this.props.getDashArray && !this.props.extensions.length) {\n      log.removed('getDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({\n    oldProps,\n    props,\n    changeFlags\n  }) {\n    super.updateState({\n      props,\n      oldProps,\n      changeFlags\n    });\n    const attributeManager = this.getAttributeManager();\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n    if (geometryChanged) {\n      const {\n        pathTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      info.object = data.find(d => d.__source.index === index);\n    }\n\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      viewport\n    } = this.context;\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n    const widthMultiplier = widthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      jointType: Number(jointRounded),\n      capType: Number(capRounded),\n      billboard,\n      widthScale: widthScale * widthMultiplier,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];\n    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 4,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: {\n            value: new Float32Array(SEGMENT_POSITIONS),\n            size: 2\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculatePositions(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  calculateSegmentTypes(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n\n}\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;\n//# sourceMappingURL=path-layer.js.map","export default \"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float miterLimit;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nvoid main(void) {\\n  geometry.uv = vPathPosition;\\n\\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\\n      discard;\\n    }\\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\\n      discard;\\n    }\\n  }\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-fragment.glsl.js.map"],"names":["Tesselator","constructor","opts","attributes","this","typedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","normalizeGeometry","geometry","updateGeometryAttributes","startIndex","Error","getGeometrySize","value","ArrayBuffer","isView","offset","stride","_allocate","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","Infinity","normalizedData","dataIndex","length","buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","PathTesselator","super","padding","initialize","type","fp64","Float64Array","Float32Array","segmentTypes","Uint8ClampedArray","path","gridResolution","wrapLongitude","flatPath","i","j","normalizePath","resolution","get","attributeName","subPath","numPoints","getPathLength","isClosed","_updateSegmentTypes","_updatePositions","isPathClosed","fill","p","ptIndex","getPointOnPath","target","loop","lastPointIndex","DEFAULT_COLOR","defaultProps","widthUnits","widthScale","min","widthMinPixels","widthMaxPixels","Number","MAX_SAFE_INTEGER","jointRounded","capRounded","miterLimit","billboard","_pathType","getPath","getColor","getWidth","rounded","deprecatedFor","ATTRIBUTE_TRANSITION","enter","chunk","subarray","PathLayer","getShaders","vs","fs","modules","project32","picking","initializeState","getAttributeManager","addInstanced","vertexOffset","use64bitPositions","transition","accessor","update","calculatePositions","noAlloc","shaderAttributes","instanceLeftPositions","instanceStartPositions","instanceEndPositions","instanceRightPositions","instanceTypes","calculateSegmentTypes","instanceStrokeWidths","defaultValue","instanceColors","props","colorFormat","normalized","instancePickingColors","encodePickingColor","__source","setState","pathTesselator","getDashArray","extensions","log","updateState","oldProps","changeFlags","attributeManager","updateTriggersChanged","all","state","viewport","numInstances","invalidateAll","extensionsChanged","_this$state$model","gl","model","delete","_getModel","getPickingInfo","params","info","find","d","disablePickingIndex","objectIndex","_disablePickingIndex","draw","uniforms","widthMultiplier","metersPerPixel","setUniforms","jointType","capType","id","drawMode","indices","Uint16Array","isInstanced","attribute","layerName"],"sourceRoot":""}