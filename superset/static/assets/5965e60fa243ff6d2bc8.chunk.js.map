{"version":3,"file":"5965e60fa243ff6d2bc8.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/cpu-grid-layer/grid-aggregator.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/grid-aggregation-layer.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/gpu-grid-aggregator.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/grid-aggregation-utils.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/resource-utils.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js"],"sourcesContent":["import { createIterable } from '@deck.gl/core';\nimport { getGridOffset } from '../utils/grid-aggregation-utils';\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {\n    data = [],\n    cellSize\n  } = props;\n  const {\n    attributes,\n    viewport,\n    projectPoints,\n    numInstances\n  } = aggregationParams;\n  const positions = attributes.positions.value;\n  const {\n    size\n  } = attributes.positions.getAccessor();\n  const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset\n    };\n  }\n\n  const {\n    width,\n    height\n  } = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  const gridHash = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n  const position = new Array(3);\n\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n\n      if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {\n        const key = \"\".concat(yIndex, \"-\").concat(xIndex);\n        gridHash[key] = gridHash[key] || {\n          count: 0,\n          points: [],\n          lonIdx: xIndex,\n          latIdx: yIndex\n        };\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n\n  return {\n    gridHash,\n    gridOffset,\n    offsets: [offsets[0] * -1, offsets[1] * -1]\n  };\n}\n\nfunction getGridLayerDataFromGridHash({\n  gridHash,\n  gridOffset,\n  offsets\n}) {\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n    data[index] = {\n      index,\n      position: [offsets[0] + gridOffset.xOffset * lonIdx, offsets[1] + gridOffset.yOffset * latIdx],\n      ...gridHash[key]\n    };\n  }\n\n  return data;\n}\n\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  const positions = positionAttribute.value;\n  const {\n    size\n  } = positionAttribute.getAccessor();\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  };\n}\n//# sourceMappingURL=grid-aggregator.js.map","import AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\nexport default class GridAggregationLayer extends AggregationLayer {\n  initializeState({\n    dimensions\n  }) {\n    const {\n      gl\n    } = this.context;\n    super.initializeState(dimensions);\n    this.setState({\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {\n        id: \"\".concat(this.id, \"-gpu-aggregator\")\n      }),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    this.updateAggregationState(opts);\n    const {\n      aggregationDataDirty,\n      aggregationWeightsDirty,\n      gpuAggregation\n    } = this.state;\n\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n\n    let aggregationDirty = false;\n\n    if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n      this._updateAggregation(opts);\n\n      aggregationDirty = true;\n    }\n\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n\n      this._uploadAggregationResults();\n\n      aggregationDirty = true;\n    }\n\n    this.setState({\n      aggregationDirty\n    });\n  }\n\n  finalizeState() {\n    var _this$state$gpuGridAg;\n\n    const {\n      count\n    } = this.state.weights;\n\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n\n    (_this$state$gpuGridAg = this.state.gpuGridAggregator) === null || _this$state$gpuGridAg === void 0 ? void 0 : _this$state$gpuGridAg.delete();\n    super.finalizeState();\n  }\n\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  updateAggregationState(opts) {\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {\n        weights\n      } = this.state;\n\n      for (const name in weights) {\n        const weight = weights[name];\n\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: 5126,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({\n    aggregationData,\n    maxMinData,\n    maxData,\n    minData\n  }) {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      props\n    } = opts;\n    const {\n      viewport\n    } = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {\n        weights\n      } = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {\n      getValue\n    } = this.state;\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue\n    });\n    this.setState({\n      sortedBins\n    });\n  }\n\n  _uploadAggregationResults() {\n    const {\n      numCol,\n      numRow\n    } = this.state;\n    const {\n      data\n    } = this.state.layerData;\n    const {\n      aggregatedBins,\n      minValue,\n      maxValue,\n      totalCount\n    } = this.state.sortedBins;\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n\n    for (const bin of aggregatedBins) {\n      const {\n        lonIdx,\n        latIdx\n      } = data[bin.i];\n      const {\n        value,\n        counts\n      } = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({\n      aggregationData,\n      maxMinData,\n      maxData,\n      minData\n    });\n  }\n\n}\nGridAggregationLayer.layerName = 'GridAggregationLayer';\n//# sourceMappingURL=grid-aggregation-layer.js.map","import { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nexport const DEFAULT_RUN_PARAMS = {\n  projectPoints: false,\n  viewport: null,\n  createBufferObjects: true,\n  moduleSettings: {}\n};\nexport const MAX_32_BIT_FLOAT = 3.402823466e38;\nexport const MIN_BLEND_EQUATION = [32775, 32774];\nexport const MAX_BLEND_EQUATION = [32776, 32774];\nexport const MAX_MIN_BLEND_EQUATION = [32776, 32775];\nexport const EQUATION_MAP = {\n  [AGGREGATION_OPERATION.SUM]: 32774,\n  [AGGREGATION_OPERATION.MEAN]: 32774,\n  [AGGREGATION_OPERATION.MIN]: MIN_BLEND_EQUATION,\n  [AGGREGATION_OPERATION.MAX]: MAX_BLEND_EQUATION\n};\nexport const ELEMENTCOUNT = 4;\nexport const DEFAULT_WEIGHT_PARAMS = {\n  size: 1,\n  operation: AGGREGATION_OPERATION.SUM,\n  needMin: false,\n  needMax: false,\n  combineMaxMin: false\n};\nexport const PIXEL_SIZE = 4;\nexport const WEIGHT_SIZE = 3;\nexport const MAX_MIN_TEXTURE_OPTS = {\n  format: 34836,\n  type: 5126,\n  border: 0,\n  mipmaps: false,\n  parameters: {\n    [10240]: 9728,\n    [10241]: 9728\n  },\n  dataFormat: 6408,\n  width: 1,\n  height: 1\n};\n//# sourceMappingURL=gpu-grid-aggregator-constants.js.map","import { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nconst REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\nexport default class GPUGridAggregator {\n  static getAggregationData({\n    aggregationData,\n    maxData,\n    minData,\n    maxMinData,\n    pixelIndex\n  }) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n\n    return results;\n  }\n\n  static getCellData({\n    countsData,\n    size = 1\n  }) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n\n    for (let i = 0; i < numCells; i++) {\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n\n    return {\n      cellCounts,\n      cellWeights\n    };\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  delete() {\n    const {\n      gridAggregationModel,\n      allAggregationModel,\n      meanTransform\n    } = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n    gridAggregationModel === null || gridAggregationModel === void 0 ? void 0 : gridAggregationModel.delete();\n    allAggregationModel === null || allAggregationModel === void 0 ? void 0 : allAggregationModel.delete();\n    meanTransform === null || meanTransform === void 0 ? void 0 : meanTransform.delete();\n    deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n  }\n\n  run(opts = {}) {\n    this.setState({\n      results: {}\n    });\n\n    const aggregationParams = this._normalizeAggregationParams(opts);\n\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n\n    return this._runAggregation(aggregationParams);\n  }\n\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n\n    if (!results[weightId].aggregationData) {\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n\n    data.aggregationData = results[weightId].aggregationData;\n\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({\n      shaderOptions,\n      modelDirty: true\n    });\n  }\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = { ...DEFAULT_RUN_PARAMS,\n      ...opts\n    };\n    const {\n      weights\n    } = aggregationParams;\n\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n\n    return aggregationParams;\n  }\n\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {\n      weights\n    } = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {\n        needMin,\n        needMax,\n        combineMaxMin\n      } = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer,\n        sourceType: 5126\n      });\n\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer,\n          sourceType: 5126\n        });\n        results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer,\n            sourceType: 5126\n          });\n          results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n        }\n\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer,\n            sourceType: 5126\n          });\n          results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n        }\n      }\n    }\n\n    this._trackGPUResultBuffers(results, weights);\n\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [1, 1]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax\n      } = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: { ...parameters,\n            blendEquation: MAX_MIN_BLEND_EQUATION\n          },\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {\n            clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n          },\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: { ...parameters,\n              blendEquation: MIN_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {\n              clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n            },\n            combineMaxMin\n          });\n        }\n\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: { ...parameters,\n              blendEquation: MAX_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, 0]\n            },\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  _renderToMaxMinTexture(opts) {\n    const {\n      id,\n      parameters,\n      gridSize,\n      minOrMaxFb,\n      combineMaxMin,\n      clearParams = {}\n    } = opts;\n    const {\n      framebuffers\n    } = this.state;\n    const {\n      gl,\n      allAggregationModel\n    } = this;\n    withParameters(gl, { ...clearParams,\n      framebuffer: minOrMaxFb,\n      viewport: [0, 0, gridSize[0], gridSize[1]]\n    }, () => {\n      gl.clear(16384);\n      allAggregationModel.draw({\n        parameters,\n        uniforms: {\n          uSampler: framebuffers[id].texture,\n          gridSize,\n          combineMaxMin\n        }\n      });\n    });\n  }\n\n  _renderToWeightsTexture(opts) {\n    const {\n      id,\n      parameters,\n      moduleSettings,\n      uniforms,\n      gridSize,\n      weights\n    } = opts;\n    const {\n      framebuffers,\n      equations,\n      weightAttributes\n    } = this.state;\n    const {\n      gl,\n      gridAggregationModel\n    } = this;\n    const {\n      operation\n    } = weights[id];\n    const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n    withParameters(gl, {\n      framebuffer: framebuffers[id],\n      viewport: [0, 0, gridSize[0], gridSize[1]],\n      clearColor\n    }, () => {\n      gl.clear(16384);\n      const attributes = {\n        weights: weightAttributes[id]\n      };\n      gridAggregationModel.draw({\n        parameters: { ...parameters,\n          blendEquation: equations[id]\n        },\n        moduleSettings,\n        uniforms,\n        attributes\n      });\n    });\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {\n        meanTextures,\n        textures\n      } = this.state;\n      const transformOptions = {\n        _sourceTextures: {\n          aggregationValues: meanTextures[id]\n        },\n        _targetTexture: textures[id],\n        elementCount: textures[id].width * textures[id].height\n      };\n\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n      framebuffers[id].attach({\n        [36064]: textures[id]\n      });\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n\n    this._setupFramebuffers(opts);\n\n    this._renderAggregateData(opts);\n\n    const results = this._getAggregateData(opts);\n\n    this.setState({\n      results\n    });\n    return results;\n  }\n\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    const {\n      numCol,\n      numRow\n    } = opts;\n    const framebufferSize = {\n      width: numCol,\n      height: numRow\n    };\n\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax,\n        combineMaxMin,\n        operation\n      } = weights[id];\n      textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n        id: \"\".concat(id, \"-texture\"),\n        width: numCol,\n        height: numRow\n      });\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-mean-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n\n      if (framebuffers[id]) {\n        framebuffers[id].attach({\n          [36064]: texture\n        });\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: \"\".concat(id, \"-fb\"),\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n              id: \"\".concat(id, \"-maxMinFb\"),\n              texture\n            });\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-minFb\"),\n                texture\n              });\n            }\n          }\n\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxFb\"),\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  _getMinMaxTexture(name) {\n    const {\n      resources\n    } = this.state;\n\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {\n        id: \"resourceName\"\n      });\n    }\n\n    return resources[name];\n  }\n\n  _setupModels({\n    numCol = 0,\n    numRow = 0\n  } = {}) {\n    var _this$gridAggregation;\n\n    const {\n      gl\n    } = this;\n    const {\n      shaderOptions\n    } = this.state;\n    (_this$gridAggregation = this.gridAggregationModel) === null || _this$gridAggregation === void 0 ? void 0 : _this$gridAggregation.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  _setupWeightAttributes(opts) {\n    const {\n      weightAttributes\n    } = this.state;\n    const {\n      weights\n    } = opts;\n\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  _trackGPUResultBuffers(results, weights) {\n    const {\n      resources\n    } = this.state;\n\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            const name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n\n            if (resources[name]) {\n              resources[name].delete();\n            }\n\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n\n  _updateModels(opts) {\n    const {\n      vertexCount,\n      attributes,\n      numCol,\n      numRow\n    } = opts;\n    const {\n      modelDirty\n    } = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n\n      this.setState({\n        modelDirty: false\n      });\n    }\n\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n\n}\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n\n  for (const id in weights) {\n    result[id] = { ...DEFAULT_WEIGHT_PARAMS,\n      ...weights[id]\n    };\n  }\n\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n//# sourceMappingURL=gpu-grid-aggregator.js.map","export default \"#define SHADER_NAME gpu-aggregation-transform-mean-vs\\nattribute vec4 aggregationValues;\\nvarying vec4 meanValues;\\n\\nvoid main()\\n{\\n  bool isCellValid = bool(aggregationValues.w > 0.);\\n  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);\\n  meanValues.w = aggregationValues.w;\\n  gl_PointSize = 1.0;\\n}\\n\";\n//# sourceMappingURL=transform-mean-vs.glsl.js.map","export default \"#define SHADER_NAME gpu-aggregation-to-grid-vs\\n\\nattribute vec3 positions;\\nattribute vec3 positions64Low;\\nattribute vec3 weights;\\nuniform vec2 cellSize;\\nuniform vec2 gridSize;\\nuniform bool projectPoints;\\nuniform vec2 translation;\\nuniform vec3 scaling;\\n\\nvarying vec3 vWeights;\\n\\nvec2 project_to_pixel(vec4 pos) {\\n  vec4 result;\\n  pos.xy = pos.xy/pos.w;\\n  result = pos + vec4(translation, 0., 0.);\\n  result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;\\n  return result.xy;\\n}\\n\\nvoid main(void) {\\n\\n  vWeights = weights;\\n\\n  vec4 windowPos = vec4(positions, 1.);\\n  if (projectPoints) {\\n    windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));\\n  }\\n\\n  vec2 pos = project_to_pixel(windowPos);\\n\\n  vec2 pixelXY64[2];\\n  pixelXY64[0] = vec2(pos.x, 0.);\\n  pixelXY64[1] = vec2(pos.y, 0.);\\n  vec2 gridXY64[2];\\n  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\\n  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\\n  float x = floor(gridXY64[0].x);\\n  float y = floor(gridXY64[1].x);\\n  pos = vec2(x, y);\\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\\n  vec2 offset = 1.0 / gridSize;\\n  pos = pos + offset;\\n\\n  gl_Position = vec4(pos, 0.0, 1.0);\\n  gl_PointSize = 1.0;\\n}\\n\";\n//# sourceMappingURL=aggregate-to-grid-vs.glsl.js.map","export default \"#define SHADER_NAME gpu-aggregation-to-grid-fs\\n\\nprecision highp float;\\n\\nvarying vec3 vWeights;\\n\\nvoid main(void) {\\n  gl_FragColor = vec4(vWeights, 1.0);\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=aggregate-to-grid-fs.glsl.js.map","export default \"#version 300 es\\n#define SHADER_NAME gpu-aggregation-all-vs-64\\n\\nin vec2 position;\\nuniform ivec2 gridSize;\\nout vec2 vTextureCoord;\\n\\nvoid main(void) {\\n  vec2 pos = vec2(-1.0, -1.0);\\n  vec2 offset = 1.0 / vec2(gridSize);\\n  pos = pos + offset;\\n\\n  gl_Position = vec4(pos, 0.0, 1.0);\\n\\n  int yIndex = gl_InstanceID / gridSize[0];\\n  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);\\n\\n  vec2 yIndexFP64 = vec2(float(yIndex), 0.);\\n  vec2 xIndexFP64 = vec2(float(xIndex), 0.);\\n  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\\n  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\\n\\n  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\\n  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\\n\\n  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\\n  gl_PointSize = 1.0;\\n}\\n\";\n//# sourceMappingURL=aggregate-all-vs.glsl.js.map","export default \"#version 300 es\\n#define SHADER_NAME gpu-aggregation-all-fs\\n\\nprecision highp float;\\n\\nin vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform bool combineMaxMin;\\nout vec4 fragColor;\\nvoid main(void) {\\n  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\\n  if (textureColor.a == 0.) {\\n    discard;\\n  }\\n  fragColor.rgb = textureColor.rgb;\\n  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;\\n}\\n\";\n//# sourceMappingURL=aggregate-all-fs.glsl.js.map","import { log, COORDINATE_SYSTEM } from '@deck.gl/core';\nconst R_EARTH = 6378000;\n\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\n\nexport function getBoundingBox(attributes, vertexCount) {\n  const positions = attributes.positions.value;\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 3];\n    y = positions[i * 3 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  const boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n  return boundingBox;\n}\n\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n  const {\n    width,\n    height\n  } = viewport;\n  const worldOrigin = coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n  log.assert(coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.DEFAULT);\n  const {\n    xMin,\n    yMin\n  } = boundingBox;\n  return [-1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]), -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])];\n}\n\nexport function alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n  value = Math.floor(value / cellSize) * cellSize;\n  return value * sign;\n}\nexport function getGridOffset(boundingBox, cellSize, convertToMeters = true) {\n  if (!convertToMeters) {\n    return {\n      xOffset: cellSize,\n      yOffset: cellSize\n    };\n  }\n\n  const {\n    yMin,\n    yMax\n  } = boundingBox;\n  const centerLat = (yMin + yMax) / 2;\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n  const gridOffset = getGridOffset(boundingBox, cellSize, coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN);\n  const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n  const {\n    xMin,\n    yMin,\n    xMax,\n    yMax\n  } = boundingBox;\n  const width = xMax - xMin + gridOffset.xOffset;\n  const height = yMax - yMin + gridOffset.yOffset;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  return {\n    gridOffset,\n    translation,\n    width,\n    height,\n    numCol,\n    numRow\n  };\n}\n\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = calculateLatOffset(cellSize);\n  const xOffset = calculateLonOffset(latitude, cellSize);\n  return {\n    yOffset,\n    xOffset\n  };\n}\n\nfunction calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\n\nfunction calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}\n//# sourceMappingURL=grid-aggregation-utils.js.map","import { Framebuffer, Texture2D, isWebGL2 } from '@luma.gl/core';\nconst DEFAULT_PARAMETERS = {\n  [10240]: 9728,\n  [10241]: 9728\n};\nexport function getFloatTexture(gl, opts = {}) {\n  const {\n    width = 1,\n    height = 1,\n    data = null,\n    unpackFlipY = true,\n    parameters = DEFAULT_PARAMETERS\n  } = opts;\n  const texture = new Texture2D(gl, {\n    data,\n    format: isWebGL2(gl) ? 34836 : 6408,\n    type: 5126,\n    border: 0,\n    mipmaps: false,\n    parameters,\n    dataFormat: 6408,\n    width,\n    height,\n    unpackFlipY\n  });\n  return texture;\n}\nexport function getFramebuffer(gl, opts) {\n  const {\n    id,\n    width = 1,\n    height = 1,\n    texture\n  } = opts;\n  const fb = new Framebuffer(gl, {\n    id,\n    width,\n    height,\n    attachments: {\n      [36064]: texture\n    }\n  });\n  return fb;\n}\nexport function getFloatArray(array, size, fillValue = 0) {\n  if (!array || array.length < size) {\n    return new Float32Array(size).fill(fillValue);\n  }\n\n  return array;\n}\n//# sourceMappingURL=resource-utils.js.map","export function fp64ify(a, out = [], startIndex = 0) {\n  const hiPart = Math.fround(a);\n  const loPart = a - hiPart;\n  out[startIndex] = hiPart;\n  out[startIndex + 1] = loPart;\n  return out;\n}\nexport function fp64LowPart(a) {\n  return a - Math.fround(a);\n}\nexport function fp64ifyMatrix4(matrix) {\n  const matrixFP64 = new Float32Array(32);\n\n  for (let i = 0; i < 4; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      const index = i * 4 + j;\n      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);\n    }\n  }\n\n  return matrixFP64;\n}\n//# sourceMappingURL=fp64-utils.js.map","export default \"uniform float ONE;\\nvec2 split(float a) {\\n  const float SPLIT = 4097.0;\\n  float t = a * SPLIT;\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float a_hi = t * ONE - (t - a);\\n  float a_lo = a * ONE - a_hi;\\n#else\\n  float a_hi = t - (t - a);\\n  float a_lo = a - a_hi;\\n#endif\\n  return vec2(a_hi, a_lo);\\n}\\nvec2 split2(vec2 a) {\\n  vec2 b = split(a.x);\\n  b.y += a.y;\\n  return b;\\n}\\nvec2 quickTwoSum(float a, float b) {\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float sum = (a + b) * ONE;\\n  float err = b - (sum - a) * ONE;\\n#else\\n  float sum = a + b;\\n  float err = b - (sum - a);\\n#endif\\n  return vec2(sum, err);\\n}\\nvec2 twoSum(float a, float b) {\\n  float s = (a + b);\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float v = (s * ONE - a) * ONE;\\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\\n#else\\n  float v = s - a;\\n  float err = (a - (s - v)) + (b - v);\\n#endif\\n  return vec2(s, err);\\n}\\n\\nvec2 twoSub(float a, float b) {\\n  float s = (a - b);\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float v = (s * ONE - a) * ONE;\\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\\n#else\\n  float v = s - a;\\n  float err = (a - (s - v)) - (b + v);\\n#endif\\n  return vec2(s, err);\\n}\\n\\nvec2 twoSqr(float a) {\\n  float prod = a * a;\\n  vec2 a_fp64 = split(a);\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\\n#else\\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\\n#endif\\n  return vec2(prod, err);\\n}\\n\\nvec2 twoProd(float a, float b) {\\n  float prod = a * b;\\n  vec2 a_fp64 = split(a);\\n  vec2 b_fp64 = split(b);\\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\\n  return vec2(prod, err);\\n}\\n\\nvec2 sum_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSum(a.x, b.x);\\n  t = twoSum(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 sub_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSub(a.x, b.x);\\n  t = twoSub(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 mul_fp64(vec2 a, vec2 b) {\\n  vec2 prod = twoProd(a.x, b.x);\\n  prod.y += a.x * b.y;\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  prod = split2(prod);\\n#endif\\n  prod = quickTwoSum(prod.x, prod.y);\\n  prod.y += a.y * b.x;\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  prod = split2(prod);\\n#endif\\n  prod = quickTwoSum(prod.x, prod.y);\\n  return prod;\\n}\\n\\nvec2 div_fp64(vec2 a, vec2 b) {\\n  float xn = 1.0 / b.x;\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\\n#else\\n  vec2 yn = a * xn;\\n#endif\\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\\n  vec2 prod = twoProd(xn, diff);\\n  return sum_fp64(yn, prod);\\n}\\n\\nvec2 sqrt_fp64(vec2 a) {\\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\\n\\n  float x = 1.0 / sqrt(a.x);\\n  float yn = a.x * x;\\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\\n  vec2 yn_sqr = twoSqr(yn) * ONE;\\n#else\\n  vec2 yn_sqr = twoSqr(yn);\\n#endif\\n  float diff = sub_fp64(a, yn_sqr).x;\\n  vec2 prod = twoProd(x * 0.5, diff);\\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\\n  return sum_fp64(split(yn), prod);\\n#else\\n  return sum_fp64(vec2(yn, 0.0), prod);\\n#endif\\n}\\n\";\n//# sourceMappingURL=fp64-arithmetic.glsl.js.map","import { fp64ify, fp64LowPart, fp64ifyMatrix4 } from './fp64-utils';\nimport fp64arithmeticShader from './fp64-arithmetic.glsl';\nimport fp64functionShader from './fp64-functions.glsl';\nconst CONST_UNIFORMS = {\n  ONE: 1.0\n};\nexport { fp64ify, fp64LowPart, fp64ifyMatrix4 };\n\nfunction getUniforms() {\n  return CONST_UNIFORMS;\n}\n\nexport const fp64arithmetic = {\n  name: 'fp64-arithmetic',\n  vs: fp64arithmeticShader,\n  fs: null,\n  getUniforms,\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\nexport const fp64 = {\n  name: 'fp64',\n  vs: fp64functionShader,\n  fs: null,\n  dependencies: [fp64arithmetic],\n  fp64ify,\n  fp64LowPart,\n  fp64ifyMatrix4\n};\n//# sourceMappingURL=fp64.js.map"],"names":["pointToDensityGridDataCPU","props","aggregationParams","hashInfo","data","cellSize","attributes","viewport","projectPoints","numInstances","positions","value","size","getAccessor","boundingBox","positionAttribute","numInstance","y","x","yMin","Infinity","yMax","xMin","xMax","i","Number","isFinite","getPositionBoundingBox","offsets","posOffset","gridOffset","xOffset","yOffset","gridHash","width","height","numCol","Math","ceil","numRow","iterable","objectInfo","position","Array","pt","index","project","yIndex","floor","xIndex","key","concat","count","points","lonIdx","latIdx","push","source","pointsToGridHashing","result","Object","keys","length","idxs","split","parseInt","getGridLayerDataFromGridHash","GridAggregationLayer","initializeState","dimensions","gl","this","context","super","setState","layerData","gpuGridAggregator","id","cpuGridAggregator","updateState","opts","updateAggregationState","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","state","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","finalizeState","_this$state$gpuGridAg","weights","aggregationBuffer","delete","updateShaders","shaders","allocateResources","dataBytes","name","weight","byteLength","accessor","type","divisor","updateResults","aggregationData","maxMinData","maxData","minData","translation","scaling","getAttributes","vertexCount","run","moduleSettings","getModuleSettings","getValue","sortedBins","aggregatedBins","minValue","maxValue","totalCount","Float32Array","fill","bin","counts","cellIndex","layerName","DEFAULT_RUN_PARAMS","createBufferObjects","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","DEFAULT_WEIGHT_PARAMS","operation","needMin","needMax","combineMaxMin","BUFFER_NAMES","ARRAY_BUFFER_MAP","REQUIRED_FEATURES","GPUGridAggregator","static","pixelIndex","results","cellCount","cellWeight","maxCellWieght","minCellWeight","countsData","numCells","cellWeights","cellCounts","Uint32Array","sizeIndex","constructor","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","_setupModels","gridAggregationModel","allAggregationModel","meanTransform","isArray","forEach","obj","deleteResources","_normalizeAggregationParams","log","_runAggregation","getData","weightId","arrayName","bufferName","shaderOptions","modelDirty","normalizeWeightParams","updateObject","assign","_getAggregateData","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","framebuffer","clear","draw","uSampler","texture","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","update","vs","_targetTextureVarying","getMeanTransform","attach","_updateModels","_setupFramebuffers","framebufferSize","resize","SUM","_getMinMaxTexture","_this$gridAggregation","fs","modules","fp64","project32","drawMode","getAggregationModel","instanceCount","isInstanced","getAllAggregationModel","_setupWeightAttributes","setVertexCount","setAttributes","setInstanceCount","R_EARTH","toFinite","n","getBoundingBox","alignToCell","inValue","sign","abs","getGridOffset","convertToMeters","latitude","lat","PI","cos","calculateGridLatLonOffset","getGridParams","coordinateSystem","worldOrigin","getTranslation","DEFAULT_PARAMETERS","getFloatTexture","unpackFlipY","format","border","mipmaps","dataFormat","getFramebuffer","attachments","fp64ify","a","out","startIndex","hiPart","fround","loPart","CONST_UNIFORMS","ONE","fp64arithmetic","getUniforms","fp64LowPart","fp64ifyMatrix4","matrix","matrixFP64","j"],"sourceRoot":""}