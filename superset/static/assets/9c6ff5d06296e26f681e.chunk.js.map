{"version":3,"file":"9c6ff5d06296e26f681e.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js","webpack://superset/./plugins/legacy-preset-chart-deckgl/src/utils.js","webpack://superset/./plugins/legacy-preset-chart-deckgl/src/utils/getPointsFromPolygon.ts","webpack://superset/./plugins/legacy-preset-chart-deckgl/src/layers/Polygon/Polygon.jsx"],"sourcesContent":["import { CompositeLayer, createIterable, log } from '@deck.gl/core';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport * as Polygon from '../solid-polygon-layer/polygon';\nimport { replaceInRange } from '../utils';\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: defaultFillColor\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: defaultLineColor\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true\n};\nexport default class PolygonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      paths: []\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({\n    oldProps,\n    props,\n    changeFlags\n  }) {\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n      const paths = this.state.paths.slice();\n      const pathsDiff = changeFlags.dataChanged.map(dataRange => replaceInRange({\n        data: paths,\n        getIndex: p => p.__source.index,\n        dataRange,\n        replace: this._getPaths(dataRange)\n      }));\n      this.setState({\n        paths,\n        pathsDiff\n      });\n    } else if (geometryChanged) {\n      this.setState({\n        paths: this._getPaths(),\n        pathsDiff: null\n      });\n    }\n  }\n\n  _getPaths(dataRange = {}) {\n    const {\n      data,\n      getPolygon,\n      positionFormat,\n      _normalize\n    } = this.props;\n    const paths = [];\n    const positionSize = positionFormat === 'XY' ? 2 : 3;\n    const {\n      startRow,\n      endRow\n    } = dataRange;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      let polygon = getPolygon(object, objectInfo);\n\n      if (_normalize) {\n        polygon = Polygon.normalize(polygon, positionSize);\n      }\n\n      const {\n        holeIndices\n      } = polygon;\n      const positions = polygon.positions || polygon;\n\n      if (holeIndices) {\n        for (let i = 0; i <= holeIndices.length; i++) {\n          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n          paths.push(this.getSubLayerRow({\n            path\n          }, object, objectInfo.index));\n        }\n      } else {\n        paths.push(this.getSubLayerRow({\n          path: positions\n        }, object, objectInfo.index));\n      }\n    }\n\n    return paths;\n  }\n\n  renderLayers() {\n    const {\n      data,\n      _dataDiff,\n      stroked,\n      filled,\n      extruded,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      elevationScale,\n      transitions,\n      positionFormat\n    } = this.props;\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified\n    } = this.props;\n    const {\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      getPolygon,\n      updateTriggers,\n      material\n    } = this.props;\n    const {\n      paths,\n      pathsDiff\n    } = this.state;\n    const FillLayer = this.getSubLayerClass('fill', SolidPolygonLayer);\n    const StrokeLayer = this.getSubLayerClass('stroke', PathLayer);\n    const polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({\n      _dataDiff,\n      extruded,\n      elevationScale,\n      filled,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      getElevation,\n      getFillColor,\n      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,\n      material,\n      transitions\n    }, this.getSubLayerProps({\n      id: 'fill',\n      updateTriggers: {\n        getPolygon: updateTriggers.getPolygon,\n        getElevation: updateTriggers.getElevation,\n        getFillColor: updateTriggers.getFillColor,\n        lineColors: extruded && wireframe,\n        getLineColor: updateTriggers.getLineColor\n      }\n    }), {\n      data,\n      positionFormat,\n      getPolygon\n    });\n    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({\n      _dataDiff: pathsDiff && (() => pathsDiff),\n      widthUnits: lineWidthUnits,\n      widthScale: lineWidthScale,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels,\n      jointRounded: lineJointRounded,\n      miterLimit: lineMiterLimit,\n      dashJustified: lineDashJustified,\n      _pathType: 'loop',\n      transitions: transitions && {\n        getWidth: transitions.getLineWidth,\n        getColor: transitions.getLineColor,\n        getPath: transitions.getPolygon\n      },\n      getColor: this.getSubLayerAccessor(getLineColor),\n      getWidth: this.getSubLayerAccessor(getLineWidth),\n      getDashArray: this.getSubLayerAccessor(getLineDashArray)\n    }, this.getSubLayerProps({\n      id: 'stroke',\n      updateTriggers: {\n        getWidth: updateTriggers.getLineWidth,\n        getColor: updateTriggers.getLineColor,\n        getDashArray: updateTriggers.getLineDashArray\n      }\n    }), {\n      data: paths,\n      positionFormat,\n      getPath: x => x.path\n    });\n    return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];\n  }\n\n}\nPolygonLayer.layerName = 'PolygonLayer';\nPolygonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=polygon-layer.js.map","/* eslint-disable no-negated-condition */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { extent } from 'd3-array';\nimport { scaleThreshold } from 'd3-scale';\nimport {\n  getSequentialSchemeRegistry,\n  SequentialScheme,\n} from '@superset-ui/core';\nimport { hexToRGB } from './utils/colors';\n\nconst DEFAULT_NUM_BUCKETS = 10;\n\nexport function getBreakPoints(\n  { break_points: formDataBreakPoints, num_buckets: formDataNumBuckets },\n  features,\n  accessor,\n) {\n  if (!features) {\n    return [];\n  }\n  if (formDataBreakPoints === undefined || formDataBreakPoints.length === 0) {\n    // compute evenly distributed break points based on number of buckets\n    const numBuckets = formDataNumBuckets\n      ? parseInt(formDataNumBuckets, 10)\n      : DEFAULT_NUM_BUCKETS;\n    const [minValue, maxValue] = extent(features, accessor);\n    if (minValue === undefined) {\n      return [];\n    }\n    const delta = (maxValue - minValue) / numBuckets;\n    const precision =\n      delta === 0 ? 0 : Math.max(0, Math.ceil(Math.log10(1 / delta)));\n    const extraBucket = maxValue > maxValue.toFixed(precision) ? 1 : 0;\n    const startValue =\n      minValue < minValue.toFixed(precision) ? minValue - 1 : minValue;\n\n    return new Array(numBuckets + 1 + extraBucket)\n      .fill()\n      .map((_, i) => (startValue + i * delta).toFixed(precision));\n  }\n\n  return formDataBreakPoints.sort((a, b) => parseFloat(a) - parseFloat(b));\n}\n\nexport function getBreakPointColorScaler(\n  {\n    break_points: formDataBreakPoints,\n    num_buckets: formDataNumBuckets,\n    linear_color_scheme: linearColorScheme,\n    opacity,\n  },\n  features,\n  accessor,\n) {\n  const breakPoints =\n    formDataBreakPoints || formDataNumBuckets\n      ? getBreakPoints(\n          {\n            break_points: formDataBreakPoints,\n            num_buckets: formDataNumBuckets,\n          },\n          features,\n          accessor,\n        )\n      : null;\n  const colorScheme = Array.isArray(linearColorScheme)\n    ? new SequentialScheme({\n        colors: linearColorScheme,\n        id: 'custom',\n      })\n    : getSequentialSchemeRegistry().get(linearColorScheme);\n\n  let scaler;\n  let maskPoint;\n  if (breakPoints !== null) {\n    // bucket colors into discrete colors\n    const n = breakPoints.length - 1;\n    const bucketedColors =\n      n > 1\n        ? colorScheme.getColors(n)\n        : [colorScheme.colors[colorScheme.colors.length - 1]];\n\n    // repeat ends\n    const first = bucketedColors[0];\n    const last = bucketedColors[bucketedColors.length - 1];\n    bucketedColors.unshift(first);\n    bucketedColors.push(last);\n\n    const points = breakPoints.map(p => parseFloat(p));\n    scaler = scaleThreshold().domain(points).range(bucketedColors);\n    maskPoint = value => value > breakPoints[n] || value < breakPoints[0];\n  } else {\n    // interpolate colors linearly\n    scaler = colorScheme.createLinearScale(extent(features, accessor));\n    maskPoint = () => false;\n  }\n\n  return d => {\n    const v = accessor(d);\n    const c = hexToRGB(scaler(v));\n    if (maskPoint(v)) {\n      c[3] = 0;\n    } else {\n      c[3] = (opacity / 100) * 255;\n    }\n\n    return c;\n  };\n}\n\nexport function getBuckets(fd, features, accessor) {\n  const breakPoints = getBreakPoints(fd, features, accessor);\n  const colorScaler = getBreakPointColorScaler(fd, features, accessor);\n  const buckets = {};\n  breakPoints.slice(1).forEach((value, i) => {\n    const range = `${breakPoints[i]} - ${breakPoints[i + 1]}`;\n    const mid =\n      0.5 * (parseFloat(breakPoints[i]) + parseFloat(breakPoints[i + 1]));\n    // fix polygon doesn't show\n    const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;\n    buckets[range] = {\n      color: colorScaler({ [metricLabel || fd.metric]: mid }),\n      enabled: true,\n    };\n  });\n\n  return buckets;\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Point } from '../types';\n\n/** Format originally used by the Polygon plugin */\ntype CustomPolygonFeature = {\n  polygon: Point[];\n};\n\n/**\n * Format that is geojson standard\n * https://geojson.org/geojson-spec.html\n */\ntype GeojsonPolygonFeature = {\n  polygon: {\n    type: 'Feature';\n    geometry: {\n      type: 'Polygon';\n      coordinates: Point[][];\n    };\n  };\n};\n\nexport default function getPointsFromPolygon(\n  feature: CustomPolygonFeature | GeojsonPolygonFeature,\n) {\n  return 'geometry' in feature.polygon\n    ? feature.polygon.geometry.coordinates[0]\n    : feature.polygon;\n}\n","/* eslint-disable react/sort-prop-types */\n/* eslint-disable react/jsx-handler-names */\n/* eslint-disable react/no-access-state-in-setstate */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"\", \"__timestamp\"] }] */\n\nimport React from 'react';\nimport { t } from '@superset-ui/core';\nimport PropTypes from 'prop-types';\n\nimport { PolygonLayer } from 'deck.gl';\n\nimport AnimatableDeckGLContainer from '../../AnimatableDeckGLContainer';\nimport Legend from '../../components/Legend';\nimport TooltipRow from '../../TooltipRow';\nimport { getBuckets, getBreakPointColorScaler } from '../../utils';\n\nimport { commonLayerProps } from '../common';\nimport { getPlaySliderParams } from '../../utils/time';\nimport sandboxedEval from '../../utils/sandbox';\n// eslint-disable-next-line import/extensions\nimport getPointsFromPolygon from '../../utils/getPointsFromPolygon';\n// eslint-disable-next-line import/extensions\nimport fitViewport from '../../utils/fitViewport';\n\nconst DOUBLE_CLICK_THRESHOLD = 250; // milliseconds\n\nfunction getElevation(d, colorScaler) {\n  /* in deck.gl 5.3.4 (used in Superset as of 2018-10-24), if a polygon has\n   * opacity zero it will make everything behind it have opacity zero,\n   * effectively showing the map layer no matter what other polygons are\n   * behind it.\n   */\n  return colorScaler(d)[3] === 0 ? 0 : d.elevation;\n}\n\nfunction setTooltipContent(formData) {\n  return o => {\n    const metricLabel = formData.metric.label || formData.metric;\n\n    return (\n      <div className=\"deckgl-tooltip\">\n        {o.object.name && (\n          <TooltipRow\n            // eslint-disable-next-line prefer-template\n            label={t('name') + ': '}\n            value={`${o.object.name}`}\n          />\n        )}\n        {o.object[formData.line_column] && (\n          <TooltipRow\n            label={`${formData.line_column}: `}\n            value={`${o.object[formData.line_column]}`}\n          />\n        )}\n        {formData.metric && (\n          <TooltipRow\n            label={`${metricLabel}: `}\n            value={`${o.object[metricLabel]}`}\n          />\n        )}\n      </div>\n    );\n  };\n}\n\nexport function getLayer(\n  formData,\n  payload,\n  onAddFilter,\n  setTooltip,\n  selected,\n  onSelect,\n  filters,\n) {\n  const fd = formData;\n  const fc = fd.fill_color_picker;\n  const sc = fd.stroke_color_picker;\n  let data = [...payload.data.features];\n\n  if (filters != null) {\n    filters.forEach(f => {\n      data = data.filter(x => f(x));\n    });\n  }\n\n  if (fd.js_data_mutator) {\n    // Applying user defined data mutator if defined\n    const jsFnMutator = sandboxedEval(fd.js_data_mutator);\n    data = jsFnMutator(data);\n  }\n\n  const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;\n  const accessor = d => d[metricLabel];\n  // base color for the polygons\n  const baseColorScaler =\n    fd.metric === null\n      ? () => [fc.r, fc.g, fc.b, 255 * fc.a]\n      : getBreakPointColorScaler(fd, data, accessor);\n\n  // when polygons are selected, reduce the opacity of non-selected polygons\n  const colorScaler = d => {\n    const baseColor = baseColorScaler(d);\n    if (selected.length > 0 && !selected.includes(d[fd.line_column])) {\n      baseColor[3] /= 2;\n    }\n\n    return baseColor;\n  };\n\n  const tooltipContentGenerator =\n    fd.line_column &&\n    fd.metric &&\n    ['json', 'geohash', 'zipcode'].includes(fd.line_type)\n      ? setTooltipContent(fd)\n      : undefined;\n\n  return new PolygonLayer({\n    id: `path-layer-${fd.slice_id}`,\n    data,\n    pickable: true,\n    filled: fd.filled,\n    stroked: fd.stroked,\n    getPolygon: getPointsFromPolygon,\n    getFillColor: colorScaler,\n    getLineColor: [sc.r, sc.g, sc.b, 255 * sc.a],\n    getLineWidth: fd.line_width,\n    extruded: fd.extruded,\n    getElevation: d => getElevation(d, colorScaler),\n    elevationScale: fd.multiplier,\n    fp64: true,\n    ...commonLayerProps(fd, setTooltip, tooltipContentGenerator, onSelect),\n  });\n}\n\nconst propTypes = {\n  formData: PropTypes.object.isRequired,\n  payload: PropTypes.object.isRequired,\n  setControlValue: PropTypes.func.isRequired,\n  viewport: PropTypes.object.isRequired,\n  onAddFilter: PropTypes.func,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n};\n\nconst defaultProps = {\n  onAddFilter() {},\n};\n\nclass DeckGLPolygon extends React.Component {\n  containerRef = React.createRef();\n\n  constructor(props) {\n    super(props);\n\n    this.state = DeckGLPolygon.getDerivedStateFromProps(props);\n\n    this.getLayers = this.getLayers.bind(this);\n    this.onSelect = this.onSelect.bind(this);\n    this.onValuesChange = this.onValuesChange.bind(this);\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    const { width, height, formData, payload } = props;\n\n    // the state is computed only from the payload; if it hasn't changed, do\n    // not recompute state since this would reset selections and/or the play\n    // slider position due to changes in form controls\n    if (state && payload.form_data === state.formData) {\n      return null;\n    }\n\n    const features = payload.data.features || [];\n    const timestamps = features.map(f => f.__timestamp);\n\n    // the granularity has to be read from the payload form_data, not the\n    // props formData which comes from the instantaneous controls state\n    const granularity =\n      payload.form_data.time_grain_sqla ||\n      payload.form_data.granularity ||\n      'P1D';\n\n    const { start, end, getStep, values, disabled } = getPlaySliderParams(\n      timestamps,\n      granularity,\n    );\n\n    let { viewport } = props;\n    if (formData.autozoom) {\n      viewport = fitViewport(viewport, {\n        width,\n        height,\n        points: features.flatMap(getPointsFromPolygon),\n      });\n    }\n\n    return {\n      start,\n      end,\n      getStep,\n      values,\n      disabled,\n      viewport,\n      selected: [],\n      lastClick: 0,\n      formData: payload.form_data,\n    };\n  }\n\n  onSelect(polygon) {\n    const { formData, onAddFilter } = this.props;\n\n    const now = new Date();\n    const doubleClick = now - this.state.lastClick <= DOUBLE_CLICK_THRESHOLD;\n\n    // toggle selected polygons\n    const selected = [...this.state.selected];\n    if (doubleClick) {\n      selected.splice(0, selected.length, polygon);\n    } else if (formData.toggle_polygons) {\n      const i = selected.indexOf(polygon);\n      if (i === -1) {\n        selected.push(polygon);\n      } else {\n        selected.splice(i, 1);\n      }\n    } else {\n      selected.splice(0, 1, polygon);\n    }\n\n    this.setState({ selected, lastClick: now });\n    if (formData.table_filter) {\n      onAddFilter(formData.line_column, selected, false, true);\n    }\n  }\n\n  onValuesChange(values) {\n    this.setState({\n      values: Array.isArray(values)\n        ? values\n        : [values, values + this.state.getStep(values)],\n    });\n  }\n\n  getLayers(values) {\n    if (this.props.payload.data.features === undefined) {\n      return [];\n    }\n\n    const filters = [];\n\n    // time filter\n    if (values[0] === values[1] || values[1] === this.end) {\n      filters.push(\n        d => d.__timestamp >= values[0] && d.__timestamp <= values[1],\n      );\n    } else {\n      filters.push(\n        d => d.__timestamp >= values[0] && d.__timestamp < values[1],\n      );\n    }\n\n    const layer = getLayer(\n      this.props.formData,\n      this.props.payload,\n      this.props.onAddFilter,\n      this.setTooltip,\n      this.state.selected,\n      this.onSelect,\n      filters,\n    );\n\n    return [layer];\n  }\n\n  setTooltip = tooltip => {\n    const { current } = this.containerRef;\n    if (current) {\n      current.setTooltip(tooltip);\n    }\n  };\n\n  render() {\n    const { payload, formData, setControlValue } = this.props;\n    const { start, end, getStep, values, disabled, viewport } = this.state;\n\n    const fd = formData;\n    const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;\n    const accessor = d => d[metricLabel];\n\n    const buckets = getBuckets(formData, payload.data.features, accessor);\n\n    return (\n      <div style={{ position: 'relative' }}>\n        <AnimatableDeckGLContainer\n          ref={this.containerRef}\n          aggregation\n          getLayers={this.getLayers}\n          start={start}\n          end={end}\n          getStep={getStep}\n          values={values}\n          disabled={disabled}\n          viewport={viewport}\n          width={this.props.width}\n          height={this.props.height}\n          mapboxApiAccessToken={payload.data.mapboxApiKey}\n          mapStyle={formData.mapbox_style}\n          setControlValue={setControlValue}\n          onValuesChange={this.onValuesChange}\n          onViewportChange={this.onViewportChange}\n        >\n          {formData.metric !== null && (\n            <Legend\n              categories={buckets}\n              position={formData.legend_position}\n              format={formData.legend_format}\n            />\n          )}\n        </AnimatableDeckGLContainer>\n      </div>\n    );\n  }\n}\n\nDeckGLPolygon.propTypes = propTypes;\nDeckGLPolygon.defaultProps = defaultProps;\n\nexport default DeckGLPolygon;\n"],"names":["defaultLineColor","defaultProps","stroked","filled","extruded","elevationScale","wireframe","_normalize","_windingOrder","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","Number","MAX_SAFE_INTEGER","lineJointRounded","lineMiterLimit","getPolygon","type","value","f","polygon","getFillColor","getLineColor","getLineWidth","getElevation","material","PolygonLayer","initializeState","this","state","paths","props","getLineDashArray","log","updateState","oldProps","changeFlags","geometryChanged","dataChanged","updateTriggersChanged","all","Array","isArray","slice","pathsDiff","map","dataRange","data","getIndex","p","__source","index","replace","_getPaths","setState","positionFormat","positionSize","startRow","endRow","iterable","objectInfo","object","holeIndices","positions","i","length","path","push","getSubLayerRow","renderLayers","_dataDiff","transitions","lineDashJustified","updateTriggers","FillLayer","getSubLayerClass","StrokeLayer","polygonLayer","shouldRenderSubLayer","getSubLayerProps","id","lineColors","widthUnits","widthScale","widthMinPixels","widthMaxPixels","jointRounded","miterLimit","dashJustified","_pathType","getWidth","getColor","getPath","getSubLayerAccessor","getDashArray","x","layerName","getBreakPoints","features","accessor","break_points","formDataBreakPoints","num_buckets","formDataNumBuckets","undefined","numBuckets","parseInt","minValue","maxValue","extent","delta","precision","Math","max","ceil","log10","extraBucket","toFixed","startValue","fill","_","sort","a","b","parseFloat","getBreakPointColorScaler","linear_color_scheme","linearColorScheme","opacity","breakPoints","colorScheme","SequentialScheme","colors","getSequentialSchemeRegistry","get","scaler","maskPoint","n","bucketedColors","getColors","first","last","unshift","points","scaleThreshold","domain","range","createLinearScale","d","v","c","hexToRGB","getPointsFromPolygon","feature","geometry","coordinates","getLayer","formData","payload","onAddFilter","setTooltip","selected","onSelect","filters","fd","fc","fill_color_picker","sc","stroke_color_picker","forEach","filter","js_data_mutator","jsFnMutator","sandboxedEval","metricLabel","metric","label","baseColorScaler","r","g","colorScaler","baseColor","line_column","tooltipContentGenerator","line_type","o","className","name","TooltipRow","t","setTooltipContent","slice_id","pickable","line_width","elevation","multiplier","fp64","commonLayerProps","propTypes","PropTypes","setControlValue","viewport","width","height","DeckGLPolygon","React","constructor","super","containerRef","tooltip","current","getDerivedStateFromProps","getLayers","bind","onValuesChange","form_data","timestamps","__timestamp","granularity","time_grain_sqla","start","end","getStep","values","disabled","getPlaySliderParams","autozoom","fitViewport","flatMap","lastClick","now","Date","doubleClick","splice","toggle_polygons","indexOf","table_filter","render","buckets","mid","color","enabled","getBuckets","style","position","AnimatableDeckGLContainer","ref","aggregation","mapboxApiAccessToken","mapboxApiKey","mapStyle","mapbox_style","onViewportChange","Legend","categories","legend_position","format","legend_format"],"sourceRoot":""}