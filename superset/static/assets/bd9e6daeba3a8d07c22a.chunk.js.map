{"version":3,"file":"bd9e6daeba3a8d07c22a.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-cell-layer.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/gpu-grid-layer/gpu-grid-layer.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/cpu-grid-layer/cpu-grid-layer.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/grid-layer/grid-layer.js"],"sourcesContent":["import Geometry from '../geometry/geometry';\nimport { uid } from '@luma.gl/webgl';\nconst CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);\nconst CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);\nconst CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);\nconst CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\nconst ATTRIBUTES = {\n  POSITION: {\n    size: 3,\n    value: new Float32Array(CUBE_POSITIONS)\n  },\n  NORMAL: {\n    size: 3,\n    value: new Float32Array(CUBE_NORMALS)\n  },\n  TEXCOORD_0: {\n    size: 2,\n    value: new Float32Array(CUBE_TEX_COORDS)\n  }\n};\nexport default class CubeGeometry extends Geometry {\n  constructor(props = {}) {\n    const {\n      id = uid('cube-geometry')\n    } = props;\n    super({ ...props,\n      id,\n      indices: {\n        size: 1,\n        value: new Uint16Array(CUBE_INDICES)\n      },\n      attributes: { ...ATTRIBUTES,\n        ...props.attributes\n      }\n    });\n  }\n\n}\n//# sourceMappingURL=cube-geometry.js.map","export default \"#version 300 es\\n#define SHADER_NAME gpu-grid-cell-layer-vertex-shader\\n#define RANGE_COUNT 6\\n\\nin vec3 positions;\\nin vec3 normals;\\n\\nin vec4 colors;\\nin vec4 elevations;\\nin vec3 instancePickingColors;\\nuniform vec2 offset;\\nuniform bool extruded;\\nuniform float cellSize;\\nuniform float coverage;\\nuniform float opacity;\\nuniform float elevationScale;\\n\\nuniform ivec2 gridSize;\\nuniform vec2 gridOrigin;\\nuniform vec2 gridOriginLow;\\nuniform vec2 gridOffset;\\nuniform vec2 gridOffsetLow;\\nuniform vec4 colorRange[RANGE_COUNT];\\nuniform vec2 elevationRange;\\nuniform vec2 colorDomain;\\nuniform bool colorDomainValid;\\nuniform vec2 elevationDomain;\\nuniform bool elevationDomainValid;\\n\\nlayout(std140) uniform;\\nuniform ColorData\\n{\\n  vec4 maxMinCount;\\n} colorData;\\nuniform ElevationData\\n{\\n  vec4 maxMinCount;\\n} elevationData;\\n\\n#define EPSILON 0.00001\\nout vec4 vColor;\\n\\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\\n  vec4 outColor = vec4(0., 0., 0., 0.);\\n  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\\n    float domainRange = domain.y - domain.x;\\n    if (domainRange <= 0.) {\\n      outColor = colorRange[0];\\n    } else {\\n      float rangeCount = float(RANGE_COUNT);\\n      float rangeStep = domainRange / rangeCount;\\n      float idx = floor((value - domain.x) / rangeStep);\\n      idx = clamp(idx, 0., rangeCount - 1.);\\n      int intIdx = int(idx);\\n      outColor = colorRange[intIdx];\\n    }\\n  }\\n  return outColor;\\n}\\n\\nfloat linearScale(vec2 domain, vec2 range, float value) {\\n  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\\n    return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;\\n  }\\n  return -1.;\\n}\\n\\nvoid main(void) {\\n\\n  vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);\\n  vec4 color = quantizeScale(clrDomain, colorRange, colors.r);\\n\\n  float elevation = 0.0;\\n\\n  if (extruded) {\\n    vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);\\n    elevation = linearScale(elvDomain, elevationRange, elevations.r);\\n    elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;\\n  }\\n  float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);\\n  float dotRadius = cellSize / 2. * coverage * shouldRender;\\n\\n  int yIndex = (gl_InstanceID / gridSize[0]);\\n  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);\\n\\n  vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));\\n  instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));\\n  vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));\\n  instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));\\n\\n  vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);\\n  vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);\\n  vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);\\n  picking_setPickingColor(instancePickingColors);\\n\\n  vec4 position_commonspace;\\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, position_commonspace);\\n\\n  vec3 normals_commonspace = project_normal(normals);\\n\\n   if (extruded) {\\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, position_commonspace.xyz, normals_commonspace);\\n    vColor = vec4(lightColor, color.a * opacity) / 255.;\\n  } else {\\n    vColor = vec4(color.rgb, color.a * opacity) / 255.;\\n  }\\n}\\n\";\n//# sourceMappingURL=gpu-grid-cell-layer-vertex.glsl.js.map","import { Layer, fp64LowPart, project32, gouraudLighting, picking } from '@deck.gl/core';\nimport { Model, CubeGeometry } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  gridSize: {\n    type: 'array',\n    min: 0,\n    value: [1, 1]\n  },\n  gridOrigin: {\n    type: 'array',\n    min: 0,\n    value: [0, 0]\n  },\n  gridOffset: {\n    type: 'array',\n    min: 0,\n    value: [0, 0]\n  },\n  cellSize: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 1000\n  },\n  offset: {\n    type: 'array',\n    min: 0,\n    value: [1, 1]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  extruded: true,\n  material: true\n};\nexport default class GPUGridCellLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking, fp64arithmetic]\n    });\n  }\n\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      colors: {\n        size: 4,\n        noAlloc: true\n      },\n      elevations: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n\n    const model = this._getModel(gl);\n\n    this._setupUniformBuffer(model);\n\n    this.setState({\n      model\n    });\n  }\n\n  _getModel(gl) {\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    });\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOffset,\n      elevationRange,\n      colorMaxMinBuffer,\n      elevationMaxMinBuffer\n    } = this.props;\n    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n    const domainUniforms = this.getDomainUniforms();\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    this.state.model.setUniforms(uniforms).setUniforms(domainUniforms).setUniforms({\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOriginLow,\n      gridOffset,\n      gridOffsetLow,\n      colorRange,\n      elevationRange\n    }).draw();\n    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n  }\n\n  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.bind({\n      target: 35345,\n      index: COLOR_DATA_UBO_INDEX\n    });\n    elevationMaxMinBuffer.bind({\n      target: 35345,\n      index: ELEVATION_DATA_UBO_INDEX\n    });\n  }\n\n  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.unbind({\n      target: 35345,\n      index: COLOR_DATA_UBO_INDEX\n    });\n    elevationMaxMinBuffer.unbind({\n      target: 35345,\n      index: ELEVATION_DATA_UBO_INDEX\n    });\n  }\n\n  getDomainUniforms() {\n    const {\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const domainUniforms = {};\n\n    if (colorDomain !== null) {\n      domainUniforms.colorDomainValid = true;\n      domainUniforms.colorDomain = colorDomain;\n    } else {\n      domainUniforms.colorDomainValid = false;\n    }\n\n    if (elevationDomain !== null) {\n      domainUniforms.elevationDomainValid = true;\n      domainUniforms.elevationDomain = elevationDomain;\n    } else {\n      domainUniforms.elevationDomainValid = false;\n    }\n\n    return domainUniforms;\n  }\n\n  _setupUniformBuffer(model) {\n    const gl = this.context.gl;\n    const programHandle = model.program.handle;\n    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n  }\n\n}\nGPUGridCellLayer.layerName = 'GPUGridCellLayer';\nGPUGridCellLayer.defaultProps = defaultProps;\n//# sourceMappingURL=gpu-grid-cell-layer.js.map","export default \"#version 300 es\\n#define SHADER_NAME gpu-grid-cell-layer-fragment-shader\\n\\nprecision highp float;\\n\\nin vec4 vColor;\\n\\nout vec4 fragColor;\\n\\nvoid main(void) {\\n  fragColor = vColor;\\n  fragColor = picking_filterColor(fragColor);\\n}\\n\";\n//# sourceMappingURL=gpu-grid-cell-layer-fragment.glsl.js.map","import { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  extruded: false,\n  material: true\n};\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    const isSupported = GPUGridAggregator.isSupported(gl);\n\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n\n    super.initializeState({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false,\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      color: {\n        size: 3,\n        accessor: 'getColorWeight'\n      },\n      elevation: {\n        size: 3,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      return;\n    }\n\n    super.updateState(opts);\n    const {\n      aggregationDirty\n    } = this.state;\n\n    if (aggregationDirty) {\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n    const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n    return \"\".concat(latIdx, \"-\").concat(lonIdx);\n  }\n\n  getPositionForIndex(index) {\n    const {\n      numRow,\n      numCol,\n      boundingBox,\n      gridOffset\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({\n    info,\n    mode\n  }) {\n    const {\n      index\n    } = info;\n    let object = null;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator\n      } = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n\n      if (mode !== 'hover') {\n        const {\n          props\n        } = this;\n        let {\n          gridHash\n        } = this.state;\n\n        if (!gridHash) {\n          const {\n            gridOffset,\n            translation,\n            boundingBox\n          } = this.state;\n          const {\n            viewport\n          } = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({\n            gridHash\n          });\n        }\n\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const {\n      weights,\n      numRow,\n      numCol,\n      gridOrigin,\n      gridOffset\n    } = this.state;\n    const {\n      color,\n      elevation\n    } = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n    return new SubLayerClass({\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n      colorRange,\n      elevationRange,\n      colorDomain,\n      elevationDomain,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationScale,\n      extruded\n    }, this.getSubLayerProps({\n      id: 'gpu-grid-cell'\n    }), {\n      data: {\n        attributes: {\n          colors: color.aggregationBuffer,\n          elevations: elevation.aggregationBuffer\n        }\n      },\n      colorMaxMinBuffer: color.maxMinBuffer,\n      elevationMaxMinBuffer: elevation.maxMinBuffer,\n      numInstances: numCol * numRow\n    });\n  }\n\n  finalizeState() {\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {\n        aggregationBuffer,\n        maxMinBuffer\n      } = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    });\n    super.finalizeState();\n  }\n\n  updateAggregationState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const {\n      cellSize,\n      coordinateSystem\n    } = props;\n    const {\n      viewport\n    } = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {\n      dimensions\n    } = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n    let {\n      boundingBox\n    } = this.state;\n\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({\n        boundingBox\n      });\n    }\n\n    if (positionsChanged || cellSizeChanged) {\n      const {\n        gridOffset,\n        translation,\n        width,\n        height,\n        numCol,\n        numRow\n      } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {\n      dimension: dimensions.data,\n      compareAll: true\n    });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  _updateAccessors(opts) {\n    const {\n      colorAggregation,\n      elevationAggregation\n    } = opts.props;\n    const {\n      color,\n      elevation\n    } = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n\n}\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;\n//# sourceMappingURL=gpu-grid-layer.js.map","import { CubeGeometry } from '@luma.gl/core';\nimport ColumnLayer from './column-layer';\nconst defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  offset: {\n    type: 'array',\n    min: 0,\n    value: [1, 1]\n  }\n};\nexport default class GridCellLayer extends ColumnLayer {\n  getGeometry(diskResolution) {\n    return new CubeGeometry();\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      elevationScale,\n      extruded,\n      offset,\n      coverage,\n      cellSize,\n      angle\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      radius: cellSize / 2,\n      angle,\n      offset,\n      extruded,\n      coverage,\n      elevationScale,\n      edgeDistance: 1,\n      isWireframe: false\n    }).draw();\n  }\n\n}\nGridCellLayer.layerName = 'GridCellLayer';\nGridCellLayer.defaultProps = defaultProps;\n//# sourceMappingURL=grid-cell-layer.js.map","import { GridCellLayer } from '@deck.gl/layers';\nimport { defaultColorRange } from '../utils/color-utils';\nimport { pointToDensityGridDataCPU } from './grid-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer from '../aggregation-layer';\n\nfunction nop() {}\n\nconst defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  upperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n  gridAggregator: pointToDensityGridDataCPU,\n  cellSize: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  extruded: false,\n  material: true,\n  _filterData: {\n    type: 'function',\n    value: null,\n    optional: true\n  }\n};\nexport default class CPUGridLayer extends AggregationLayer {\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.gridAggregator,\n      getCellSize: props => props.cellSize\n    });\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition'\n      }\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    this.setState({\n      aggregatorState: this.state.cpuAggregator.updateState(opts, {\n        viewport: this.context.viewport,\n        attributes: this.getAttributes(),\n        numInstances: this.getNumInstances(opts.props)\n      })\n    });\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    return this.state.cpuAggregator.getPickingInfo({\n      info\n    });\n  }\n\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers() {\n    const {\n      elevationScale,\n      extruded,\n      cellSize,\n      coverage,\n      material,\n      transitions\n    } = this.props;\n    const {\n      cpuAggregator\n    } = this.state;\n    const SubLayerClass = this.getSubLayerClass('grid-cell', GridCellLayer);\n\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    return new SubLayerClass({\n      cellSize,\n      coverage,\n      material,\n      elevationScale,\n      extruded,\n      getFillColor: this._onGetSublayerColor.bind(this),\n      getElevation: this._onGetSublayerElevation.bind(this),\n      transitions: transitions && {\n        getFillColor: transitions.getColorValue || transitions.getColorWeight,\n        getElevation: transitions.getElevationValue || transitions.getElevationWeight\n      }\n    }, this.getSubLayerProps({\n      id: 'grid-cell',\n      updateTriggers\n    }), {\n      data: cpuAggregator.state.layerData.data\n    });\n  }\n\n}\nCPUGridLayer.layerName = 'CPUGridLayer';\nCPUGridLayer.defaultProps = defaultProps;\n//# sourceMappingURL=cpu-grid-layer.js.map","import { CompositeLayer } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport GPUGridLayer from '../gpu-grid-layer/gpu-grid-layer';\nimport CPUGridLayer from '../cpu-grid-layer/cpu-grid-layer';\nconst defaultProps = { ...GPUGridLayer.defaultProps,\n  ...CPUGridLayer.defaultProps,\n  gpuAggregation: false\n};\nexport default class GridLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      useGPUAggregation: true\n    };\n  }\n\n  updateState({\n    oldProps,\n    props,\n    changeFlags\n  }) {\n    const newState = {};\n    newState.useGPUAggregation = this.canUseGPUAggregation(props);\n    this.setState(newState);\n  }\n\n  renderLayers() {\n    const {\n      data,\n      updateTriggers\n    } = this.props;\n    const id = this.state.useGPUAggregation ? 'GPU' : 'CPU';\n    const LayerType = this.state.useGPUAggregation ? this.getSubLayerClass('GPU', GPUGridLayer) : this.getSubLayerClass('CPU', CPUGridLayer);\n    return new LayerType(this.props, this.getSubLayerProps({\n      id,\n      updateTriggers\n    }), {\n      data\n    });\n  }\n\n  canUseGPUAggregation(props) {\n    const {\n      gpuAggregation,\n      lowerPercentile,\n      upperPercentile,\n      getColorValue,\n      getElevationValue,\n      colorScaleType\n    } = props;\n\n    if (!gpuAggregation) {\n      return false;\n    }\n\n    if (!GPUGridAggregator.isSupported(this.context.gl)) {\n      return false;\n    }\n\n    if (lowerPercentile !== 0 || upperPercentile !== 100) {\n      return false;\n    }\n\n    if (getColorValue !== null || getElevationValue !== null) {\n      return false;\n    }\n\n    if (colorScaleType === 'quantile' || colorScaleType === 'ordinal') {\n      return false;\n    }\n\n    return true;\n  }\n\n}\nGridLayer.layerName = 'GridLayer';\nGridLayer.defaultProps = defaultProps;\n//# sourceMappingURL=grid-layer.js.map"],"names":["CUBE_INDICES","Uint16Array","CUBE_POSITIONS","Float32Array","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","POSITION","size","value","NORMAL","TEXCOORD_0","CubeGeometry","constructor","props","id","super","indices","attributes","defaultProps","colorDomain","colorRange","elevationDomain","elevationRange","elevationScale","type","min","gridSize","gridOrigin","gridOffset","cellSize","max","offset","coverage","extruded","material","GPUGridCellLayer","getShaders","vs","fs","modules","project32","picking","fp64","initializeState","gl","this","context","getAttributeManager","addInstanced","colors","noAlloc","elevations","model","_getModel","_setupUniformBuffer","setState","geometry","isInstanced","draw","uniforms","colorMaxMinBuffer","elevationMaxMinBuffer","gridOriginLow","gridOffsetLow","domainUniforms","getDomainUniforms","bindUniformBuffers","state","setUniforms","unbindUniformBuffers","bind","target","index","unbind","colorDomainValid","elevationDomainValid","programHandle","program","handle","colorIndex","getUniformBlockIndex","elevationIndex","uniformBlockBinding","layerName","getColorWeight","colorAggregation","getElevationWeight","elevationAggregation","getPosition","x","position","DIMENSIONS","data","POSITION_ATTRIBUTE_NAME","GPUGridLayer","isSupported","log","dimensions","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","byteLength","accessor","divisor","elevation","positionAttributeName","add","use64bitPositions","updateState","opts","aggregationDirty","gridHash","getHashKeyForIndex","numRow","numCol","boundingBox","xMin","yMin","xOffset","yOffset","yIndex","Math","floor","xIndex","latIdx","lonIdx","concat","getPositionForIndex","getPickingInfo","info","mode","object","gpuGridAggregator","colorInfo","pixelIndex","getData","elevationInfo","colorValue","cellWeight","elevationValue","count","cellCount","totalCount","translation","viewport","getAttributes","cpuAggregationData","Object","assign","picked","Boolean","renderLayers","cellSizeMeters","getSubLayerClass","getSubLayerProps","aggregationBuffer","numInstances","finalizeState","forEach","weight","delete","updateAggregationState","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","isAttributeChanged","attributesChanged","getNumInstances","width","height","allocateResources","aggregationDataDirty","isAggregationDirty","dimension","compareAll","_updateAccessors","operation","GridCellLayer","getGeometry","diskResolution","angle","radius","edgeDistance","isWireframe","nop","getColorValue","lowerPercentile","upperPercentile","colorScaleType","onSetColorDomain","getElevationValue","elevationLowerPercentile","elevationUpperPercentile","elevationScaleType","onSetElevationDomain","gridAggregator","_filterData","optional","CPUGridLayer","cpuAggregator","getAggregator","getCellSize","aggregatorState","positions","_onGetSublayerColor","cell","getAccessor","_onGetSublayerElevation","_getSublayerUpdateTriggers","getUpdateTriggers","transitions","SubLayerClass","updateTriggers","getFillColor","getElevation","layerData","GridLayer","useGPUAggregation","changeFlags","newState","canUseGPUAggregation"],"sourceRoot":""}