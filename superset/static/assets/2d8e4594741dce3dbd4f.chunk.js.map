{"version":3,"file":"2d8e4594741dce3dbd4f.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/utils.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js","webpack://superset/./node_modules/earcut/src/earcut.js"],"sourcesContent":["import earcut from 'earcut';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\nconst windingOptions = {\n  isClosed: true\n};\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n  const positions = [];\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    const {\n      positions: srcPositions,\n      holeIndices: srcHoleIndices\n    } = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions,\n        holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n      holeIndices.push(targetIndex);\n    }\n\n    holeIndices.pop();\n    return {\n      positions,\n      holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    const n = positions.length;\n    positions = positions.slice();\n    const p = [];\n\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  return earcut(positions, holeIndices, positionSize);\n}\n//# sourceMappingURL=polygon.js.map","import * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize);\n\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n    }\n\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      let size = 0;\n\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n\n      return size;\n    }\n\n    return (polygon.positions || polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  _updateIndices(polygon, {\n    geometryIndex,\n    vertexStart: offset,\n    indexStart\n  }) {\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n\n    if (!target) {\n      return;\n    }\n\n    let i = indexStart;\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  _updatePositions(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n\n    if (!positions) {\n      return;\n    }\n\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        vertexValid\n      },\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n\n}\n//# sourceMappingURL=polygon-tesselator.js.map","export default \"\\nattribute vec2 vertexPositions;\\nattribute float vertexValid;\\n\\nuniform bool extruded;\\nuniform bool isWireframe;\\nuniform float elevationScale;\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\n\\nstruct PolygonProps {\\n  vec4 fillColors;\\n  vec4 lineColors;\\n  vec3 positions;\\n  vec3 nextPositions;\\n  vec3 pickingColors;\\n  vec3 positions64Low;\\n  vec3 nextPositions64Low;\\n  float elevations;\\n};\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvoid calculatePosition(PolygonProps props) {\\n#ifdef IS_SIDE_VERTEX\\n  if(vertexValid < 0.5){\\n    gl_Position = vec4(0.);\\n    return;\\n  }\\n#endif\\n\\n  vec3 pos;\\n  vec3 pos64Low;\\n  vec3 normal;\\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\\n\\n  geometry.worldPosition = props.positions;\\n  geometry.worldPositionAlt = props.nextPositions;\\n  geometry.pickingColor = props.pickingColors;\\n\\n#ifdef IS_SIDE_VERTEX\\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\\n#else\\n  pos = props.positions;\\n  pos64Low = props.positions64Low;\\n#endif\\n\\n  if (extruded) {\\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\\n\\n#ifdef IS_SIDE_VERTEX\\n    normal = vec3(\\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\\n      0.0);\\n    normal = project_offset_normal(normal);\\n#else\\n    normal = vec3(0.0, 0.0, 1.0);\\n#endif\\n    geometry.normal = normal;\\n  }\\n\\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  if (extruded) {\\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\\n    vColor = vec4(lightColor, colors.a * opacity);\\n  } else {\\n    vColor = vec4(colors.rgb, colors.a * opacity);\\n  }\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=solid-polygon-layer-vertex-main.glsl.js.map","import main from './solid-polygon-layer-vertex-main.glsl';\nexport default \"#define SHADER_NAME solid-polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 positions64Low;\\nattribute float elevations;\\nattribute vec4 fillColors;\\nattribute vec4 lineColors;\\nattribute vec3 pickingColors;\\n\\n\".concat(main, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = positions;\\n  props.positions64Low = positions64Low;\\n  props.elevations = elevations;\\n  props.fillColors = fillColors;\\n  props.lineColors = lineColors;\\n  props.pickingColors = pickingColors;\\n\\n  calculatePosition(props);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-vertex-top.glsl.js.map","import main from './solid-polygon-layer-vertex-main.glsl';\nexport default \"#define SHADER_NAME solid-polygon-layer-vertex-shader-side\\n#define IS_SIDE_VERTEX\\n\\n\\nattribute vec3 instancePositions;\\nattribute vec3 nextPositions;\\nattribute vec3 instancePositions64Low;\\nattribute vec3 nextPositions64Low;\\nattribute float instanceElevations;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\n\".concat(main, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  #if RING_WINDING_ORDER_CW == 1\\n    props.positions = instancePositions;\\n    props.positions64Low = instancePositions64Low;\\n    props.nextPositions = nextPositions;\\n    props.nextPositions64Low = nextPositions64Low;\\n  #else\\n    props.positions = nextPositions;\\n    props.positions64Low = nextPositions64Low;\\n    props.nextPositions = instancePositions;\\n    props.nextPositions64Low = instancePositions64Low;\\n  #endif\\n  props.elevations = instanceElevations;\\n  props.fillColors = instanceFillColors;\\n  props.lineColors = instanceLineColors;\\n  props.pickingColors = instancePickingColors;\\n\\n  calculatePosition(props);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-vertex-side.glsl.js.map","import { Layer, project32, gouraudLighting, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry, hasFeatures, FEATURES } from '@luma.gl/core';\nimport PolygonTesselator from './polygon-tesselator';\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: true\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nexport default class SolidPolygonLayer extends Layer {\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudLighting, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const {\n      gl,\n      viewport\n    } = this.context;\n    let {\n      coordinateSystem\n    } = this.props;\n\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        preproject: coordinateSystem === COORDINATE_SYSTEM.LNGLAT && viewport.projectFlat,\n        fp64: this.use64bitPositions(),\n        IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      })\n    });\n    const attributeManager = this.getAttributeManager();\n    const noAlloc = true;\n    attributeManager.remove(['instancePickingColors']);\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: this.calculateIndices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          positions: {\n            vertexOffset: 0,\n            divisor: 0\n          },\n          instancePositions: {\n            vertexOffset: 0,\n            divisor: 1\n          },\n          nextPositions: {\n            vertexOffset: 1,\n            divisor: 1\n          }\n        }\n      },\n      vertexValid: {\n        size: 1,\n        divisor: 1,\n        type: 5121,\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation',\n        shaderAttributes: {\n          elevations: {\n            divisor: 0\n          },\n          instanceElevations: {\n            divisor: 1\n          }\n        }\n      },\n      fillColors: {\n        alias: 'colors',\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          fillColors: {\n            divisor: 0\n          },\n          instanceFillColors: {\n            divisor: 1\n          }\n        }\n      },\n      lineColors: {\n        alias: 'colors',\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          lineColors: {\n            divisor: 0\n          },\n          instanceLineColors: {\n            divisor: 1\n          }\n        }\n      },\n      pickingColors: {\n        size: 3,\n        type: 5121,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),\n        shaderAttributes: {\n          pickingColors: {\n            divisor: 0\n          },\n          instancePickingColors: {\n            divisor: 1\n          }\n        }\n      }\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      info.object = data.find(d => d.__source.index === index);\n    }\n\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      extruded,\n      filled,\n      wireframe,\n      elevationScale\n    } = this.props;\n    const {\n      topModel,\n      sideModel,\n      polygonTesselator\n    } = this.state;\n    const renderUniforms = { ...uniforms,\n      extruded: Boolean(extruded),\n      elevationScale\n    };\n\n    if (sideModel) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.setUniforms(renderUniforms);\n\n      if (wireframe) {\n        sideModel.setDrawMode(3);\n        sideModel.setUniforms({\n          isWireframe: true\n        }).draw();\n      }\n\n      if (filled) {\n        sideModel.setDrawMode(6);\n        sideModel.setUniforms({\n          isWireframe: false\n        }).draw();\n      }\n    }\n\n    if (topModel) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.setUniforms(renderUniforms).draw();\n    }\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    this.updateGeometry(updateParams);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = updateParams;\n    const attributeManager = this.getAttributeManager();\n    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      var _this$state$models;\n\n      (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach(model => model.delete());\n      this.setState(this._getModels(this.context.gl));\n      attributeManager.invalidateAll();\n    }\n  }\n\n  updateGeometry({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n    if (geometryConfigChanged) {\n      const {\n        polygonTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }\n\n  _getModels(gl) {\n    const {\n      id,\n      filled,\n      extruded\n    } = this.props;\n    let topModel;\n    let sideModel;\n\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n      topModel = new Model(gl, { ...shaders,\n        id: \"\".concat(id, \"-top\"),\n        drawMode: 4,\n        attributes: {\n          vertexPositions: new Float32Array([0, 1])\n        },\n        uniforms: {\n          isWireframe: false,\n          isSideVertex: false\n        },\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n\n    if (extruded) {\n      sideModel = new Model(gl, { ...this.getShaders('side'),\n        id: \"\".concat(id, \"-side\"),\n        geometry: new Geometry({\n          drawMode: 1,\n          vertexCount: 4,\n          attributes: {\n            vertexPositions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        instanceCount: 0,\n        isInstanced: 1\n      });\n      sideModel.userData.excludeAttributes = {\n        indices: true\n      };\n    }\n\n    return {\n      models: [sideModel, topModel].filter(Boolean),\n      topModel,\n      sideModel\n    };\n  }\n\n  calculateIndices(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  calculatePositions(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n\n}\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nSolidPolygonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=solid-polygon-layer.js.map","export default \"#define SHADER_NAME solid-polygon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=solid-polygon-layer-fragment.glsl.js.map","export function replaceInRange({\n  data,\n  getIndex,\n  dataRange,\n  replace\n}) {\n  const {\n    startRow = 0,\n    endRow = Infinity\n  } = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  const endChunk = dataLengthChanged && data.slice(replaceEnd);\n\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n\n  if (dataLengthChanged) {\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n//# sourceMappingURL=utils.js.map","export default \"#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\\n\\nstruct AmbientLight {\\n vec3 color;\\n};\\n\\nstruct PointLight {\\n vec3 color;\\n vec3 position;\\n vec3 attenuation;\\n};\\n\\nstruct DirectionalLight {\\n  vec3 color;\\n  vec3 direction;\\n};\\n\\nuniform AmbientLight lighting_uAmbientLight;\\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\\nuniform int lighting_uPointLightCount;\\nuniform int lighting_uDirectionalLightCount;\\n\\nuniform bool lighting_uEnabled;\\n\\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\\n  return pointLight.attenuation.x\\n       + pointLight.attenuation.y * distance\\n       + pointLight.attenuation.z * distance * distance;\\n}\\n\\n#endif\\n\";\n//# sourceMappingURL=lights.glsl.js.map","import lightingShader from './lights.glsl';\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor({\n  color = [0, 0, 0],\n  intensity = 1.0\n} = {}) {\n  return color.map(component => component * intensity / 255.0);\n}\n\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          lightSources.ambientLight = light;\n          break;\n\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n\n        default:\n      }\n    }\n\n    return getUniforms({\n      lightSources\n    });\n  }\n\n  return {};\n}\n\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n//# sourceMappingURL=lights.js.map","import { lights } from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {\n    ambient = 0.35,\n    diffuse = 0.6,\n    shininess = 32,\n    specularColor = [30, 30, 30]\n  } = material;\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {\n    material\n  } = opts;\n\n  if (!material) {\n    return {\n      lighting_uEnabled: false\n    };\n  }\n\n  return getMaterialUniforms(material);\n}\n\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n//# sourceMappingURL=phong-lighting.js.map","export default \"\\nuniform float lighting_uAmbient;\\nuniform float lighting_uDiffuse;\\nuniform float lighting_uShininess;\\nuniform vec3  lighting_uSpecularColor;\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normal_worldspace);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\\n      specular = pow(specular_angle, lighting_uShininess);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\\n}\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = surfaceColor;\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = vec3(0, 0, 0);\\n  vec3 surfaceColor = vec3(0, 0, 0);\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\";\n//# sourceMappingURL=phong-lighting.glsl.js.map","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n"],"names":["OUTER_POLYGON_WINDING","HOLE_POLYGON_WINDING","windingOptions","isClosed","copyNestedRing","target","targetStartIndex","simplePolygon","size","windingDirection","targetIndex","len","length","i","j","p0","p1","isNestedRingClosed","start","end","copyFlatRing","positions","srcStartIndex","srcEndIndex","srcLength","startIndex","endIndex","isFlatRingClosed","normalize","polygon","positionSize","Array","isArray","ArrayBuffer","isView","Error","validate","holeIndices","srcPositions","srcHoleIndices","push","pop","Number","isFinite","isSimple","polygonIndex","entries","getSurfaceIndices","normalizedPolygon","preproject","map","positionIndex","n","slice","p","xy","PolygonTesselator","constructor","opts","fp64","IndexType","Uint32Array","super","attributes","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","this","subarray","vertexCount","updateGeometry","externalIndices","buffers","value","normalizeGeometry","resolution","gridResolution","edgeTypes","wrapLongitude","maxLatitude","getGeometrySize","subPolygon","getGeometryFromBuffer","buffer","updateGeometryAttributes","context","geometrySize","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","offset","typedArrayManager","allocate","copy","polygonPositions","x","y","z","set","fill","concat","DEFAULT_COLOR","defaultProps","filled","extruded","wireframe","_normalize","_windingOrder","elevationScale","min","getPolygon","f","getElevation","getFillColor","getLineColor","material","ATTRIBUTE_TRANSITION","enter","chunk","SolidPolygonLayer","getShaders","vs","fs","defines","RING_WINDING_ORDER_CW","props","modules","project32","picking","initializeState","gl","viewport","coordinateSystem","isGeospatial","setState","numInstances","polygonTesselator","projectFlat","use64bitPositions","Uint16Array","attributeManager","getAttributeManager","noAlloc","remove","add","isIndexed","update","calculateIndices","transition","accessor","calculatePositions","shaderAttributes","vertexOffset","divisor","instancePositions","nextPositions","calculateVertexValid","elevations","instanceElevations","fillColors","alias","colorFormat","normalized","defaultValue","instanceFillColors","lineColors","instanceLineColors","pickingColors","object","index","encodePickingColor","__source","instancePickingColors","getPickingInfo","params","info","data","find","d","disablePickingIndex","objectIndex","_disablePickingIndex","draw","uniforms","topModel","sideModel","state","renderUniforms","Boolean","setInstanceCount","instanceCount","setUniforms","setDrawMode","isWireframe","setVertexCount","updateState","updateParams","oldProps","changeFlags","_this$state$models","extensionsChanged","models","forEach","model","delete","_getModels","invalidateAll","dataChanged","updateTriggersChanged","all","geometryBuffer","getGeometry","positionFormat","startIndices","vertexStarts","id","shaders","NON_INSTANCED_MODEL","drawMode","vertexPositions","isSideVertex","geometry","isInstanced","userData","excludeAttributes","filter","attribute","layerName","replaceInRange","getIndex","dataRange","replace","startRow","endRow","Infinity","count","replaceStart","replaceEnd","row","dataLengthChanged","endChunk","INITIAL_MODULE_OPTIONS","lightSources","convertColor","color","intensity","component","gouraudLighting","name","dependencies","getUniforms","ambientLight","pointLights","directionalLights","Object","assign","lightSourceUniforms","pointLight","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getLightSourceUniforms","lighting_uEnabled","light","lights","MAX_LIGHTS","LIGHTING_VERTEX","ambient","diffuse","shininess","specularColor","lighting_uAmbient","lighting_uDiffuse","lighting_uShininess","lighting_uSpecularColor","getMaterialUniforms","earcut","dim","minX","minY","maxX","maxY","invSize","hasHoles","outerLen","outerNode","linkedList","triangles","next","prev","list","queue","steiner","getLeftmost","sort","compareX","eliminateHole","eliminateHoles","Math","max","earcutLinked","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","again","area","ear","pass","zOrder","prevZ","nextZ","q","e","tail","numMerges","pSize","qSize","inSize","sortLinked","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","y0","x1","y1","pointInTriangle","minZ","maxZ","intersects","locallyInside","isValidDiagonal","splitPolygon","hole","bridge","m","hx","hy","qx","tan","mx","my","tanMin","abs","sectorContainsSector","findHoleBridge","bridgeReverse","leftmost","px","py","intersectsPolygon","inside","middleInside","r","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","num","a2","Node","b2","an","bp","sum","module","exports","deviation","polygonArea","trianglesArea","flatten","result","vertices","holes","dimensions","holeIndex"],"sourceRoot":""}