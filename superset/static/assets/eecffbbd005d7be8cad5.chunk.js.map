{"version":3,"file":"eecffbbd005d7be8cad5.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer-vertex.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-cell-layer.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer-fragment.glsl.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/screen-grid-layer/screen-grid-layer.js","webpack://superset/./plugins/legacy-preset-chart-deckgl/src/layers/Screengrid/Screengrid.jsx"],"sourcesContent":["export default \"#define SHADER_NAME screen-grid-layer-vertex-shader\\n#define RANGE_COUNT 6\\n\\nattribute vec3 positions;\\nattribute vec3 instancePositions;\\nattribute vec4 instanceCounts;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform vec3 cellScale;\\nuniform vec4 minColor;\\nuniform vec4 maxColor;\\nuniform vec4 colorRange[RANGE_COUNT];\\nuniform vec2 colorDomain;\\nuniform bool shouldUseMinMax;\\nuniform sampler2D maxTexture;\\n\\nvarying vec4 vColor;\\nvarying float vSampleCount;\\n\\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\\n  vec4 outColor = vec4(0., 0., 0., 0.);\\n  if (value >= domain.x && value <= domain.y) {\\n    float domainRange = domain.y - domain.x;\\n    if (domainRange <= 0.) {\\n      outColor = colorRange[0];\\n    } else {\\n      float rangeCount = float(RANGE_COUNT);\\n      float rangeStep = domainRange / rangeCount;\\n      float idx = floor((value - domain.x) / rangeStep);\\n      idx = clamp(idx, 0., rangeCount - 1.);\\n      int intIdx = int(idx);\\n      outColor = colorRange[intIdx];\\n    }\\n  }\\n  outColor = outColor / 255.;\\n  return outColor;\\n}\\n\\nvoid main(void) {\\n  vSampleCount = instanceCounts.a;\\n\\n  float weight = instanceCounts.r;\\n  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;\\n\\n  float step = weight / maxWeight;\\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\\n\\n  vec2 domain = colorDomain;\\n  float domainMaxValid = float(colorDomain.y != 0.);\\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\\n\\n  float rangeMinMax = float(shouldUseMinMax);\\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\\n  vColor = vec4(color.rgb, color.a * opacity);\\n  picking_setPickingColor(instancePickingColors);\\n\\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\\n}\\n\";\n//# sourceMappingURL=screen-grid-layer-vertex.glsl.js.map","import { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nconst defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {\n      vs,\n      fs,\n      modules: [picking]\n    };\n  }\n\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        update: this.calculateInstancePositions\n      },\n      instanceCounts: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({\n    oldProps,\n    props,\n    changeFlags\n  }) {\n    super.updateState({\n      oldProps,\n      props,\n      changeFlags\n    });\n    const attributeManager = this.getAttributeManager();\n\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      parameters,\n      maxTexture\n    } = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {\n      model\n    } = this.state;\n    model.setUniforms(uniforms).setUniforms({\n      minColor,\n      maxColor,\n      maxTexture,\n      colorDomain\n    }).draw({\n      parameters: {\n        depthTest: false,\n        depthMask: false,\n        ...parameters\n      }\n    });\n  }\n\n  calculateInstancePositions(attribute, {\n    numInstances\n  }) {\n    const {\n      width,\n      height\n    } = this.context.viewport;\n    const {\n      cellSizePixels\n    } = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n    const {\n      value,\n      size\n    } = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n      value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  _getModel(gl) {\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {\n      minColor,\n      maxColor,\n      colorDomain,\n      colorRange\n    } = this.props;\n\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n\n    if (colorDomain || colorRange) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {\n      model\n    } = this.state;\n\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({\n        shouldUseMinMax: this._shouldUseMinMax()\n      });\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({\n        colorRange: colorRangeToFlatArray(props.colorRange)\n      });\n    }\n\n    if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n      const {\n        width,\n        height\n      } = this.context.viewport;\n      const {\n        cellSizePixels,\n        cellMarginPixels\n      } = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n      const cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n      model.setUniforms({\n        cellScale\n      });\n    }\n  }\n\n}\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n//# sourceMappingURL=screen-grid-cell-layer.js.map","export default \"#define SHADER_NAME screen-grid-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\nvarying float vSampleCount;\\n\\nvoid main(void) {\\n  if (vSampleCount <= 0.0) {\\n    discard;\\n  }\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=screen-grid-layer-fragment.glsl.js.map","import { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nconst defaultProps = { ...ScreenGridCellLayer.defaultProps,\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {\n          id: \"\".concat(this.id, \"-max-texture\")\n        })\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true,\n      weights,\n      subLayerData: {\n        attributes: {}\n      },\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n\n    const {\n      maxTexture,\n      numRow,\n      numCol,\n      weights\n    } = this.state;\n    const {\n      updateTriggers\n    } = this.props;\n    const {\n      aggregationBuffer\n    } = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer',\n      updateTriggers\n    }), {\n      data: {\n        attributes: {\n          instanceCounts: aggregationBuffer\n        }\n      },\n      maxTexture,\n      numInstances: numRow * numCol\n    });\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    const {\n      aggregationBuffer,\n      maxBuffer,\n      maxTexture\n    } = this.state;\n    aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n    maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n  }\n\n  getPickingInfo({\n    info,\n    mode\n  }) {\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator,\n        gpuAggregation,\n        weights\n      } = this.state;\n      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  updateResults({\n    aggregationData,\n    maxData\n  }) {\n    const {\n      count\n    } = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({\n      data: aggregationData\n    });\n    count.maxData = maxData;\n    count.maxTexture.setImageData({\n      data: maxData\n    });\n  }\n\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {\n      viewportChanged\n    } = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      dimensions\n    } = this.state;\n    const {\n      data,\n      weights\n    } = dimensions;\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n      compareAll: gpuAggregation,\n      dimension: data\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n    const {\n      viewport\n    } = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {\n        width,\n        height\n      } = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        scaling: [width / 2, -height / 2, 1],\n        gridOffset: {\n          xOffset: cellSize,\n          yOffset: cellSize\n        },\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n}\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\n//# sourceMappingURL=screen-grid-layer.js.map","/* eslint-disable react/sort-prop-types */\n/* eslint-disable react/jsx-handler-names */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"\", \"__timestamp\"] }] */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { ScreenGridLayer } from 'deck.gl';\nimport { t } from '@superset-ui/core';\nimport AnimatableDeckGLContainer from '../../AnimatableDeckGLContainer';\nimport { getPlaySliderParams } from '../../utils/time';\nimport sandboxedEval from '../../utils/sandbox';\nimport { commonLayerProps } from '../common';\nimport TooltipRow from '../../TooltipRow';\n// eslint-disable-next-line import/extensions\nimport fitViewport from '../../utils/fitViewport';\n\nfunction getPoints(data) {\n  return data.map(d => d.position);\n}\n\nfunction setTooltipContent(o) {\n  return (\n    <div className=\"deckgl-tooltip\">\n      <TooltipRow\n        // eslint-disable-next-line prefer-template\n        label={t('Longitude and Latitude') + ': '}\n        value={`${o.coordinate[0]}, ${o.coordinate[1]}`}\n      />\n      <TooltipRow\n        // eslint-disable-next-line prefer-template\n        label={t('Weight') + ': '}\n        value={`${o.object.cellWeight}`}\n      />\n    </div>\n  );\n}\n\nexport function getLayer(\n  formData,\n  payload,\n  onAddFilter,\n  setTooltip,\n  selected,\n  onSelect,\n  filters,\n) {\n  const fd = formData;\n  const c = fd.color_picker;\n  let data = payload.data.features.map(d => ({\n    ...d,\n    color: [c.r, c.g, c.b, 255 * c.a],\n  }));\n\n  if (fd.js_data_mutator) {\n    // Applying user defined data mutator if defined\n    const jsFnMutator = sandboxedEval(fd.js_data_mutator);\n    data = jsFnMutator(data);\n  }\n\n  if (filters != null) {\n    filters.forEach(f => {\n      data = data.filter(x => f(x));\n    });\n  }\n\n  // Passing a layer creator function instead of a layer since the\n  // layer needs to be regenerated at each render\n  return new ScreenGridLayer({\n    id: `screengrid-layer-${fd.slice_id}`,\n    data,\n    pickable: true,\n    cellSizePixels: fd.grid_size,\n    minColor: [c.r, c.g, c.b, 0],\n    maxColor: [c.r, c.g, c.b, 255 * c.a],\n    outline: false,\n    getWeight: d => d.weight || 0,\n    ...commonLayerProps(fd, setTooltip, setTooltipContent),\n  });\n}\n\nconst propTypes = {\n  formData: PropTypes.object.isRequired,\n  payload: PropTypes.object.isRequired,\n  setControlValue: PropTypes.func.isRequired,\n  viewport: PropTypes.object.isRequired,\n  onAddFilter: PropTypes.func,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n};\nconst defaultProps = {\n  onAddFilter() {},\n};\n\nclass DeckGLScreenGrid extends React.PureComponent {\n  containerRef = React.createRef();\n\n  constructor(props) {\n    super(props);\n\n    this.state = DeckGLScreenGrid.getDerivedStateFromProps(props);\n\n    this.getLayers = this.getLayers.bind(this);\n    this.onValuesChange = this.onValuesChange.bind(this);\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // the state is computed only from the payload; if it hasn't changed, do\n    // not recompute state since this would reset selections and/or the play\n    // slider position due to changes in form controls\n    if (state && props.payload.form_data === state.formData) {\n      return null;\n    }\n\n    const features = props.payload.data.features || [];\n    const timestamps = features.map(f => f.__timestamp);\n\n    // the granularity has to be read from the payload form_data, not the\n    // props formData which comes from the instantaneous controls state\n    const granularity =\n      props.payload.form_data.time_grain_sqla ||\n      props.payload.form_data.granularity ||\n      'P1D';\n\n    const { start, end, getStep, values, disabled } = getPlaySliderParams(\n      timestamps,\n      granularity,\n    );\n    const { width, height, formData } = props;\n\n    let { viewport } = props;\n    if (formData.autozoom) {\n      viewport = fitViewport(viewport, {\n        width,\n        height,\n        points: getPoints(features),\n      });\n    }\n\n    return {\n      start,\n      end,\n      getStep,\n      values,\n      disabled,\n      viewport,\n      selected: [],\n      lastClick: 0,\n      formData: props.payload.form_data,\n    };\n  }\n\n  onValuesChange(values) {\n    this.setState({\n      values: Array.isArray(values)\n        ? values\n        : // eslint-disable-next-line react/no-access-state-in-setstate\n          [values, values + this.state.getStep(values)],\n    });\n  }\n\n  getLayers(values) {\n    const filters = [];\n\n    // time filter\n    if (values[0] === values[1] || values[1] === this.end) {\n      filters.push(\n        d => d.__timestamp >= values[0] && d.__timestamp <= values[1],\n      );\n    } else {\n      filters.push(\n        d => d.__timestamp >= values[0] && d.__timestamp < values[1],\n      );\n    }\n\n    const layer = getLayer(\n      this.props.formData,\n      this.props.payload,\n      this.props.onAddFilter,\n      this.setTooltip,\n      filters,\n    );\n\n    return [layer];\n  }\n\n  setTooltip = tooltip => {\n    const { current } = this.containerRef;\n    if (current) {\n      current.setTooltip(tooltip);\n    }\n  };\n\n  render() {\n    const { formData, payload, setControlValue } = this.props;\n\n    return (\n      <div>\n        <AnimatableDeckGLContainer\n          ref={this.containerRef}\n          aggregation\n          getLayers={this.getLayers}\n          start={this.state.start}\n          end={this.state.end}\n          getStep={this.state.getStep}\n          values={this.state.values}\n          disabled={this.state.disabled}\n          viewport={this.state.viewport}\n          width={this.props.width}\n          height={this.props.height}\n          mapboxApiAccessToken={payload.data.mapboxApiKey}\n          mapStyle={formData.mapbox_style}\n          setControlValue={setControlValue}\n          onValuesChange={this.onValuesChange}\n          onViewportChange={this.onViewportChange}\n        />\n      </div>\n    );\n  }\n}\n\nDeckGLScreenGrid.propTypes = propTypes;\nDeckGLScreenGrid.defaultProps = defaultProps;\n\nexport default DeckGLScreenGrid;\n"],"names":["DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","ScreenGridCellLayer","static","gl","getShaders","vs","fs","modules","picking","initializeState","this","context","getAttributeManager","addInstanced","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","setState","model","_getModel","shouldUpdateState","changeFlags","somethingChanged","updateState","oldProps","props","super","attributeManager","numInstances","invalidateAll","invalidate","_updateUniforms","draw","uniforms","parameters","maxTexture","minColor","maxColor","state","setUniforms","depthTest","depthMask","attribute","width","height","viewport","numCol","Math","ceil","i","x","y","floor","id","geometry","drawMode","attributes","positions","Float32Array","isInstanced","_shouldUseMinMax","log","some","key","shouldUseMinMax","viewportChanged","margin","cellScale","layerName","getPosition","type","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","weights","accessors","ScreenGridLayer","isSupported","supported","concat","dimensions","getCellSize","count","operation","needMax","projectPoints","subLayerData","positionAttributeName","posOffset","translation","add","accessor","fp64","use64bitPositions","opts","renderLayers","numRow","updateTriggers","aggregationBuffer","getSubLayerClass","getSubLayerProps","finalizeState","maxBuffer","delete","getPickingInfo","info","mode","index","gpuGridAggregator","aggregationResults","getData","object","pixelIndex","updateResults","aggregationData","maxData","setData","setImageData","updateAggregationState","cellSize","cellSizeChanged","gpuAggregationChanged","positionsChanged","isAttributeChanged","aggregationDataDirty","isAggregationDirty","compareAll","dimension","aggregationWeightsDirty","allocateResources","scaling","gridOffset","xOffset","yOffset","_updateAccessors","_resetResults","getValue","setTooltipContent","o","className","TooltipRow","label","t","coordinate","cellWeight","getLayer","formData","payload","onAddFilter","setTooltip","selected","onSelect","filters","fd","c","color_picker","features","map","color","r","g","b","a","js_data_mutator","jsFnMutator","sandboxedEval","forEach","f","filter","slice_id","pickable","grid_size","outline","weight","commonLayerProps","propTypes","PropTypes","setControlValue","DeckGLScreenGrid","React","constructor","containerRef","tooltip","current","getDerivedStateFromProps","getLayers","bind","onValuesChange","form_data","timestamps","__timestamp","granularity","time_grain_sqla","start","end","getStep","values","disabled","getPlaySliderParams","autozoom","fitViewport","points","lastClick","Array","isArray","push","render","AnimatableDeckGLContainer","ref","mapboxApiAccessToken","mapboxApiKey","mapStyle","mapbox_style","onViewportChange"],"sourceRoot":""}