{"version":3,"file":"f78780e94e356fb88436.chunk.js","mappings":"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","sources":["webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/roundDecimal.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/geo.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/luminanceFromRGB.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/MapBox.jsx"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport default function roundDecimal(number, precision) {\n  let roundedNumber;\n  let p = precision;\n  if (precision) {\n    roundedNumber = Math.round(number * (p = 10 ** p)) / p;\n  } else {\n    roundedNumber = Math.round(number);\n  }\n\n  return roundedNumber;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport roundDecimal from './roundDecimal';\n\nexport const EARTH_CIRCUMFERENCE_KM = 40075.16;\nexport const MILES_PER_KM = 1.60934;\n\nexport function kmToPixels(kilometers, latitude, zoomLevel) {\n  // Algorithm from: http://wiki.openstreetmap.org/wiki/Zoom_levels\n  const latitudeRad = latitude * (Math.PI / 180);\n  // Seems like the zoomLevel is off by one\n  const kmPerPixel =\n    (EARTH_CIRCUMFERENCE_KM * Math.cos(latitudeRad)) / 2 ** (zoomLevel + 9);\n\n  return roundDecimal(kilometers / kmPerPixel, 2);\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const LUMINANCE_RED_WEIGHT = 0.2126;\nexport const LUMINANCE_GREEN_WEIGHT = 0.7152;\nexport const LUMINANCE_BLUE_WEIGHT = 0.0722;\n\nexport default function luminanceFromRGB(r, g, b) {\n  // Formula: https://en.wikipedia.org/wiki/Relative_luminance\n  return (\n    LUMINANCE_RED_WEIGHT * r +\n    LUMINANCE_GREEN_WEIGHT * g +\n    LUMINANCE_BLUE_WEIGHT * b\n  );\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n"],"names":["roundDecimal","number","precision","roundedNumber","p","Math","round","kmToPixels","kilometers","latitude","zoomLevel","latitudeRad","PI","cos","propTypes","aggregation","PropTypes","compositeOperation","dotRadius","lngLatAccessor","locations","isRequired","pointRadiusUnit","renderWhileDragging","rgb","zoom","ScatterPlotGlowOverlay","React","constructor","props","super","this","redraw","bind","drawText","ctx","pixel","options","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","height","isDragging","project","clusterLabelMap","forEach","location","i","properties","cluster","count","point_count","sum","mean","squaredSum","variance","sqrt","computeClusterLabel","maxLabel","max","filter","v","Number","isNaN","clearRect","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointLabel","pointRadius","pointLatitude","undefined","render","defaultProps","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","aggregatorName","clusterer","globalOpacity","hasCustomMetric","mapStyle","mapboxApiKey","onViewportChange","bounds","MapBox","mercator","ViewportMercator","fitBounds","longitude","state","viewport","handleViewportChange","setState","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","mapboxApiAccessToken","preserveDrawingBuffer","coordinates","geometry"],"sourceRoot":""}