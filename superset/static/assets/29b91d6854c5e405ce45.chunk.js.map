{"version":3,"file":"29b91d6854c5e405ce45.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@math.gl/polygon/dist/esm/polygon-utils.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/lineclip.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/utils.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"],"sourcesContent":["import { equals } from '@math.gl/core';\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nexport function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\nexport function getPolygonSignedAreaPoints(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  let area = 0;\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n//# sourceMappingURL=polygon-utils.js.map","import { push, copy, getPointAtIndex } from './utils';\nexport function clipPolyline(positions, bbox, options = {}) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  const result = [];\n  let part = [];\n  let a;\n  let b;\n  let codeA = -1;\n  let codeB;\n  let lastCode;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nexport function clipPolygon(positions, bbox, options = {}) {\n  const {\n    size = 2,\n    endIndex = positions.length\n  } = options;\n  let {\n    startIndex = 0\n  } = options;\n  let numPoints = (endIndex - startIndex) / size;\n  let result;\n  let p;\n  let prev;\n  let inside;\n  let prevInside;\n\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nexport function intersect(a, b, edge, bbox, out = []) {\n  let t;\n  let snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n\n  return out;\n}\nexport function bitCode(p, bbox) {\n  let code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n//# sourceMappingURL=lineclip.js.map","export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}\n//# sourceMappingURL=utils.js.map","import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions, options = {}) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nexport function cutPolygonByGrid(positions, holeIndices, options = {}) {\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options;\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n//# sourceMappingURL=cut-by-grid.js.map","import { cutPolylineByGrid, cutPolygonByGrid } from './cut-by-grid';\nimport { getPointAtIndex, push } from './utils';\nconst DEFAULT_MAX_LATITUDE = 85.051129;\nexport function cutPolylineByMercatorBounds(positions, options = {}) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length,\n    normalize = true\n  } = options;\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n\n  return parts;\n}\nexport function cutPolygonByMercatorBounds(positions, holeIndices, options = {}) {\n  const {\n    size = 2,\n    normalize = true,\n    edgeTypes = false\n  } = options;\n  holeIndices = holeIndices || [];\n  const newPositions = [];\n  const newHoleIndices = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    const targetStartIndex = targetIndex;\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  let maxLat = -1;\n  let pointIndex = -1;\n\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  let prevLng = positions[0];\n  let lng;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  let refLng;\n  const pointCount = positions.length / size;\n\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map"],"names":["WINDING","CLOCKWISE","COUNTER_CLOCKWISE","points","direction","options","windingDirection","Math","sign","start","end","length","dim","size","area","i","j","getPolygonWindingDirection","numPoints","numSwaps","floor","b1","b2","tmp","reversePolygon","intersect","a","b","edge","bbox","out","t","snap","bitCode","p","code","target","source","startIndex","isDuplicate","positions","index","offset","startI","cutPolylineByGrid","broken","gridResolution","gridOffset","endIndex","part","result","codeB","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","push","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","Array","fill","holes","shift","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","side","type","prev","prevSide","prevType","lowPointCount","highPointCount","left","bottom","minX","Infinity","maxX","minY","maxY","x","y","cutPolylineByMercatorBounds","normalize","newPositions","slice","wrapLongitudesForShortestPath","shiftLongitudesIntoRange","cutPolygonByMercatorBounds","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","findSplitIndex","insertPoleVertices","maxLatitude","pop","maxLat","pointIndex","lat","abs","firstLng","lastLng","round","lng","prevLng","delta","refLng","pointCount"],"sourceRoot":""}