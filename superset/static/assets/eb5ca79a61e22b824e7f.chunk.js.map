{"version":3,"file":"eb5ca79a61e22b824e7f.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/prop-utils.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/aggregation-layer.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/aggregation-operation-utils.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/bin-sorter.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/color-utils.js","webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/scale-utils.js","webpack://superset/./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"],"sourcesContent":["export function filterProps(props, filterKeys) {\n  const filteredProps = {};\n\n  for (const key in props) {\n    if (!filterKeys.includes(key)) {\n      filteredProps[key] = props[key];\n    }\n  }\n\n  return filteredProps;\n}\n//# sourceMappingURL=prop-utils.js.map","import { CompositeLayer, AttributeManager, _compareProps as compareProps } from '@deck.gl/core';\nimport { cssToDeviceRatio } from '@luma.gl/core';\nimport { filterProps } from './utils/prop-utils';\nexport default class AggregationLayer extends CompositeLayer {\n  initializeState(dimensions) {\n    super.initializeState();\n    this.setState({\n      ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),\n      dimensions\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    const {\n      changeFlags\n    } = opts;\n\n    if (changeFlags.extensionsChanged) {\n      const shaders = this.getShaders({});\n\n      if (shaders && shaders.defines) {\n        shaders.defines.NON_INSTANCED_MODEL = 1;\n      }\n\n      this.updateShaders(shaders);\n    }\n\n    this._updateAttributes(opts.props);\n  }\n\n  updateAttributes(changedAttributes) {\n    this.setState({\n      changedAttributes\n    });\n  }\n\n  getAttributes() {\n    return this.getAttributeManager().getShaderAttributes();\n  }\n\n  getModuleSettings() {\n    const {\n      viewport,\n      mousePosition,\n      gl\n    } = this.context;\n    const moduleSettings = Object.assign(Object.create(this.props), {\n      viewport,\n      mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(gl)\n    });\n    return moduleSettings;\n  }\n\n  updateShaders(shaders) {}\n\n  isAggregationDirty(updateOpts, params = {}) {\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = updateOpts;\n    const {\n      compareAll = false,\n      dimension\n    } = params;\n    const {\n      ignoreProps\n    } = this.state;\n    const {\n      props: dataProps,\n      accessors = []\n    } = dimension;\n    const {\n      updateTriggersChanged\n    } = changeFlags;\n\n    if (changeFlags.dataChanged) {\n      return true;\n    }\n\n    if (updateTriggersChanged) {\n      if (updateTriggersChanged.all) {\n        return true;\n      }\n\n      for (const accessor of accessors) {\n        if (updateTriggersChanged[accessor]) {\n          return true;\n        }\n      }\n    }\n\n    if (compareAll) {\n      if (changeFlags.extensionsChanged) {\n        return true;\n      }\n\n      return compareProps({\n        oldProps,\n        newProps: props,\n        ignoreProps,\n        propTypes: this.constructor._propTypes\n      });\n    }\n\n    for (const name of dataProps) {\n      if (props[name] !== oldProps[name]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isAttributeChanged(name) {\n    const {\n      changedAttributes\n    } = this.state;\n\n    if (!name) {\n      return !isObjectEmpty(changedAttributes);\n    }\n\n    return changedAttributes && changedAttributes[name] !== undefined;\n  }\n\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n}\n\nfunction isObjectEmpty(obj) {\n  let isEmpty = true;\n\n  for (const key in obj) {\n    isEmpty = false;\n    break;\n  }\n\n  return isEmpty;\n}\n\nAggregationLayer.layerName = 'AggregationLayer';\n//# sourceMappingURL=aggregation-layer.js.map","export const AGGREGATION_OPERATION = {\n  SUM: 1,\n  MEAN: 2,\n  MIN: 3,\n  MAX: 4\n};\n\nfunction sumReducer(accu, cur) {\n  return accu + cur;\n}\n\nfunction maxReducer(accu, cur) {\n  return cur > accu ? cur : accu;\n}\n\nfunction minReducer(accu, cur) {\n  return cur < accu ? cur : accu;\n}\n\nexport function getMean(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;\n}\nexport function getSum(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? pts.length * accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(sumReducer, 0) : null;\n}\nexport function getMax(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;\n}\nexport function getMin(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n  return filtered.length ? filtered.reduce(minReducer, Infinity) : null;\n}\nexport function getValueFunc(aggregation, accessor, context) {\n  const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;\n  accessor = wrapAccessor(accessor, context);\n\n  switch (op) {\n    case AGGREGATION_OPERATION.MIN:\n      return pts => getMin(pts, accessor);\n\n    case AGGREGATION_OPERATION.SUM:\n      return pts => getSum(pts, accessor);\n\n    case AGGREGATION_OPERATION.MEAN:\n      return pts => getMean(pts, accessor);\n\n    case AGGREGATION_OPERATION.MAX:\n      return pts => getMax(pts, accessor);\n\n    default:\n      return null;\n  }\n}\n\nfunction wrapAccessor(accessor, context = {}) {\n  if (Number.isFinite(accessor)) {\n    return accessor;\n  }\n\n  return pt => {\n    context.index = pt.index;\n    return accessor(pt.source, context);\n  };\n}\n\nexport function wrapGetValueFunc(getValue, context = {}) {\n  return pts => {\n    context.indices = pts.map(pt => pt.index);\n    return getValue(pts.map(pt => pt.source), context);\n  };\n}\n//# sourceMappingURL=aggregation-operation-utils.js.map","const defaultGetValue = points => points.length;\n\nimport { clamp, getQuantileDomain, getOrdinalDomain } from './scale-utils';\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n\nconst defaultGetPoints = bin => bin.points;\n\nconst defaultGetIndex = bin => bin.index;\n\nconst ascending = (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n\nconst defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\nexport default class BinSorter {\n  constructor(bins = [], props = defaultProps) {\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n\n    this._updateMinMaxValues();\n\n    this.binMap = this.getBinMap();\n  }\n\n  getAggregatedBins(bins, props) {\n    const {\n      getValue = defaultGetValue,\n      getPoints = defaultGetPoints,\n      getIndex = defaultGetIndex,\n      filterData\n    } = props;\n    const hasFilter = typeof filterData === 'function';\n    const binCount = bins.length;\n    const aggregatedBins = [];\n    let index = 0;\n\n    for (let binIndex = 0; binIndex < binCount; binIndex++) {\n      const bin = bins[binIndex];\n      const points = getPoints(bin);\n      const i = getIndex(bin);\n      const filteredPoints = hasFilter ? points.filter(filterData) : points;\n      bin.filteredPoints = hasFilter ? filteredPoints : null;\n      const value = filteredPoints.length ? getValue(filteredPoints) : null;\n\n      if (value !== null && value !== undefined) {\n        aggregatedBins[index] = {\n          i: Number.isFinite(i) ? i : binIndex,\n          value,\n          counts: filteredPoints.length\n        };\n        index++;\n      }\n    }\n\n    return aggregatedBins;\n  }\n\n  _percentileToIndex(percentileRange) {\n    const len = this.sortedBins.length;\n\n    if (len < 2) {\n      return [0, 0];\n    }\n\n    const [lower, upper] = percentileRange.map(n => clamp(n, 0, 100));\n    const lowerIdx = Math.ceil(lower / 100 * (len - 1));\n    const upperIdx = Math.floor(upper / 100 * (len - 1));\n    return [lowerIdx, upperIdx];\n  }\n\n  getBinMap() {\n    const binMap = {};\n\n    for (const bin of this.aggregatedBins) {\n      binMap[bin.i] = bin;\n    }\n\n    return binMap;\n  }\n\n  _updateMinMaxValues() {\n    let maxCount = 0;\n    let maxValue = 0;\n    let minValue = MAX_32_BIT_FLOAT;\n    let totalCount = 0;\n\n    for (const x of this.aggregatedBins) {\n      maxCount = maxCount > x.counts ? maxCount : x.counts;\n      maxValue = maxValue > x.value ? maxValue : x.value;\n      minValue = minValue < x.value ? minValue : x.value;\n      totalCount += x.counts;\n    }\n\n    this.maxCount = maxCount;\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n    this.totalCount = totalCount;\n  }\n\n  getValueRange(percentileRange) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n\n    if (!this.sortedBins.length) {\n      return [];\n    }\n\n    let lowerIdx = 0;\n    let upperIdx = this.sortedBins.length - 1;\n\n    if (Array.isArray(percentileRange)) {\n      const idxRange = this._percentileToIndex(percentileRange);\n\n      lowerIdx = idxRange[0];\n      upperIdx = idxRange[1];\n    }\n\n    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n  }\n\n  getValueDomainByScale(scale, [lower = 0, upper = 100] = []) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n\n    if (!this.sortedBins.length) {\n      return [];\n    }\n\n    const indexEdge = this._percentileToIndex([lower, upper]);\n\n    return this._getScaleDomain(scale, indexEdge);\n  }\n\n  _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {\n    const bins = this.sortedBins;\n\n    switch (scaleType) {\n      case 'quantize':\n      case 'linear':\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n\n      case 'quantile':\n        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), d => d.value);\n\n      case 'ordinal':\n        return getOrdinalDomain(bins, d => d.value);\n\n      default:\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n    }\n  }\n\n}\n//# sourceMappingURL=bin-sorter.js.map","export const defaultColorRange = [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [240, 59, 32], [189, 0, 38]];\nexport function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {\n  let flatArray;\n\n  if (Number.isFinite(colorRange[0])) {\n    flatArray = new ArrayType(colorRange);\n  } else {\n    flatArray = new ArrayType(colorRange.length * 4);\n    let index = 0;\n\n    for (let i = 0; i < colorRange.length; i++) {\n      const color = colorRange[i];\n      flatArray[index++] = color[0];\n      flatArray[index++] = color[1];\n      flatArray[index++] = color[2];\n      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n    }\n  }\n\n  if (normalize) {\n    for (let i = 0; i < flatArray.length; i++) {\n      flatArray[i] /= 255;\n    }\n  }\n\n  return flatArray;\n}\n//# sourceMappingURL=color-utils.js.map","import { log } from '@deck.gl/core';\nexport function getScale(domain, range, scaleFunction) {\n  const scale = scaleFunction;\n\n  scale.domain = () => domain;\n\n  scale.range = () => range;\n\n  return scale;\n}\nexport function getQuantizeScale(domain, range) {\n  const scaleFunction = value => quantizeScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function getLinearScale(domain, range) {\n  const scaleFunction = value => linearScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function getQuantileScale(domain, range) {\n  const sortedDomain = domain.sort(ascending);\n  let i = 0;\n  const n = Math.max(1, range.length);\n  const thresholds = new Array(n - 1);\n\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n\n  const scaleFunction = value => thresholdsScale(thresholds, range, value);\n\n  scaleFunction.thresholds = () => thresholds;\n\n  return getScale(domain, range, scaleFunction);\n}\n\nfunction ascending(a, b) {\n  return a - b;\n}\n\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n\n  while (lo < hi) {\n    const mid = lo + hi >>> 1;\n\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  return lo;\n}\n\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\n\nfunction ordinalScale(domain, domainMap, range, value) {\n  const key = \"\".concat(value);\n  let d = domainMap.get(key);\n\n  if (d === undefined) {\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n\n  return range[(d - 1) % range.length];\n}\n\nexport function getOrdinalScale(domain, range) {\n  const domainMap = new Map();\n  const uniqueDomain = [];\n\n  for (const d of domain) {\n    const key = \"\".concat(d);\n\n    if (!domainMap.has(key)) {\n      domainMap.set(key, uniqueDomain.push(d));\n    }\n  }\n\n  const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function quantizeScale(domain, range, value) {\n  const domainRange = domain[1] - domain[0];\n\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n\n  const step = domainRange / range.length;\n  const idx = Math.floor((value - domain[0]) / step);\n  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n  return range[clampIdx];\n}\nexport function linearScale(domain, range, value) {\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}\n\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\n\nexport function unique(values) {\n  const results = [];\n  values.forEach(v => {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\n\nfunction getTruthyValues(data, valueAccessor) {\n  const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\n\nexport function getLinearDomain(data, valueAccessor) {\n  const sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n\n    case 'linear':\n      return getLinearScale;\n\n    case 'quantile':\n      return getQuantileScale;\n\n    case 'ordinal':\n      return getOrdinalScale;\n\n    default:\n      return getQuantizeScale;\n  }\n}\n//# sourceMappingURL=scale-utils.js.map","import Layer from './layer';\nimport debug from '../debug';\nimport { flatten } from '../utils/flatten';\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\nexport default class CompositeLayer extends Layer {\n  get isComposite() {\n    return true;\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n\n  getSubLayers() {\n    return this.internalState && this.internalState.subLayers || [];\n  }\n\n  initializeState() {}\n\n  setState(updateObject) {\n    super.setState(updateObject);\n    this.setNeedsUpdate();\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    const {\n      object\n    } = info;\n    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n\n    if (!isDataWrapped) {\n      return info;\n    }\n\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n    return info;\n  }\n\n  renderLayers() {\n    return null;\n  }\n\n  filterSubLayer(context) {\n    return true;\n  }\n\n  shouldRenderSubLayer(id, data) {\n    const {\n      _subLayerProps: overridingProps\n    } = this.props;\n    return data && data.length || overridingProps && overridingProps[id];\n  }\n\n  getSubLayerClass(id, DefaultLayerClass) {\n    const {\n      _subLayerProps: overridingProps\n    } = this.props;\n    return overridingProps && overridingProps[id] && overridingProps[id].type || DefaultLayerClass;\n  }\n\n  getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n\n  getSubLayerAccessor(accessor) {\n    if (typeof accessor === 'function') {\n      const objectInfo = {\n        data: this.props.data,\n        target: []\n      };\n      return (x, i) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          return accessor(x.__source.object, objectInfo);\n        }\n\n        return accessor(x, i);\n      };\n    }\n\n    return accessor;\n  }\n\n  getSubLayerProps(sublayerProps = {}) {\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch\n    };\n    const overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || 'sublayer';\n\n    if (overridingSublayerProps) {\n      const propTypes = this.constructor._propTypes;\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n\n        if (propType && propType.type === 'accessor') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n\n    Object.assign(newProps, sublayerProps, overridingSublayerProps);\n    newProps.id = \"\".concat(this.props.id, \"-\").concat(sublayerId);\n    newProps.updateTriggers = {\n      all: this.props.updateTriggers.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n\n    return newProps;\n  }\n\n  _updateAutoHighlight(info) {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  _getAttributeManager() {\n    return null;\n  }\n\n  _renderLayers() {\n    let {\n      subLayers\n    } = this.internalState;\n    const shouldUpdate = !subLayers || this.needsUpdate();\n\n    if (shouldUpdate) {\n      subLayers = this.renderLayers();\n      subLayers = flatten(subLayers, Boolean);\n      this.internalState.subLayers = subLayers;\n    }\n\n    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n\n}\nCompositeLayer.layerName = 'CompositeLayer';\n//# sourceMappingURL=composite-layer.js.map"],"names":["filterProps","props","filterKeys","filteredProps","key","includes","AggregationLayer","initializeState","dimensions","super","this","setState","ignoreProps","constructor","_propTypes","data","updateState","opts","changeFlags","extensionsChanged","shaders","getShaders","defines","NON_INSTANCED_MODEL","updateShaders","_updateAttributes","updateAttributes","changedAttributes","getAttributes","getAttributeManager","getShaderAttributes","getModuleSettings","viewport","mousePosition","gl","context","Object","assign","create","pickingActive","devicePixelRatio","isAggregationDirty","updateOpts","params","oldProps","compareAll","dimension","state","dataProps","accessors","updateTriggersChanged","dataChanged","all","accessor","newProps","propTypes","name","isAttributeChanged","undefined","obj","isEmpty","isObjectEmpty","_getAttributeManager","id","stats","layerName","AGGREGATION_OPERATION","SUM","MEAN","MIN","MAX","sumReducer","accu","cur","maxReducer","minReducer","getValueFunc","aggregation","op","Number","isFinite","pt","index","source","wrapAccessor","pts","length","filtered","map","filter","reduce","Infinity","getMin","getSum","getMean","getMax","wrapGetValueFunc","getValue","indices","defaultGetValue","points","defaultGetPoints","bin","defaultGetIndex","ascending","a","b","NaN","defaultProps","getPoints","getIndex","filterData","BinSorter","bins","aggregatedBins","getAggregatedBins","_updateMinMaxValues","binMap","getBinMap","hasFilter","binCount","binIndex","i","filteredPoints","value","counts","_percentileToIndex","percentileRange","len","sortedBins","lower","upper","n","Math","ceil","floor","maxCount","maxValue","minValue","totalCount","x","getValueRange","sort","lowerIdx","upperIdx","Array","isArray","idxRange","getValueDomainByScale","scale","indexEdge","_getScaleDomain","scaleType","slice","d","defaultColorRange","colorRangeToFlatArray","colorRange","normalize","ArrayType","Float32Array","flatArray","color","getScale","domain","range","scaleFunction","getQuantizeScale","domainRange","step","idx","max","min","quantizeScale","getLinearScale","linearScale","getQuantileScale","sortedDomain","thresholds","threshold","lo","hi","mid","bisectRight","thresholdsScale","fraction","domainLength","domainFraction","lowIndex","low","getOrdinalScale","domainMap","Map","uniqueDomain","concat","has","set","push","get","ordinalScale","notNullOrUndefined","getTruthyValues","valueAccessor","getQuantileDomain","getOrdinalDomain","values","results","forEach","v","unique","clamp","getScaleFunctionByScaleType","CompositeLayer","isComposite","isLoaded","getSubLayers","every","layer","internalState","subLayers","updateObject","setNeedsUpdate","getPickingInfo","info","object","__source","parent","renderLayers","filterSubLayer","shouldRenderSubLayer","_subLayerProps","overridingProps","getSubLayerClass","DefaultLayerClass","type","getSubLayerRow","row","sourceObject","sourceObjectIndex","getSubLayerAccessor","objectInfo","target","getSubLayerProps","sublayerProps","opacity","pickable","visible","parameters","getPolygonOffset","highlightedObjectIndex","autoHighlight","highlightColor","coordinateSystem","coordinateOrigin","wrapLongitude","positionFormat","modelMatrix","extensions","fetch","overridingSublayerProps","overridingSublayerTriggers","updateTriggers","sublayerId","subLayerPropTypes","propType","extension","passThroughProps","call","_updateAutoHighlight","updateAutoHighlight","_renderLayers","shouldUpdate","needsUpdate","Boolean"],"sourceRoot":""}