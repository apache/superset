{"version":3,"file":"5755.9a30c8fe6a57798ab86b.entry.js","mappings":"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","sources":["webpack://superset/./node_modules/serialize-query-params/esm/serialize.js","webpack://superset/./node_modules/serialize-query-params/esm/params.js","webpack://superset/./node_modules/serialize-query-params/esm/updateLocation.js","webpack://superset/./node_modules/serialize-query-params/esm/encodeQueryParams.js","webpack://superset/./node_modules/serialize-query-params/esm/index.js","webpack://superset/./node_modules/use-query-params/esm/shallowEqual.js","webpack://superset/./node_modules/use-query-params/esm/helpers.js","webpack://superset/./node_modules/use-query-params/esm/LocationProvider.js","webpack://superset/./node_modules/use-query-params/esm/updateUrlQuery.js","webpack://superset/./node_modules/use-query-params/esm/memoizedQueryParser.js","webpack://superset/./node_modules/use-query-params/esm/useQueryParam.js","webpack://superset/./node_modules/use-query-params/esm/useQueryParams.js","webpack://superset/./node_modules/use-query-params/esm/QueryParamProvider.js"],"sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * Interprets an encoded string and returns either the string or null/undefined if not available.\n * Ignores array inputs (takes just first element in array)\n * @param input encoded string\n */\nfunction getEncodedValue(input, allowEmptyString) {\n    if (input == null) {\n        return input;\n    }\n    // '' or []\n    if (input.length === 0 &&\n        (!allowEmptyString || (allowEmptyString && input !== ''))) {\n        return null;\n    }\n    var str = input instanceof Array ? input[0] : input;\n    if (str == null) {\n        return str;\n    }\n    if (!allowEmptyString && str === '') {\n        return null;\n    }\n    return str;\n}\n/**\n * Interprets an encoded string and return null/undefined or an array with\n * the encoded string contents\n * @param input encoded string\n */\nfunction getEncodedValueArray(input) {\n    if (input == null) {\n        return input;\n    }\n    return input instanceof Array ? input : input === '' ? [] : [input];\n}\n/**\n * Encodes a date as a string in YYYY-MM-DD format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDate(date) {\n    if (date == null) {\n        return date;\n    }\n    var year = date.getFullYear();\n    var month = date.getMonth() + 1;\n    var day = date.getDate();\n    return year + \"-\" + (month < 10 ? \"0\" + month : month) + \"-\" + (day < 10 ? \"0\" + day : day);\n}\n/**\n * Converts a date in the format 'YYYY-mm-dd...' into a proper date, because\n * new Date() does not do that correctly. The date can be as complete or incomplete\n * as necessary (aka, '2015', '2015-10', '2015-10-01').\n * It will not work for dates that have times included in them.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '2015-10-01'\n * @return {Date} parsed date\n */\nexport function decodeDate(input) {\n    var dateString = getEncodedValue(input);\n    if (dateString == null)\n        return dateString;\n    var parts = dateString.split('-');\n    // may only be a year so won't even have a month\n    if (parts[1] != null) {\n        parts[1] -= 1; // Note: months are 0-based\n    }\n    else {\n        // just a year, set the month and day to the first\n        parts[1] = 0;\n        parts[2] = 1;\n    }\n    var decoded = new (Date.bind.apply(Date, __spreadArrays([void 0], parts)))();\n    if (isNaN(decoded.getTime())) {\n        return null;\n    }\n    return decoded;\n}\n/**\n * Encodes a date as a string in ISO 8601 (\"2019-05-28T10:58:40Z\") format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDateTime(date) {\n    if (date == null) {\n        return date;\n    }\n    return date.toISOString();\n}\n/**\n * Converts a date in the https://en.wikipedia.org/wiki/ISO_8601 format.\n * For allowed inputs see specs:\n *  - https://tools.ietf.org/html/rfc2822#page-14\n *  - http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '1995-12-17T03:24:00'\n * @return {Date} parsed date\n */\nexport function decodeDateTime(input) {\n    var dateString = getEncodedValue(input);\n    if (dateString == null)\n        return dateString;\n    var decoded = new Date(dateString);\n    if (isNaN(decoded.getTime())) {\n        return null;\n    }\n    return decoded;\n}\n/**\n * Encodes a boolean as a string. true -> \"1\", false -> \"0\".\n *\n * @param {Boolean} bool\n * @return {String} the encoded boolean\n */\nexport function encodeBoolean(bool) {\n    if (bool == null) {\n        return bool;\n    }\n    return bool ? '1' : '0';\n}\n/**\n * Decodes a boolean from a string. \"1\" -> true, \"0\" -> false.\n * Everything else maps to undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded boolean string\n * @return {Boolean} the boolean value\n */\nexport function decodeBoolean(input) {\n    var boolStr = getEncodedValue(input);\n    if (boolStr == null)\n        return boolStr;\n    if (boolStr === '1') {\n        return true;\n    }\n    else if (boolStr === '0') {\n        return false;\n    }\n    return null;\n}\n/**\n * Encodes a number as a string.\n *\n * @param {Number} num\n * @return {String} the encoded number\n */\nexport function encodeNumber(num) {\n    if (num == null) {\n        return num;\n    }\n    return String(num);\n}\n/**\n * Decodes a number from a string. If the number is invalid,\n * it returns undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded number string\n * @return {Number} the number value\n */\nexport function decodeNumber(input) {\n    var numStr = getEncodedValue(input);\n    if (numStr == null)\n        return numStr;\n    if (numStr === '')\n        return null;\n    var result = +numStr;\n    return result;\n}\n/**\n * Encodes a string while safely handling null and undefined values.\n *\n * @param {String} str a string to encode\n * @return {String} the encoded string\n */\nexport function encodeString(str) {\n    if (str == null) {\n        return str;\n    }\n    return String(str);\n}\n/**\n * Decodes a string while safely handling null and undefined values.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded string\n * @return {String} the string value\n */\nexport function decodeString(input) {\n    var str = getEncodedValue(input, true);\n    if (str == null)\n        return str;\n    return String(str);\n}\n/**\n * Encodes anything as a JSON string.\n *\n * @param {Any} any The thing to be encoded\n * @return {String} The JSON string representation of any\n */\nexport function encodeJson(any) {\n    if (any == null) {\n        return any;\n    }\n    return JSON.stringify(any);\n}\n/**\n * Decodes a JSON string into javascript\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @return {Any} The javascript representation\n */\nexport function decodeJson(input) {\n    var jsonStr = getEncodedValue(input);\n    if (jsonStr == null)\n        return jsonStr;\n    var result = null;\n    try {\n        result = JSON.parse(jsonStr);\n    }\n    catch (e) {\n        /* ignore errors, returning undefined */\n    }\n    return result;\n}\n/**\n * Encodes an array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeArray(array) {\n    if (array == null) {\n        return array;\n    }\n    return array;\n}\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeArray(input) {\n    var arr = getEncodedValueArray(input);\n    if (arr == null)\n        return arr;\n    return arr;\n}\n/**\n * Encodes a numeric array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeNumericArray(array) {\n    if (array == null) {\n        return array;\n    }\n    return array.map(String);\n}\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined and NaN values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeNumericArray(input) {\n    var arr = decodeArray(input);\n    if (arr == null)\n        return arr;\n    return arr.map(function (d) { return (d === '' || d == null ? null : +d); });\n}\n/**\n * Encodes an array as a delimited string. For example,\n * ['a', 'b'] -> 'a_b' with entrySeparator='_'\n *\n * @param array The array to be encoded\n * @param entrySeparator The string used to delimit entries\n * @return The array as a string with elements joined by the\n * entry separator\n */\nexport function encodeDelimitedArray(array, entrySeparator) {\n    if (entrySeparator === void 0) { entrySeparator = '_'; }\n    if (array == null) {\n        return array;\n    }\n    return array.join(entrySeparator);\n}\n/**\n * Decodes a delimited string into javascript array. For example,\n * 'a_b' -> ['a', 'b'] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @param entrySeparator The array as a string with elements joined by the\n * entry separator\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedArray(input, entrySeparator) {\n    if (entrySeparator === void 0) { entrySeparator = '_'; }\n    var arrayStr = getEncodedValue(input, true);\n    if (arrayStr == null)\n        return arrayStr;\n    if (arrayStr === '')\n        return [];\n    return arrayStr.split(entrySeparator);\n}\n/**\n * Encodes a numeric array as a delimited string. (alias of encodeDelimitedArray)\n * For example, [1, 2] -> '1_2' with entrySeparator='_'\n *\n * @param {Array} array The array to be encoded\n * @return {String} The JSON string representation of array\n */\nexport var encodeDelimitedNumericArray = encodeDelimitedArray;\n/**\n * Decodes a delimited string into javascript array where all entries are numbers\n * For example, '1_2' -> [1, 2] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} jsonStr The JSON string representation\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedNumericArray(arrayStr, entrySeparator) {\n    if (entrySeparator === void 0) { entrySeparator = '_'; }\n    var decoded = decodeDelimitedArray(arrayStr, entrySeparator);\n    if (decoded == null)\n        return decoded;\n    return decoded.map(function (d) { return (d === '' || d == null ? null : +d); });\n}\n/**\n * Encode simple objects as readable strings. Works only for simple,\n * flat objects where values are numbers, strings.\n *\n * For example { foo: bar, boo: baz } -> \"foo-bar_boo-baz\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport function encodeObject(obj, keyValSeparator, entrySeparator) {\n    if (keyValSeparator === void 0) { keyValSeparator = '-'; }\n    if (entrySeparator === void 0) { entrySeparator = '_'; }\n    if (obj == null)\n        return obj; // null or undefined\n    if (!Object.keys(obj).length)\n        return ''; // {} case\n    return Object.keys(obj)\n        .map(function (key) { return \"\" + key + keyValSeparator + obj[key]; })\n        .join(entrySeparator);\n}\n/**\n * Decodes a simple object to javascript. Currently works only for simple,\n * flat objects where values are strings.\n *\n * For example \"foo-bar_boo-baz\" -> { foo: bar, boo: baz }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeObject(input, keyValSeparator, entrySeparator) {\n    if (keyValSeparator === void 0) { keyValSeparator = '-'; }\n    if (entrySeparator === void 0) { entrySeparator = '_'; }\n    var objStr = getEncodedValue(input, true);\n    if (objStr == null)\n        return objStr;\n    if (objStr === '')\n        return {};\n    var obj = {};\n    var keyValSeparatorRegExp = new RegExp(keyValSeparator + \"(.*)\");\n    objStr.split(entrySeparator).forEach(function (entryStr) {\n        var _a = entryStr.split(keyValSeparatorRegExp), key = _a[0], value = _a[1];\n        obj[key] = value;\n    });\n    return obj;\n}\n/**\n * Encode simple objects as readable strings. Alias of encodeObject.\n *\n * For example { foo: 123, boo: 521 } -> \"foo-123_boo-521\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport var encodeNumericObject = encodeObject;\n/**\n * Decodes a simple object to javascript where all values are numbers.\n * Currently works only for simple, flat objects.\n *\n * For example \"foo-123_boo-521\" -> { foo: 123, boo: 521 }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeNumericObject(input, keyValSeparator, entrySeparator) {\n    if (keyValSeparator === void 0) { keyValSeparator = '-'; }\n    if (entrySeparator === void 0) { entrySeparator = '_'; }\n    var decoded = decodeObject(input, keyValSeparator, entrySeparator);\n    if (decoded == null)\n        return decoded;\n    // convert to numbers\n    var decodedNumberObj = {};\n    for (var _i = 0, _a = Object.keys(decoded); _i < _a.length; _i++) {\n        var key = _a[_i];\n        decodedNumberObj[key] = decodeNumber(decoded[key]);\n    }\n    return decodedNumberObj;\n}\n","import * as Serialize from './serialize';\n/**\n * String values\n */\nexport var StringParam = {\n    encode: Serialize.encodeString,\n    decode: Serialize.decodeString,\n};\n/**\n * Numbers (integers or floats)\n */\nexport var NumberParam = {\n    encode: Serialize.encodeNumber,\n    decode: Serialize.decodeNumber,\n};\n/**\n * For flat objects where values are strings\n */\nexport var ObjectParam = {\n    encode: Serialize.encodeObject,\n    decode: Serialize.decodeObject,\n};\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport var ArrayParam = {\n    encode: Serialize.encodeArray,\n    decode: Serialize.decodeArray,\n};\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport var NumericArrayParam = {\n    encode: Serialize.encodeNumericArray,\n    decode: Serialize.decodeNumericArray,\n};\n/**\n * For any type of data, encoded via JSON.stringify\n */\nexport var JsonParam = {\n    encode: Serialize.encodeJson,\n    decode: Serialize.decodeJson,\n};\n/**\n * For simple dates (YYYY-MM-DD)\n */\nexport var DateParam = {\n    encode: Serialize.encodeDate,\n    decode: Serialize.decodeDate,\n    equals: function (valueA, valueB) {\n        if (valueA === valueB)\n            return true;\n        if (valueA == null || valueB == null)\n            return valueA === valueB;\n        // ignore time of day\n        return (valueA.getFullYear() === valueB.getFullYear() &&\n            valueA.getMonth() === valueB.getMonth() &&\n            valueA.getDate() === valueB.getDate());\n    },\n};\n/**\n * For dates in simplified extended ISO format (YYYY-MM-DDTHH:mm:ss.sssZ or Â±YYYYYY-MM-DDTHH:mm:ss.sssZ)\n */\nexport var DateTimeParam = {\n    encode: Serialize.encodeDateTime,\n    decode: Serialize.decodeDateTime,\n    equals: function (valueA, valueB) {\n        if (valueA === valueB)\n            return true;\n        if (valueA == null || valueB == null)\n            return valueA === valueB;\n        return valueA.valueOf() === valueB.valueOf();\n    },\n};\n/**\n * For boolean values: 1 = true, 0 = false\n */\nexport var BooleanParam = {\n    encode: Serialize.encodeBoolean,\n    decode: Serialize.decodeBoolean,\n};\n/**\n * For flat objects where the values are numbers\n */\nexport var NumericObjectParam = {\n    encode: Serialize.encodeNumericObject,\n    decode: Serialize.decodeNumericObject,\n};\n/**\n * For flat arrays of strings, filters out undefined values during decode\n */\nexport var DelimitedArrayParam = {\n    encode: Serialize.encodeDelimitedArray,\n    decode: Serialize.decodeDelimitedArray,\n};\n/**\n * For flat arrays where the values are numbers, filters out undefined values during decode\n */\nexport var DelimitedNumericArrayParam = {\n    encode: Serialize.encodeDelimitedNumericArray,\n    decode: Serialize.decodeDelimitedNumericArray,\n};\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { stringify, parse as parseQueryString, parseUrl, } from 'query-string';\n/**\n * An example of a transformSearchString function that undoes encoding of\n * common JSON characters that are technically allowed in URLs.\n */\nvar JSON_SAFE_CHARS = \"{}[],\\\":\"\n    .split('')\n    .map(function (d) { return [d, encodeURIComponent(d)]; });\nexport function transformSearchStringJsonSafe(searchString) {\n    var str = searchString;\n    for (var _i = 0, JSON_SAFE_CHARS_1 = JSON_SAFE_CHARS; _i < JSON_SAFE_CHARS_1.length; _i++) {\n        var _a = JSON_SAFE_CHARS_1[_i], char = _a[0], code = _a[1];\n        str = str.replace(new RegExp('\\\\' + code, 'g'), char);\n    }\n    return str;\n}\n/**\n * Update a location, wiping out parameters not included in encodedQuery\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateLocation(encodedQuery, location, stringifyOptions) {\n    var encodedSearchString = stringify(encodedQuery, stringifyOptions);\n    if (stringifyOptions && stringifyOptions.transformSearchString) {\n        encodedSearchString = stringifyOptions.transformSearchString(encodedSearchString);\n    }\n    var search = encodedSearchString.length ? \"?\" + encodedSearchString : '';\n    var href = parseUrl(location.href || '').url + search;\n    var newLocation = __assign(__assign({}, location), { key: \"\" + Date.now(), // needed for some routers (e.g. react-router)\n        href: href,\n        search: search, query: encodedQuery });\n    return newLocation;\n}\n/**\n * Update a location while retaining existing parameters.\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateInLocation(encodedQueryReplacements, location, stringifyOptions) {\n    // if a query is there, use it, otherwise parse the search string\n    var currQuery = location.query || parseQueryString(location.search);\n    var newQuery = __assign(__assign({}, currQuery), encodedQueryReplacements);\n    return updateLocation(newQuery, location, stringifyOptions);\n}\n","/**\n * Convert the values in query to strings via the encode functions configured\n * in paramConfigMap\n *\n * @param paramConfigMap Map from query name to { encode, decode } config\n * @param query Query updates mapping param name to decoded value\n */\nexport function encodeQueryParams(paramConfigMap, query) {\n    var encodedQuery = {};\n    var paramNames = Object.keys(query);\n    for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n        var paramName = paramNames_1[_i];\n        var decodedValue = query[paramName];\n        if (!paramConfigMap[paramName]) {\n            if (process.env.NODE_ENV === 'development') {\n                console.warn(\"Encoding parameter \" + paramName + \" as string since it was not configured.\");\n            }\n            // NOTE: we could just not encode it, but it is probably convenient to have\n            // it be included by default as a string type.\n            encodedQuery[paramName] =\n                decodedValue == null ? decodedValue : String(decodedValue);\n        }\n        else {\n            encodedQuery[paramName] = paramConfigMap[paramName].encode(query[paramName]);\n        }\n    }\n    return encodedQuery;\n}\nexport default encodeQueryParams;\n","export { withDefault } from './withDefault';\nexport { encodeDate, decodeDate, encodeBoolean, decodeBoolean, encodeNumber, decodeNumber, encodeString, decodeString, encodeJson, decodeJson, encodeArray, decodeArray, encodeNumericArray, decodeNumericArray, encodeDelimitedArray, decodeDelimitedArray, encodeDelimitedNumericArray, decodeDelimitedNumericArray, encodeObject, decodeObject, encodeNumericObject, decodeNumericObject, } from './serialize';\nexport { StringParam, NumberParam, ObjectParam, ArrayParam, NumericArrayParam, JsonParam, DateParam, DateTimeParam, BooleanParam, NumericObjectParam, DelimitedArrayParam, DelimitedNumericArrayParam, } from './params';\nexport { updateLocation, updateInLocation, transformSearchStringJsonSafe, } from './updateLocation';\nexport { encodeQueryParams } from './encodeQueryParams';\nexport { decodeQueryParams } from './decodeQueryParams';\nif (process.env.NODE_ENV !== 'production' && typeof require === 'function') {\n    /*\n     * run checks to ensure a valid version of query-string is installed\n     * see https://github.com/pbeshai/use-query-params/issues/127 for discussion\n     */\n    var queryStringVersion = require('query-string/package.json').version;\n    // simple check of versions since we don't anticipate any new minor v5s and\n    // don't want to require the semver package as a dependency for just a simple\n    // dev check.\n    var validQueryStringInstalled = /^5.1.[1-9][0-9]*/.test(queryStringVersion) ||\n        /^6\\./.test(queryStringVersion);\n    if (!validQueryStringInstalled) {\n        throw new Error(\"serialize-query-params requires query-string ^5.1.1 || ^6, \" +\n            (\"but \" + queryStringVersion + \" is installed. Note: you may also \") +\n            \"see this message if you're using use-query-params.\");\n    }\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license at\n * https://github.com/facebook/fbjs/blob/master/LICENSE\n */\n/*eslint-disable no-self-compare */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n        // Steps 1-5, 7-10\n        // Steps 6.b-6.e: +0 != -0\n        // Added the nonzero y check to make Flow happy, but it is redundant\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        // Step 6.a: NaN == NaN\n        return x !== x && y !== y;\n    }\n}\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n\n * @pbeshai modification of shallowEqual to take into consideration a map providing\n * equals functions\n */\nexport default function shallowEqual(objA, objB, equalMap) {\n    var _a, _b;\n    if (is(objA, objB)) {\n        return true;\n    }\n    if (typeof objA !== 'object' ||\n        objA === null ||\n        typeof objB !== 'object' ||\n        objB === null) {\n        return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    // Test for A's keys different from B.\n    for (var i = 0; i < keysA.length; i++) {\n        var isEqual = (_b = (_a = equalMap === null || equalMap === void 0 ? void 0 : equalMap[keysA[i]]) === null || _a === void 0 ? void 0 : _a.equals) !== null && _b !== void 0 ? _b : is;\n        if (!hasOwnProperty.call(objB, keysA[i]) ||\n            !isEqual(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n","import * as React from 'react';\nimport { extract } from 'query-string';\nimport shallowEqual from './shallowEqual';\nexport function useUpdateRefIfShallowNew(ref, newValue, isEqual) {\n    if (isEqual === void 0) { isEqual = shallowEqual; }\n    var hasNew = ((ref.current == null || newValue == null) && ref.current === newValue) ||\n        !isEqual(ref.current, newValue);\n    React.useEffect(function () {\n        if (hasNew) {\n            ref.current = newValue;\n        }\n    }, [ref, newValue, hasNew]);\n}\nexport function getSSRSafeSearchString(location) {\n    // handle checking SSR (#13)\n    if (typeof location === 'object') {\n        // in browser\n        if (typeof window !== 'undefined') {\n            return location.search;\n        }\n        else {\n            return extract(\"\" + location.pathname + (location.search ? location.search : ''));\n        }\n    }\n    return '';\n}\n","import * as React from 'react';\nimport { updateUrlQuery, createLocationWithChanges } from './updateUrlQuery';\nvar providerlessContextValue = {\n    location: {},\n    getLocation: function () { return ({}); },\n    setLocation: function () { },\n};\nexport var LocationContext = React.createContext(providerlessContextValue);\nexport function useLocationContext() {\n    var context = React.useContext(LocationContext);\n    if (process.env.NODE_ENV !== 'production' &&\n        (context === undefined || context === providerlessContextValue)) {\n        throw new Error('useQueryParams must be used within a QueryParamProvider');\n    }\n    return context;\n}\n/**\n * An internal-only context provider which provides down the most\n * recent location object and a callback to update the history.\n */\nexport function LocationProvider(_a) {\n    var history = _a.history, location = _a.location, children = _a.children, stringifyOptions = _a.stringifyOptions;\n    var locationRef = React.useRef(location);\n    React.useEffect(function () {\n        locationRef.current = location;\n    }, [location]);\n    // TODO: we can probably simplify this now that we are reading location from history\n    var getLocation = React.useCallback(function () { return locationRef.current; }, [\n        locationRef,\n    ]);\n    var setLocation = React.useCallback(function (queryReplacements, updateType) {\n        // A ref is needed here to stop setLocation updating constantly (see #46)\n        locationRef.current = createLocationWithChanges(queryReplacements, history == null || history.location == null\n            ? locationRef.current\n            : history.location, updateType, stringifyOptions);\n        if (history) {\n            updateUrlQuery(history, locationRef.current, updateType);\n        }\n    }, [history, stringifyOptions]);\n    return (React.createElement(LocationContext.Provider, { value: { location: location, getLocation: getLocation, setLocation: setLocation } }, children));\n}\n","import { updateLocation, updateInLocation, } from 'serialize-query-params';\n/**\n * Creates a new location object containing the specified query changes.\n * If replaceIn or pushIn are used as the updateType, then parameters\n * not specified in queryReplacements are retained. If replace or push\n * are used, only the values in queryReplacements will be available.\n * The default is pushIn.\n */\nexport function createLocationWithChanges(queryReplacements, location, updateType, stringifyOptions) {\n    if (updateType === void 0) { updateType = 'pushIn'; }\n    switch (updateType) {\n        case 'replace':\n        case 'push':\n            return updateLocation(queryReplacements, location, stringifyOptions);\n        case 'replaceIn':\n        case 'pushIn':\n        default:\n            return updateInLocation(queryReplacements, location, stringifyOptions);\n    }\n}\n/**\n * Updates the URL to the new location.\n */\nexport function updateUrlQuery(history, location, updateType) {\n    if (updateType === void 0) { updateType = 'pushIn'; }\n    switch (updateType) {\n        case 'pushIn':\n        case 'push':\n            history.push(location);\n            break;\n        case 'replaceIn':\n        case 'replace':\n        default:\n            history.replace(location);\n            break;\n    }\n}\n","import { parse as parseQueryString } from 'query-string';\nexport var makeMemoizedQueryParser = function (initialSearchString) {\n    var cachedSearchString = initialSearchString;\n    var cachedParsedQuery = parseQueryString(cachedSearchString || '');\n    return function (newSearchString) {\n        if (cachedSearchString !== newSearchString) {\n            cachedSearchString = newSearchString;\n            cachedParsedQuery = parseQueryString(cachedSearchString);\n        }\n        return cachedParsedQuery;\n    };\n};\nexport var sharedMemoizedQueryParser = makeMemoizedQueryParser();\n","import * as React from 'react';\nimport { StringParam } from 'serialize-query-params';\nimport { getSSRSafeSearchString, useUpdateRefIfShallowNew } from './helpers';\nimport { useLocationContext } from './LocationProvider';\nimport { sharedMemoizedQueryParser } from './memoizedQueryParser';\nimport shallowEqual from './shallowEqual';\n/**\n * Helper to get the latest decoded value with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nfunction getLatestDecodedValue(location, name, paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef) {\n    var _a;\n    // check if we have a new param config\n    var hasNewParamConfig = !shallowEqual(paramConfigRef.current, paramConfig);\n    var isValueEqual = (_a = paramConfig.equals) !== null && _a !== void 0 ? _a : shallowEqual;\n    // read in the parsed query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location) // get the latest location object\n    );\n    // read in the encoded string value (we have to check cache if available because\n    // sometimes the query string changes so we get a new parsedQuery but this value\n    // didn't change, so we should avoid generating a new array or whatever value)\n    var hasNewEncodedValue = !shallowEqual(encodedValueCacheRef.current, parsedQuery[name]);\n    var encodedValue = hasNewEncodedValue\n        ? parsedQuery[name]\n        : encodedValueCacheRef.current;\n    // only decode if we have changes to encoded value or the config.\n    // check for undefined to handle initial case\n    if (!hasNewEncodedValue &&\n        !hasNewParamConfig &&\n        decodedValueCacheRef.current !== undefined) {\n        return decodedValueCacheRef.current;\n    }\n    var newDecodedValue = paramConfig.decode(encodedValue);\n    var hasNewDecodedValue = ((decodedValueCacheRef.current == null || newDecodedValue == null) &&\n        decodedValueCacheRef.current === newDecodedValue) ||\n        !isValueEqual(decodedValueCacheRef.current, newDecodedValue);\n    // if we have a new decoded value use it, otherwise use cached\n    return hasNewDecodedValue\n        ? newDecodedValue\n        : decodedValueCacheRef.current;\n}\n/**\n * Given a query param name and query parameter configuration ({ encode, decode })\n * return the decoded value and a setter for updating it.\n *\n * The setter takes two arguments (newValue, updateType) where updateType\n * is one of 'replace' | 'replaceIn' | 'push' | 'pushIn', defaulting to\n * 'pushIn'.\n *\n * You may optionally pass in a rawQuery object, otherwise the query is derived\n * from the location available in the context.\n *\n * D = decoded type\n * D2 = return value from decode (typically same as D)\n */\nexport var useQueryParam = function (name, paramConfig) {\n    if (paramConfig === void 0) { paramConfig = StringParam; }\n    var _a = useLocationContext(), location = _a.location, getLocation = _a.getLocation, setLocation = _a.setLocation;\n    // read in the raw query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location));\n    // make caches\n    var encodedValueCacheRef = React.useRef();\n    var paramConfigRef = React.useRef(paramConfig);\n    var decodedValueCacheRef = React.useRef();\n    var decodedValue = getLatestDecodedValue(location, name, paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef);\n    // update cached values in a useEffect\n    useUpdateRefIfShallowNew(encodedValueCacheRef, parsedQuery[name]);\n    useUpdateRefIfShallowNew(paramConfigRef, paramConfig);\n    useUpdateRefIfShallowNew(decodedValueCacheRef, decodedValue, paramConfig.equals);\n    // create the setter, memoizing via useCallback\n    var setValueDeps = {\n        paramConfig: paramConfig,\n        name: name,\n        setLocation: setLocation,\n        getLocation: getLocation,\n    };\n    var setValueDepsRef = React.useRef(setValueDeps);\n    setValueDepsRef.current = setValueDeps;\n    var setValue = React.useCallback(function setValueCallback(newValue, updateType) {\n        var _a;\n        var deps = setValueDepsRef.current;\n        var newEncodedValue;\n        // allow functional updates #26\n        if (typeof newValue === 'function') {\n            // get latest decoded value to pass as a fresh arg to the setter fn\n            var latestValue = getLatestDecodedValue(deps.getLocation(), deps.name, deps.paramConfig, paramConfigRef, encodedValueCacheRef, decodedValueCacheRef);\n            decodedValueCacheRef.current = latestValue; // keep cache in sync\n            newEncodedValue = deps.paramConfig.encode(newValue(latestValue));\n        }\n        else {\n            newEncodedValue = deps.paramConfig.encode(newValue);\n        }\n        // update the URL\n        deps.setLocation((_a = {}, _a[deps.name] = newEncodedValue, _a), updateType);\n    }, []);\n    return [decodedValue, setValue];\n};\n","import * as React from 'react';\nimport { encodeQueryParams, } from 'serialize-query-params';\nimport { getSSRSafeSearchString, useUpdateRefIfShallowNew } from './helpers';\nimport { useLocationContext } from './LocationProvider';\nimport { sharedMemoizedQueryParser } from './memoizedQueryParser';\nimport shallowEqual from './shallowEqual';\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nfunction getLatestDecodedValues(location, paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef) {\n    // check if we have a new param config\n    var hasNewParamConfigMap = !shallowEqual(paramConfigMapRef.current, paramConfigMap);\n    // read in the parsed query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location) // get the latest location object\n    );\n    // check if new encoded values are around (new parsed query).\n    // can use triple equals since we already cache this value\n    var hasNewParsedQuery = parsedQueryRef.current !== parsedQuery;\n    // if nothing has changed, use existing.. so long as we have existing.\n    if (!hasNewParsedQuery &&\n        !hasNewParamConfigMap &&\n        encodedValuesCacheRef.current !== undefined) {\n        return {\n            encodedValues: encodedValuesCacheRef.current,\n            decodedValues: decodedValuesCacheRef.current,\n        };\n    }\n    var encodedValuesCache = encodedValuesCacheRef.current || {};\n    var decodedValuesCache = decodedValuesCacheRef.current || {};\n    var encodedValues = {};\n    // we have new encoded values, so let's get new decoded values.\n    // recompute new values but only for those that changed\n    var paramNames = Object.keys(paramConfigMap);\n    var decodedValues = {};\n    for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n        var paramName = paramNames_1[_i];\n        // do we have a new encoded value?\n        var paramConfig = paramConfigMap[paramName];\n        var hasNewEncodedValue = !shallowEqual(encodedValuesCache[paramName], parsedQuery[paramName]);\n        // if we have a new encoded value, re-decode. otherwise reuse cache\n        var encodedValue = void 0;\n        var decodedValue = void 0;\n        if (hasNewEncodedValue ||\n            (encodedValuesCache[paramName] === undefined &&\n                decodedValuesCache[paramName] === undefined)) {\n            encodedValue = parsedQuery[paramName];\n            decodedValue = paramConfig.decode(encodedValue);\n        }\n        else {\n            encodedValue = encodedValuesCache[paramName];\n            decodedValue = decodedValuesCache[paramName];\n        }\n        encodedValues[paramName] = encodedValue;\n        decodedValues[paramName] = decodedValue;\n    }\n    // keep referential equality for decoded valus if we didn't actually change anything\n    var hasNewDecodedValues = !shallowEqual(decodedValuesCacheRef.current, decodedValues, paramConfigMap);\n    return {\n        encodedValues: encodedValues,\n        decodedValues: hasNewDecodedValues\n            ? decodedValues\n            : decodedValuesCacheRef.current,\n    };\n}\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\nexport var useQueryParams = function (paramConfigMap) {\n    var _a = useLocationContext(), location = _a.location, getLocation = _a.getLocation, setLocation = _a.setLocation;\n    // read in the raw query\n    var parsedQuery = sharedMemoizedQueryParser(getSSRSafeSearchString(location));\n    // make caches\n    var paramConfigMapRef = React.useRef(paramConfigMap);\n    var parsedQueryRef = React.useRef(parsedQuery);\n    var encodedValuesCacheRef = React.useRef(undefined); // undefined for initial check\n    var decodedValuesCacheRef = React.useRef({});\n    // memoize paramConfigMap to make the API nicer for consumers.\n    // otherwise we'd have to useQueryParams(useMemo(() => { foo: NumberParam }, []))\n    paramConfigMap = shallowEqual(paramConfigMap, paramConfigMapRef.current)\n        ? paramConfigMapRef.current\n        : paramConfigMap;\n    // decode all the values if we have changes\n    var _b = getLatestDecodedValues(location, paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef), encodedValues = _b.encodedValues, decodedValues = _b.decodedValues;\n    // update cached values in useEffects\n    useUpdateRefIfShallowNew(parsedQueryRef, parsedQuery);\n    useUpdateRefIfShallowNew(paramConfigMapRef, paramConfigMap);\n    useUpdateRefIfShallowNew(encodedValuesCacheRef, encodedValues);\n    useUpdateRefIfShallowNew(decodedValuesCacheRef, decodedValues, function (a, b) {\n        return shallowEqual(a, b, paramConfigMap);\n    });\n    // create a setter for updating multiple query params at once\n    var setQueryDeps = {\n        paramConfigMap: paramConfigMap,\n        setLocation: setLocation,\n        getLocation: getLocation,\n    };\n    var setQueryDepsRef = React.useRef(setQueryDeps);\n    setQueryDepsRef.current = setQueryDeps;\n    var setQuery = React.useCallback(function (changes, updateType) {\n        var deps = setQueryDepsRef.current;\n        var encodedChanges;\n        if (typeof changes === 'function') {\n            // get latest decoded value to pass as a fresh arg to the setter fn\n            var latestValues = getLatestDecodedValues(deps.getLocation(), deps.paramConfigMap, paramConfigMapRef, parsedQueryRef, encodedValuesCacheRef, decodedValuesCacheRef).decodedValues;\n            decodedValuesCacheRef.current = latestValues; // keep cache in sync\n            encodedChanges = encodeQueryParams(deps.paramConfigMap, changes(latestValues));\n        }\n        else {\n            // encode as strings for the URL\n            encodedChanges = encodeQueryParams(deps.paramConfigMap, changes);\n        }\n        // update the URL\n        deps.setLocation(encodedChanges, updateType);\n    }, []);\n    // no longer Partial\n    return [decodedValues, setQuery];\n};\nexport default useQueryParams;\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport { LocationProvider } from './LocationProvider';\nimport shallowEqual from './shallowEqual';\n// we use a lazy caching solution to prevent #46 from happening\nvar cachedWindowHistory;\nvar cachedAdaptedWindowHistory;\n/**\n * Adapts standard DOM window history to work with our\n * { replace, push } interface.\n *\n * @param history Standard history provided by DOM\n */\nfunction adaptWindowHistory(history) {\n    if (history === cachedWindowHistory && cachedAdaptedWindowHistory != null) {\n        return cachedAdaptedWindowHistory;\n    }\n    var adaptedWindowHistory = {\n        replace: function (location) {\n            history.replaceState(location.state, '', location.protocol + \"//\" + location.host + location.pathname + location.search);\n        },\n        push: function (location) {\n            history.pushState(location.state, '', location.protocol + \"//\" + location.host + location.pathname + location.search);\n        },\n        get location() {\n            return window.location;\n        },\n    };\n    cachedWindowHistory = history;\n    cachedAdaptedWindowHistory = adaptedWindowHistory;\n    return adaptedWindowHistory;\n}\n// we use a lazy caching solution to prevent #46 from happening\nvar cachedReachHistory;\nvar cachedAdaptedReachHistory;\n/**\n * Adapts @reach/router history to work with our\n * { replace, push } interface.\n *\n * @param history globalHistory from @reach/router\n */\nfunction adaptReachHistory(history) {\n    if (history === cachedReachHistory && cachedAdaptedReachHistory != null) {\n        return cachedAdaptedReachHistory;\n    }\n    var adaptedReachHistory = {\n        replace: function (location) {\n            history.navigate(location.protocol + \"//\" + location.host + location.pathname + location.search, { replace: true });\n        },\n        push: function (location) {\n            history.navigate(location.protocol + \"//\" + location.host + location.pathname + location.search, { replace: false });\n        },\n        get location() {\n            return history.location;\n        },\n    };\n    cachedReachHistory = history;\n    cachedAdaptedReachHistory = adaptedReachHistory;\n    return adaptedReachHistory;\n}\n/**\n * Helper to produce the context value falling back to\n * window history and location if not provided.\n */\nexport function getLocationProps(_a) {\n    var _b = _a === void 0 ? {} : _a, history = _b.history, location = _b.location;\n    var hasWindow = typeof window !== 'undefined';\n    if (hasWindow) {\n        if (!history) {\n            history = adaptWindowHistory(window.history);\n        }\n        if (!location) {\n            location = window.location;\n        }\n    }\n    if (!location) {\n        throw new Error(\"\\n        Could not read the location. Is the router wired up correctly?\\n      \");\n    }\n    return { history: history, location: location };\n}\n/**\n * Context provider for query params to have access to the\n * active routing system, enabling updates to the URL.\n */\nexport function QueryParamProvider(_a) {\n    var children = _a.children, ReactRouterRoute = _a.ReactRouterRoute, reachHistory = _a.reachHistory, history = _a.history, location = _a.location, stringifyOptions = _a.stringifyOptions;\n    // cache the stringify options object so we users can just do\n    // <QueryParamProvider stringifyOptions={{ encode: false }} />\n    var stringifyOptionsRef = React.useRef(stringifyOptions);\n    var hasNewStringifyOptions = !shallowEqual(stringifyOptionsRef.current, stringifyOptions);\n    var stringifyOptionsCached = hasNewStringifyOptions\n        ? stringifyOptions\n        : stringifyOptionsRef.current;\n    React.useEffect(function () {\n        stringifyOptionsRef.current = stringifyOptionsCached;\n    }, [stringifyOptionsCached]);\n    // if we have React Router, use it to get the context value\n    if (ReactRouterRoute) {\n        return (React.createElement(ReactRouterRoute, null, function (routeProps) {\n            return (React.createElement(LocationProvider, __assign({ stringifyOptions: stringifyOptionsCached }, getLocationProps(routeProps)), children));\n        }));\n    }\n    // if we are using reach router, use its history\n    if (reachHistory) {\n        return (React.createElement(LocationProvider, __assign({ stringifyOptions: stringifyOptionsCached }, getLocationProps({\n            history: adaptReachHistory(reachHistory),\n            location: location,\n        })), children));\n    }\n    // neither reach nor react-router, so allow manual overrides\n    return (React.createElement(LocationProvider, __assign({ stringifyOptions: stringifyOptionsCached }, getLocationProps({ history: history, location: location })), children));\n}\nexport default QueryParamProvider;\n"],"names":["getEncodedValue","input","allowEmptyString","length","str","Array","StringParam","encode","String","decode","NumberParam","num","numStr","BooleanParam","bool","boolStr","Object","assign","t","s","i","n","arguments","p","prototype","hasOwnProperty","call","apply","this","updateLocation","encodedQuery","location","stringifyOptions","encodedSearchString","stringify","transformSearchString","search","href","parseUrl","url","key","Date","now","query","encodeQueryParams","paramConfigMap","_i","paramNames_1","keys","paramName","decodedValue","split","map","d","encodeURIComponent","is","x","y","shallowEqual","objA","objB","equalMap","_a","_b","keysA","keysB","isEqual","equals","useUpdateRefIfShallowNew","ref","newValue","hasNew","current","getSSRSafeSearchString","window","extract","pathname","LocationContext","getLocation","setLocation","useLocationContext","LocationProvider","history","children","locationRef","queryReplacements","updateType","encodedQueryReplacements","currQuery","parse","updateInLocation","createLocationWithChanges","push","replace","updateUrlQuery","Provider","value","cachedSearchString","cachedParsedQuery","sharedMemoizedQueryParser","initialSearchString","newSearchString","getLatestDecodedValue","name","paramConfig","paramConfigRef","encodedValueCacheRef","decodedValueCacheRef","hasNewParamConfig","isValueEqual","parsedQuery","hasNewEncodedValue","encodedValue","undefined","newDecodedValue","useQueryParam","setValueDeps","setValueDepsRef","setValue","newEncodedValue","deps","latestValue","getLatestDecodedValues","paramConfigMapRef","parsedQueryRef","encodedValuesCacheRef","decodedValuesCacheRef","hasNewParamConfigMap","encodedValues","decodedValues","encodedValuesCache","decodedValuesCache","cachedWindowHistory","cachedAdaptedWindowHistory","cachedReachHistory","cachedAdaptedReachHistory","a","b","setQueryDeps","setQueryDepsRef","changes","encodedChanges","latestValues","adaptReachHistory","adaptedReachHistory","navigate","protocol","host","getLocationProps","adaptedWindowHistory","replaceState","state","pushState","adaptWindowHistory","Error","QueryParamProvider","ReactRouterRoute","reachHistory","stringifyOptionsRef","stringifyOptionsCached","routeProps"],"sourceRoot":""}