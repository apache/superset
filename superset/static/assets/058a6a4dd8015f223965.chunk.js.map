{"version":3,"file":"058a6a4dd8015f223965.chunk.js","mappings":"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","sources":["webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/roundDecimal.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/geo.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/luminanceFromRGB.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/MapBox.jsx","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/sort.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/within.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/index.js","webpack://superset/./node_modules/supercluster/index.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/range.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/transformProps.js"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport default function roundDecimal(number, precision) {\n  let roundedNumber;\n  let p = precision;\n  if (precision) {\n    roundedNumber = Math.round(number * (p = 10 ** p)) / p;\n  } else {\n    roundedNumber = Math.round(number);\n  }\n\n  return roundedNumber;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport roundDecimal from './roundDecimal';\n\nexport const EARTH_CIRCUMFERENCE_KM = 40075.16;\nexport const MILES_PER_KM = 1.60934;\n\nexport function kmToPixels(kilometers, latitude, zoomLevel) {\n  // Algorithm from: http://wiki.openstreetmap.org/wiki/Zoom_levels\n  const latitudeRad = latitude * (Math.PI / 180);\n  // Seems like the zoomLevel is off by one\n  const kmPerPixel =\n    (EARTH_CIRCUMFERENCE_KM * Math.cos(latitudeRad)) / 2 ** (zoomLevel + 9);\n\n  return roundDecimal(kilometers / kmPerPixel, 2);\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const LUMINANCE_RED_WEIGHT = 0.2126;\nexport const LUMINANCE_GREEN_WEIGHT = 0.7152;\nexport const LUMINANCE_BLUE_WEIGHT = 0.0722;\n\nexport default function luminanceFromRGB(r, g, b) {\n  // Formula: https://en.wikipedia.org/wiki/Relative_luminance\n  return (\n    LUMINANCE_RED_WEIGHT * r +\n    LUMINANCE_GREEN_WEIGHT * g +\n    LUMINANCE_BLUE_WEIGHT * b\n  );\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    var m = Math.floor((left + right) / 2);\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        var t = coords[2 * k + inc];\n        var i = left;\n        var j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        var x = coords[2 * m];\n        var y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nexport default function kdbush(points, getX, getY, nodeSize, ArrayType) {\n    return new KDBush(points, getX, getY, nodeSize, ArrayType);\n}\n\nfunction KDBush(points, getX, getY, nodeSize, ArrayType) {\n    getX = getX || defaultGetX;\n    getY = getY || defaultGetY;\n    ArrayType = ArrayType || Array;\n\n    this.nodeSize = nodeSize || 64;\n    this.points = points;\n\n    this.ids = new ArrayType(points.length);\n    this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n        this.ids[i] = i;\n        this.coords[2 * i] = getX(points[i]);\n        this.coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sort(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);\n}\n\nKDBush.prototype = {\n    range: function (minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    },\n\n    within: function (x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n};\n\nfunction defaultGetX(p) { return p[0]; }\nfunction defaultGetY(p) { return p[1]; }\n","\nimport kdbush from 'kdbush';\n\nexport default function supercluster(options) {\n    return new SuperCluster(options);\n}\n\nfunction SuperCluster(options) {\n    this.options = extend(Object.create(this.options), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n}\n\nSuperCluster.prototype = {\n    options: {\n        minZoom: 0,   // min zoom to generate clusters on\n        maxZoom: 16,  // max zoom level to cluster the points on\n        radius: 40,   // cluster radius in pixels\n        extent: 512,  // tile extent (radius is calculated relative to it)\n        nodeSize: 64, // size of the KD-tree leaf node, affects performance\n        log: false,   // whether to log timing info\n\n        // a reduce function for calculating custom cluster properties\n        reduce: null, // function (accumulated, props) { accumulated.sum += props.sum; }\n\n        // initial properties of a cluster (before running the reducer)\n        initial: function () { return {}; }, // function () { return {sum: 0}; },\n\n        // properties to use for individual points when running the reducer\n        map: function (props) { return props; } // function (props) { return {sum: props.my_value}; },\n    },\n\n    load: function (points) {\n        var log = this.options.log;\n\n        if (log) console.time('total time');\n\n        var timerId = 'prepare ' + points.length + ' points';\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        var clusters = [];\n        for (var i = 0; i < points.length; i++) {\n            if (!points[i].geometry) {\n                continue;\n            }\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[this.options.maxZoom + 1] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {\n            var now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    },\n\n    getClusters: function (bbox, zoom) {\n        var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        var minLat = Math.max(-90, Math.min(90, bbox[1]));\n        var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        var tree = this.trees[this._limitZoom(zoom)];\n        var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        var clusters = [];\n        for (var i = 0; i < ids.length; i++) {\n            var c = tree.points[ids[i]];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    },\n\n    getChildren: function (clusterId) {\n        var originId = clusterId >> 5;\n        var originZoom = clusterId % 32;\n        var errorMsg = 'No cluster with the specified id.';\n\n        var index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        var origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        var ids = index.within(origin.x, origin.y, r);\n        var children = [];\n        for (var i = 0; i < ids.length; i++) {\n            var c = index.points[ids[i]];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    },\n\n    getLeaves: function (clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        var leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    },\n\n    getTile: function (z, x, y) {\n        var tree = this.trees[this._limitZoom(z)];\n        var z2 = Math.pow(2, z);\n        var extent = this.options.extent;\n        var r = this.options.radius;\n        var p = r / extent;\n        var top = (y - p) / z2;\n        var bottom = (y + 1 + p) / z2;\n\n        var tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    },\n\n    getClusterExpansionZoom: function (clusterId) {\n        var clusterZoom = (clusterId % 32) - 1;\n        while (clusterZoom < this.options.maxZoom) {\n            var children = this.getChildren(clusterId);\n            clusterZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return clusterZoom;\n    },\n\n    _appendLeaves: function (result, clusterId, limit, offset, skipped) {\n        var children = this.getChildren(clusterId);\n\n        for (var i = 0; i < children.length; i++) {\n            var props = children[i].properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(children[i]);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    },\n\n    _addTileFeatures: function (ids, points, x, y, z2, tile) {\n        for (var i = 0; i < ids.length; i++) {\n            var c = points[ids[i]];\n            var f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (c.x * z2 - x)),\n                    Math.round(this.options.extent * (c.y * z2 - y))\n                ]],\n                tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\n            };\n            var id = c.numPoints ? c.id : this.points[c.index].id;\n            if (id !== undefined) {\n                f.id = id;\n            }\n            tile.features.push(f);\n        }\n    },\n\n    _limitZoom: function (z) {\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n    },\n\n    _cluster: function (points, zoom) {\n        var clusters = [];\n        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (var i = 0; i < points.length; i++) {\n            var p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            var tree = this.trees[zoom + 1];\n            var neighborIds = tree.within(p.x, p.y, r);\n\n            var numPoints = p.numPoints || 1;\n            var wx = p.x * numPoints;\n            var wy = p.y * numPoints;\n\n            var clusterProperties = null;\n\n            if (this.options.reduce) {\n                clusterProperties = this.options.initial();\n                this._accumulate(clusterProperties, p);\n            }\n\n            // encode both zoom and point index on which the cluster originated\n            var id = (i << 5) + (zoom + 1);\n\n            for (var j = 0; j < neighborIds.length; j++) {\n                var b = tree.points[neighborIds[j]];\n                // filter out neighbors that are already processed\n                if (b.zoom <= zoom) continue;\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                var numPoints2 = b.numPoints || 1;\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b.y * numPoints2;\n\n                numPoints += numPoints2;\n                b.parentId = id;\n\n                if (this.options.reduce) {\n                    this._accumulate(clusterProperties, b);\n                }\n            }\n\n            if (numPoints === 1) {\n                clusters.push(p);\n            } else {\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n            }\n        }\n\n        return clusters;\n    },\n\n    _accumulate: function (clusterProperties, point) {\n        var properties = point.numPoints ?\n            point.properties :\n            this.options.map(this.points[point.index].properties);\n\n        this.options.reduce(clusterProperties, properties);\n    }\n};\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: x, // weighted cluster center\n        y: y,\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id: id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints: numPoints,\n        properties: properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    var coords = p.geometry.coordinates;\n    return {\n        x: lngX(coords[0]), // projected point coordinates\n        y: latY(coords[1]),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev =\n        count >= 10000 ? Math.round(count / 1000) + 'k' :\n        count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (var id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport supercluster from 'supercluster';\nimport { DEFAULT_POINT_RADIUS, DEFAULT_MAX_ZOOM } from './MapBox';\n\nconst NOOP = () => {};\n\nexport default function transformProps(chartProps) {\n  const { width, height, formData, hooks, queriesData } = chartProps;\n  const { onError = NOOP, setControlValue = NOOP } = hooks;\n  const { bounds, geoJSON, hasCustomMetric, mapboxApiKey } =\n    queriesData[0].data;\n  const {\n    clusteringRadius,\n    globalOpacity,\n    mapboxColor,\n    mapboxStyle,\n    pandasAggfunc,\n    pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n  } = formData;\n\n  // Validate mapbox color\n  const rgb = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/.exec(mapboxColor);\n  if (rgb === null) {\n    onError(\"Color field must be of form 'rgb(%d, %d, %d)'\");\n\n    return {};\n  }\n\n  const opts = {\n    maxZoom: DEFAULT_MAX_ZOOM,\n    radius: clusteringRadius,\n  };\n  if (hasCustomMetric) {\n    opts.initial = () => ({\n      sum: 0,\n      squaredSum: 0,\n      min: Infinity,\n      max: -Infinity,\n    });\n    opts.map = prop => ({\n      sum: prop.metric,\n      squaredSum: prop.metric ** 2,\n      min: prop.metric,\n      max: prop.metric,\n    });\n    opts.reduce = (accu, prop) => {\n      // Temporarily disable param-reassignment linting to work with supercluster's api\n      /* eslint-disable no-param-reassign */\n      accu.sum += prop.sum;\n      accu.squaredSum += prop.squaredSum;\n      accu.min = Math.min(accu.min, prop.min);\n      accu.max = Math.max(accu.max, prop.max);\n      /* eslint-enable no-param-reassign */\n    };\n  }\n  const clusterer = supercluster(opts);\n  clusterer.load(geoJSON.features);\n\n  return {\n    width,\n    height,\n    aggregatorName: pandasAggfunc,\n    bounds,\n    clusterer,\n    globalOpacity,\n    hasCustomMetric,\n    mapboxApiKey,\n    mapStyle: mapboxStyle,\n    onViewportChange({ latitude, longitude, zoom }) {\n      setControlValue('viewport_longitude', longitude);\n      setControlValue('viewport_latitude', latitude);\n      setControlValue('viewport_zoom', zoom);\n    },\n    pointRadius: pointRadius === 'Auto' ? DEFAULT_POINT_RADIUS : pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n    rgb,\n  };\n}\n"],"names":["roundDecimal","number","precision","roundedNumber","p","Math","round","kmToPixels","kilometers","latitude","zoomLevel","latitudeRad","PI","cos","propTypes","aggregation","PropTypes","compositeOperation","dotRadius","lngLatAccessor","locations","isRequired","pointRadiusUnit","renderWhileDragging","rgb","zoom","ScatterPlotGlowOverlay","React","constructor","props","super","this","redraw","bind","drawText","ctx","pixel","options","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","height","isDragging","project","clusterLabelMap","forEach","location","i","properties","cluster","count","point_count","sum","mean","squaredSum","variance","sqrt","computeClusterLabel","maxLabel","max","filter","v","Number","isNaN","clearRect","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointLabel","pointRadius","pointLatitude","undefined","render","defaultProps","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","aggregatorName","clusterer","globalOpacity","hasCustomMetric","mapStyle","mapboxApiKey","onViewportChange","bounds","MapBox","mercator","ViewportMercator","fitBounds","longitude","state","viewport","handleViewportChange","setState","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","mapboxApiAccessToken","preserveDrawingBuffer","coordinates","geometry","sortKD","ids","coords","nodeSize","left","right","depth","m","floor","k","inc","n","z","log","s","exp","sd","min","t","j","swapItem","swap","arr","tmp","sqDist","ax","ay","bx","by","dx","dy","kdbush","points","getX","getY","ArrayType","KDBush","defaultGetX","defaultGetY","Array","length","SuperCluster","extend","Object","create","trees","maxZoom","createCluster","id","numPoints","Infinity","parentId","getClusterJSON","type","getClusterProperties","y2","atan","abbrev","cluster_id","point_count_abbreviated","lngX","lng","latY","lat","sin","dest","src","prototype","range","minX","minY","maxX","maxY","stack","result","axis","pop","push","nextAxis","within","r","qx","qy","r2","minZoom","extent","reduce","initial","map","load","console","time","timerId","index","Float32Array","timeEnd","now","Date","_cluster","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","c","getChildren","clusterId","originId","originZoom","errorMsg","Error","origin","pow","children","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","clusterZoom","skipped","f","tags","neighborIds","wx","wy","clusterProperties","_accumulate","b","numPoints2","point","NOOP","transformProps","chartProps","formData","hooks","queriesData","onError","setControlValue","geoJSON","data","clusteringRadius","mapboxColor","mapboxStyle","pandasAggfunc","exec","opts","prop","accu"],"sourceRoot":""}