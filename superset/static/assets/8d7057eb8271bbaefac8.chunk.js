"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[5566,6871,1261],{95644:(t,i,e)=>{e.d(i,{N:()=>s});const o="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",n={lightSources:{}};function r({color:t=[0,0,0],intensity:i=1}={}){return t.map((t=>t*i/255))}const a={};const s={name:"gouraud-lighting",dependencies:[{name:"lights",vs:o,fs:o,getUniforms:function t(i=n){if("lightSources"in i){const{ambientLight:t,pointLights:e,directionalLights:o}=i.lightSources||{};return t||e&&e.length>0||o&&o.length>0?Object.assign({},function({ambientLight:t,pointLights:i=[],directionalLights:e=[]}){const o={};return o["lighting_uAmbientLight.color"]=t?r(t):[0,0,0],i.forEach(((t,i)=>{o["lighting_uPointLight[".concat(i,"].color")]=r(t),o["lighting_uPointLight[".concat(i,"].position")]=t.position,o["lighting_uPointLight[".concat(i,"].attenuation")]=t.attenuation||[1,0,0]})),o.lighting_uPointLightCount=i.length,e.forEach(((t,i)=>{o["lighting_uDirectionalLight[".concat(i,"].color")]=r(t),o["lighting_uDirectionalLight[".concat(i,"].direction")]=t.direction})),o.lighting_uDirectionalLightCount=e.length,o}({ambientLight:t,pointLights:e,directionalLights:o}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in i){const e={pointLights:[],directionalLights:[]};for(const t of i.lights||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights.push(t);break;case"point":e.pointLights.push(t)}return t({lightSources:e})}return{}},defines:{MAX_LIGHTS:3}}],vs:"\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",defines:{LIGHTING_VERTEX:1},getUniforms:function(t=a){if(!("material"in t))return{};const{material:i}=t;return i?function(t){const{ambient:i=.35,diffuse:e=.6,shininess:o=32,specularColor:n=[30,30,30]}=t;return{lighting_uAmbient:i,lighting_uDiffuse:e,lighting_uShininess:o,lighting_uSpecularColor:n.map((t=>t/255))}}(i):{lighting_uEnabled:!1}}}},36665:(t,i,e)=>{e.d(i,{Z:()=>d});var o=e(78580),n=e.n(o),r=e(67294),a=e(45697),s=e.n(a),l=e(51995),g=e(67190),c=e(11965);const h=l.iK.div`
  ${t=>{let{theme:i}=t;return`\n    font-size: ${i.typography.sizes.s}px;\n    position: absolute;\n    background: ${i.colors.grayscale.light5};\n    box-shadow: 0 0 ${i.gridUnit}px ${i.colors.grayscale.light2};\n    margin: ${6*i.gridUnit}px;\n    padding: ${3*i.gridUnit}px ${5*i.gridUnit}px;\n    outline: none;\n    overflow-y: scroll;\n    max-height: 200px;\n\n    & ul {\n      list-style: none;\n      padding-left: 0;\n      margin: 0;\n\n      & li a {\n        color: ${i.colors.grayscale.base};\n        text-decoration: none;\n\n        & span {\n          margin-right: ${3*i.gridUnit}px;\n        }\n      }\n    }\n  `}}
`,p=" - ",u={categories:s().object,forceCategorical:s().bool,format:s().string,position:s().oneOf([null,"tl","tr","bl","br"]),showSingleCategory:s().func,toggleCategory:s().func};class d extends r.PureComponent{format(t){if(!this.props.format||this.props.forceCategorical)return t;const i=parseFloat(t);return(0,g.uf)(this.props.format,i)}formatCategoryLabel(t){if(!this.props.format)return t;if(n()(t).call(t,p)){const i=t.split(p);return this.format(i[0])+p+this.format(i[1])}return this.format(t)}render(){if(0===Object.keys(this.props.categories).length||null===this.props.position)return null;const t=Object.entries(this.props.categories).map((t=>{let[i,e]=t;const o={color:`rgba(${e.color.join(", ")})`},n=e.enabled?"◼":"◻";return(0,c.tZ)("li",{key:i},(0,c.tZ)("a",{href:"#",onClick:()=>this.props.toggleCategory(i),onDoubleClick:()=>this.props.showSingleCategory(i)},(0,c.tZ)("span",{style:o},n)," ",this.formatCategoryLabel(i)))})),i={position:"absolute",["t"===this.props.position.charAt(0)?"top":"bottom"]:"0px",["r"===this.props.position.charAt(1)?"right":"left"]:"10px"};return(0,c.tZ)(h,{style:i},(0,c.tZ)("ul",null,t))}}d.propTypes=u,d.defaultProps={categories:{},forceCategorical:!1,format:null,position:"tr",showSingleCategory:()=>{},toggleCategory:()=>{}}},94828:(t,i,e)=>{e.r(i),e.d(i,{getLayer:()=>u,default:()=>d});var o=e(99396),n=(e(67294),e(55867)),r=e(28062),a=e(52154),s=e(21207),l=e(64106),g=e(26331),c=e(1740),h=e(11965);function p(t){return(0,h.tZ)("div",{className:"deckgl-tooltip"},(0,h.tZ)(c.Z,{label:(0,n.t)("Longitude and Latitude")+": ",value:`${t.coordinate[0]}, ${t.coordinate[1]}`}),(0,h.tZ)(c.Z,{label:(0,n.t)("Height")+": ",value:`${t.object.elevationValue}`}))}function u(t,i,e,n){const g=t,c=r.getScale(g.color_scheme).range().map((t=>(0,l.hexToRGB)(t)));let h=i.data.features;g.js_data_mutator&&(h=(0,s.Z)(g.js_data_mutator)(h));const u=(0,a.Z)(g.js_agg_function,(t=>t.weight));return new o.Z({id:`grid-layer-${g.slice_id}`,data:h,pickable:!0,cellSize:g.grid_size,extruded:g.extruded,colorRange:c,outline:!1,getElevationValue:u,getColorValue:u,...(0,a.N)(g,n,p)})}const d=(0,g.G)(u,(function(t){return t.map((t=>t.position))}))},26331:(t,i,e)=>{e.d(i,{B:()=>y,G:()=>C});var o=e(18446),n=e.n(o),r=e(67294),a=e(84502),s=e(45697),l=e.n(s),g=e(28062),c=e(85531),h=e(36665),p=e(64106),u=e(66911),d=e(21207),f=e(40461),m=e(11965);const{getScale:_}=g,L={datasource:l().object.isRequired,formData:l().object.isRequired,getLayer:l().func.isRequired,getPoints:l().func.isRequired,height:l().number.isRequired,mapboxApiKey:l().string.isRequired,onAddFilter:l().func,payload:l().object.isRequired,setControlValue:l().func.isRequired,viewport:l().object.isRequired,width:l().number.isRequired};class b extends r.PureComponent{constructor(t){super(t),this.containerRef=r.createRef(),this.setTooltip=t=>{const{current:i}=this.containerRef;i&&i.setTooltip(t)},this.state=this.getStateFromProps(t),this.getLayers=this.getLayers.bind(this),this.onValuesChange=this.onValuesChange.bind(this),this.toggleCategory=this.toggleCategory.bind(this),this.showSingleCategory=this.showSingleCategory.bind(this)}UNSAFE_componentWillReceiveProps(t){t.payload.form_data!==this.state.formData&&this.setState({...this.getStateFromProps(t)})}onValuesChange(t){this.setState({values:Array.isArray(t)?t:[t,t+this.state.getStep(t)]})}getStateFromProps(t,i){const e=t.payload.data.features||[],o=e.map((t=>t.__timestamp)),n=function(t,i){const e=t.color_picker||{r:0,g:0,b:0,a:1},o=[e.r,e.g,e.b,255*e.a],n=_(t.color_scheme),r={};return i.forEach((i=>{if(null!=i.cat_color&&!r.hasOwnProperty(i.cat_color)){let a;a=t.dimension?(0,p.hexToRGB)(n(i.cat_color,t.sliceId),255*e.a):o,r[i.cat_color]={color:a,enabled:!0}}})),r}(t.formData,e);if(i&&t.payload.form_data===i.formData)return{...i,categories:n};const r=t.payload.form_data.time_grain_sqla||t.payload.form_data.granularity||"P1D",{start:a,end:s,getStep:l,values:g,disabled:c}=(0,u.g)(o,r),{width:h,height:d,formData:m}=t;let{viewport:L}=t;return m.autozoom&&(L=(0,f.Z)(L,{width:h,height:d,points:t.getPoints(e)})),L.zoom<0&&(L.zoom=0),{start:a,end:s,getStep:l,values:g,disabled:c,viewport:L,selected:[],lastClick:0,formData:t.payload.form_data,categories:n}}getLayers(t){const{getLayer:i,payload:e,formData:o,onAddFilter:n}=this.props;let r=e.data.features?[...e.data.features]:[];r=this.addColor(r,o),o.js_data_mutator&&(r=(0,d.Z)(o.js_data_mutator)(r)),r=t[0]===t[1]||t[1]===this.end?r.filter((i=>i.__timestamp>=t[0]&&i.__timestamp<=t[1])):r.filter((i=>i.__timestamp>=t[0]&&i.__timestamp<t[1]));const a=this.state.categories;return o.dimension&&(r=r.filter((t=>a[t.cat_color]&&a[t.cat_color].enabled))),[i(o,{...e,data:{...e.data,features:r}},n,this.setTooltip,this.props.datasource)]}addColor(t,i){const e=i.color_picker||{r:0,g:0,b:0,a:1},o=_(i.color_scheme);return t.map((t=>{let n;return i.dimension?(n=(0,p.hexToRGB)(o(t.cat_color,i.sliceId),255*e.a),{...t,color:n}):t}))}toggleCategory(t){const i=this.state.categories[t],e={...this.state.categories,[t]:{...i,enabled:!i.enabled}};Object.values(e).every((t=>!t.enabled))&&Object.values(e).forEach((t=>{t.enabled=!0})),this.setState({categories:e})}showSingleCategory(t){const i={...this.state.categories};Object.values(i).forEach((t=>{t.enabled=!1})),i[t].enabled=!0,this.setState({categories:i})}render(){return(0,m.tZ)("div",{style:{position:"relative"}},(0,m.tZ)(c.Z,{ref:this.containerRef,getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,disabled:this.state.disabled,viewport:this.state.viewport,mapboxApiAccessToken:this.props.mapboxApiKey,mapStyle:this.props.formData.mapbox_style,setControlValue:this.props.setControlValue,width:this.props.width,height:this.props.height},(0,m.tZ)(h.Z,{forceCategorical:!0,categories:this.state.categories,format:this.props.formData.legend_format,position:this.props.formData.legend_position,showSingleCategory:this.showSingleCategory,toggleCategory:this.toggleCategory})))}}function C(t,i){class e extends r.PureComponent{constructor(t){super(t),this.containerRef=r.createRef(),this.setTooltip=t=>{const{current:i}=this.containerRef;i&&(null==i||i.setTooltip(t))};const{width:e,height:o,formData:n}=t;let{viewport:a}=t;n.autozoom&&(a=(0,f.Z)(a,{width:e,height:o,points:i(t.payload.data.features)})),this.state={viewport:a,layer:this.computeLayer(t)},this.onViewportChange=this.onViewportChange.bind(this)}UNSAFE_componentWillReceiveProps(t){const i={...t.formData,viewport:null},e={...this.props.formData,viewport:null};n()(i,e)&&t.payload===this.props.payload||this.setState({layer:this.computeLayer(t)})}onViewportChange(t){this.setState({viewport:t})}computeLayer(i){const{formData:e,payload:o,onAddFilter:n}=i;return t(e,o,n,this.setTooltip)}render(){const{formData:t,payload:i,setControlValue:e,height:o,width:n}=this.props,{layer:r,viewport:s}=this.state;return(0,m.tZ)(a.F,{ref:this.containerRef,mapboxApiAccessToken:i.data.mapboxApiKey,viewport:s,layers:[r],mapStyle:t.mapbox_style,setControlValue:e,width:n,height:o,onViewportChange:this.onViewportChange})}}return e}function y(t,i){return function(e){const{datasource:o,formData:n,height:r,payload:a,setControlValue:s,viewport:l,width:g}=e;return(0,m.tZ)(b,{datasource:o,formData:n,mapboxApiKey:a.data.mapboxApiKey,setControlValue:s,viewport:l,getLayer:t,payload:a,getPoints:i,width:g,height:r})}}b.propTypes=L}}]);
//# sourceMappingURL=8d7057eb8271bbaefac8.chunk.js.map
