{"version":3,"file":"2303fb8941bde712abf8.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@deck.gl/aggregation-layers/dist/esm/utils/cpu-aggregator.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js","webpack://superset/./node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js"],"sourcesContent":["import BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc, wrapGetValueFunc } from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\n\nconst defaultGetCellSize = props => props.cellSize;\n\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {\n      oldProps,\n      props,\n      changeFlags\n    } = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n\n    this.setState({\n      aggregationDirty\n    });\n    return this.state;\n  }\n\n  setState(updateObject) {\n    this.state = { ...this.state,\n      ...updateObject\n    };\n  }\n\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: { ...this.state.dimensions,\n        [key]: { ...this.state.dimensions[key],\n          ...updateObject\n        }\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    if (result.hexagons) {\n      return {\n        data: result.hexagons,\n        ...result\n      };\n    } else if (result.layerData) {\n      return {\n        data: result.layerData,\n        ...result\n      };\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {\n        value,\n        weight,\n        aggregation\n      } = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {\n            data: props.data\n          });\n        } else {\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {\n            data: props.data\n          });\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {\n          getValue\n        });\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n  }\n\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {\n        key\n      } = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({\n    key,\n    accessor,\n    pickingInfo,\n    getBins,\n    getDomain,\n    getScaleFunc,\n    nullValue\n  }) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {\n        updater: this.getDimensionSortedBins,\n        ...getBins\n      },\n      getDomain: {\n        updater: this.getDimensionValueDomain,\n        ...getDomain\n      },\n      getScaleFunc: {\n        updater: this.getDimensionScale,\n        ...getScaleFunc\n      },\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n      }\n\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    const updaters = [];\n\n    for (const key in this.dimensionUpdaters) {\n      const needUpdate = dimensionSteps.find(step => this.needUpdateDimensionStep(this.dimensionUpdaters[key][step], oldProps, props, changeFlags));\n\n      if (needUpdate) {\n        updaters.push(this.dimensionUpdaters[key][needUpdate].updater.bind(this, props, this.dimensionUpdaters[key]));\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {\n        accessor\n      } = this.dimensionUpdaters[key];\n      updateTriggers[accessor] = {};\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(({\n          prop,\n          updateTrigger\n        }) => {\n          if (updateTrigger) {\n            const fromProp = _updateTriggers[updateTrigger];\n\n            if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n              Object.assign(updateTriggers[accessor], fromProp);\n            } else if (fromProp !== undefined) {\n              updateTriggers[accessor][prop] = fromProp;\n            }\n          } else {\n            updateTriggers[accessor][prop] = props[prop];\n          }\n        });\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {\n      key\n    } = dimensionUpdater;\n    const {\n      getValue\n    } = this.state.dimensions[key];\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {\n      sortedBins\n    });\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {\n      getDomain,\n      key\n    } = dimensionUpdater;\n    const {\n      triggers: {\n        lowerPercentile,\n        upperPercentile,\n        scaleType\n      }\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n    this.setDimensionState(key, {\n      valueDomain\n    });\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {\n      key,\n      getScaleFunc,\n      getDomain\n    } = dimensionUpdater;\n    const {\n      domain,\n      range\n    } = getScaleFunc.triggers;\n    const {\n      scaleType\n    } = getDomain.triggers;\n    const {\n      onSet\n    } = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {\n      scaleFunc\n    });\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {\n        sortedBins,\n        scaleFunc\n      } = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        return nullValue;\n      }\n\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {\n        accessor\n      } = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      const cell = this.state.layerData.data[info.index];\n      const binInfo = {};\n\n      for (const key in this.dimensionUpdaters) {\n        const {\n          pickingInfo\n        } = this.dimensionUpdaters[key];\n        const {\n          sortedBins\n        } = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    info.picked = Boolean(object);\n    info.object = object;\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n\n}\n//# sourceMappingURL=cpu-aggregator.js.map","import { log } from '@deck.gl/core';\nimport { Geometry, uid } from '@luma.gl/core';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nexport default class ColumnGeometry extends Geometry {\n  constructor(props = {}) {\n    const {\n      id = uid('column-geometry')\n    } = props;\n    const {\n      indices,\n      attributes\n    } = tesselateColumn(props);\n    super({ ...props,\n      id,\n      indices,\n      attributes\n    });\n  }\n\n}\n\nfunction tesselateColumn(props) {\n  const {\n    radius,\n    height = 1,\n    nradial = 10\n  } = props;\n  let {\n    vertices\n  } = props;\n\n  if (vertices) {\n    log.assert(vertices.length >= nradial);\n    vertices = vertices.flatMap(v => [v[0], v[1]]);\n    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);\n  }\n\n  const isExtruded = height > 0;\n  const vertsAroundEdge = nradial + 1;\n  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;\n  const stepAngle = Math.PI * 2 / nradial;\n  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  let i = 0;\n\n  if (isExtruded) {\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const a = j * stepAngle;\n      const vertexIndex = j % nradial;\n      const sin = Math.sin(a);\n      const cos = Math.cos(a);\n\n      for (let k = 0; k < 2; k++) {\n        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n        positions[i + 2] = (1 / 2 - k) * height;\n        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;\n        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;\n        i += 3;\n      }\n    }\n\n    positions[i + 0] = positions[i - 3];\n    positions[i + 1] = positions[i - 2];\n    positions[i + 2] = positions[i - 1];\n    i += 3;\n  }\n\n  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);\n    const a = v * stepAngle;\n    const vertexIndex = (v + nradial) % nradial;\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n    positions[i + 2] = height / 2;\n    normals[i + 2] = 1;\n    i += 3;\n  }\n\n  if (isExtruded) {\n    let index = 0;\n\n    for (let j = 0; j < nradial; j++) {\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 2;\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 3;\n    }\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      }\n    }\n  };\n}\n//# sourceMappingURL=column-geometry.js.map","export default \"\\n#define SHADER_NAME column-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 normals;\\n\\nattribute vec3 instancePositions;\\nattribute float instanceElevations;\\nattribute vec3 instancePositions64Low;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute float instanceStrokeWidths;\\n\\nattribute vec3 instancePickingColors;\\nuniform float opacity;\\nuniform float radius;\\nuniform float angle;\\nuniform vec2 offset;\\nuniform bool extruded;\\nuniform bool isStroke;\\nuniform float coverage;\\nuniform float elevationScale;\\nuniform float edgeDistance;\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n\\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\\n  float elevation = 0.0;\\n  float strokeOffsetRatio = 1.0;\\n\\n  if (extruded) {\\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\\n  } else if (isStroke) {\\n    float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n      widthMinPixels, widthMaxPixels) / 2.0;\\n    strokeOffsetRatio -= sign(positions.z) * project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\\n  }\\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\\n  float dotRadius = radius * coverage * shouldRender;\\n\\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\\n  geometry.pickingColor = instancePickingColors;\\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\\n  vec3 centroidPosition64Low = instancePositions64Low;\\n  vec3 pos = vec3(project_size(rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius, 0.);\\n  DECKGL_FILTER_SIZE(pos, geometry);\\n\\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  if (extruded && !isStroke) {\\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\\n    vColor = vec4(lightColor, color.a * opacity);\\n  } else {\\n    vColor = vec4(color.rgb, color.a * opacity);\\n  }\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=column-layer-vertex.glsl.js.map","import { Layer, project32, gouraudLighting, picking } from '@deck.gl/core';\nimport { Model } from '@luma.gl/core';\nimport ColumnGeometry from './column-geometry';\nimport vs from './column-layer-vertex.glsl';\nimport fs from './column-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  diskResolution: {\n    type: 'number',\n    min: 4,\n    value: 20\n  },\n  vertices: null,\n  radius: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  angle: {\n    type: 'number',\n    value: 0\n  },\n  offset: {\n    type: 'array',\n    value: [0, 0]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  extruded: true,\n  wireframe: false,\n  filled: true,\n  stroked: false,\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true,\n  getColor: {\n    deprecatedFor: ['getFillColor', 'getLineColor']\n  }\n};\nexport default class ColumnLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking]\n    });\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceElevations: {\n        size: 1,\n        transition: true,\n        accessor: 'getElevation'\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getLineWidth',\n        transition: true\n      }\n    });\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    super.updateState({\n      props,\n      oldProps,\n      changeFlags\n    });\n    const regenerateModels = changeFlags.extensionsChanged;\n\n    if (regenerateModels) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {\n      this._updateGeometry(props);\n    }\n  }\n\n  getGeometry(diskResolution, vertices, hasThinkness) {\n    const geometry = new ColumnGeometry({\n      radius: 1,\n      height: hasThinkness ? 2 : 0,\n      vertices,\n      nradial: diskResolution\n    });\n    let meanVertexDistance = 0;\n\n    if (vertices) {\n      for (let i = 0; i < diskResolution; i++) {\n        const p = vertices[i];\n        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n        meanVertexDistance += d / diskResolution;\n      }\n    } else {\n      meanVertexDistance = 1;\n    }\n\n    this.setState({\n      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance\n    });\n    return geometry;\n  }\n\n  _getModel(gl) {\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      isInstanced: true\n    });\n  }\n\n  _updateGeometry({\n    diskResolution,\n    vertices,\n    extruded,\n    stroked\n  }) {\n    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);\n    this.setState({\n      fillVertexCount: geometry.attributes.POSITION.value.length / 3,\n      wireframeVertexCount: geometry.indices.value.length\n    });\n    this.state.model.setProps({\n      geometry\n    });\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      viewport\n    } = this.context;\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      elevationScale,\n      extruded,\n      filled,\n      stroked,\n      wireframe,\n      offset,\n      coverage,\n      radius,\n      angle\n    } = this.props;\n    const {\n      model,\n      fillVertexCount,\n      wireframeVertexCount,\n      edgeDistance\n    } = this.state;\n    const widthMultiplier = lineWidthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n    model.setUniforms(uniforms).setUniforms({\n      radius,\n      angle: angle / 180 * Math.PI,\n      offset,\n      extruded,\n      coverage,\n      elevationScale,\n      edgeDistance,\n      widthScale: lineWidthScale * widthMultiplier,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels\n    });\n\n    if (extruded && wireframe) {\n      model.setProps({\n        isIndexed: true\n      });\n      model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({\n        isStroke: true\n      }).draw();\n    }\n\n    if (filled) {\n      model.setProps({\n        isIndexed: false\n      });\n      model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({\n        isStroke: false\n      }).draw();\n    }\n\n    if (!extruded && stroked) {\n      model.setProps({\n        isIndexed: false\n      });\n      model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({\n        isStroke: true\n      }).draw();\n    }\n  }\n\n}\nColumnLayer.layerName = 'ColumnLayer';\nColumnLayer.defaultProps = defaultProps;\n//# sourceMappingURL=column-layer.js.map","export default \"#define SHADER_NAME column-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=column-layer-fragment.glsl.js.map"],"names":["nop","dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","cellSize","CPUAggregator","constructor","opts","this","state","layerData","dimensions","changeFlags","dimensionUpdaters","_getCellSize","getCellSize","_getAggregator","getAggregator","_addDimension","static","updateState","aggregationParams","oldProps","updateGetValueFuncs","reprojectNeeded","needsReProjectPoints","aggregationDirty","dataChanged","getAggregatedData","getDimensionChanges","forEach","f","setState","updateObject","setDimensionState","normalizeResult","result","hexagons","data","aggregator","getSortedBins","getValue","needUpdateDimensionStep","updateTriggersChanged","all","getPosition","addDimension","dimension","getDimensionUpdaters","sortedBins","scaleFunc","updater","getDimensionSortedBins","getDimensionValueDomain","getDimensionScale","attributeAccessor","getSubLayerDimensionAttribute","dimensionStep","Object","values","some","item","updaters","needUpdate","find","step","push","bind","length","getUpdateTriggers","_updateTriggers","updateTriggers","fromProp","Array","isArray","undefined","assign","dimensionUpdater","_filterData","valueDomain","getValueDomainByScale","dimensionRange","dimensionDomain","ge","getScaleFunction","cell","bin","binMap","index","counts","cv","getSubLayerAccessors","accessors","getPickingInfo","info","object","picked","binInfo","points","filteredPoints","Boolean","getAccessor","dimensionKey","hasOwnProperty","ColumnGeometry","id","indices","attributes","radius","height","nradial","vertices","log","flatMap","v","isExtruded","vertsAroundEdge","numVertices","stepAngle","Math","PI","Uint16Array","positions","Float32Array","normals","i","j","a","vertexIndex","sin","cos","k","floor","sign","POSITION","size","NORMAL","tesselateColumn","super","DEFAULT_COLOR","defaultProps","diskResolution","type","min","angle","offset","coverage","max","elevationScale","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","Number","MAX_SAFE_INTEGER","extruded","wireframe","filled","stroked","x","position","getFillColor","getLineColor","getLineWidth","getElevation","material","getColor","deprecatedFor","ColumnLayer","getShaders","vs","fs","modules","project32","picking","initializeState","getAttributeManager","addInstanced","instancePositions","fp64","use64bitPositions","transition","instanceElevations","instanceFillColors","colorFormat","normalized","defaultValue","instanceLineColors","instanceStrokeWidths","regenerateModels","extensionsChanged","_this$state$model","gl","context","model","delete","_getModel","invalidateAll","_updateGeometry","getGeometry","hasThinkness","geometry","meanVertexDistance","p","sqrt","edgeDistance","isInstanced","fillVertexCount","wireframeVertexCount","setProps","draw","uniforms","viewport","widthMultiplier","metersPerPixel","setUniforms","widthScale","widthMinPixels","widthMaxPixels","isIndexed","setVertexCount","setDrawMode","isStroke","layerName"],"sourceRoot":""}