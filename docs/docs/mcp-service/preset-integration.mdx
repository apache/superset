---
title: Preset.io Integration
sidebar_position: 6
version: 1
---

# Preset.io Integration Guide

This document outlines integration points for the Preset.io team to extend the Superset MCP service with enterprise features, RBAC customizations, and OIDC integration.

## RBAC Extension Points

### Custom Authorization Factory

The MCP service supports custom authorization logic through the factory pattern:

```python
# In preset_config.py or superset_config.py
def create_preset_mcp_auth(app):
    """Custom auth factory for Preset.io environments."""
    from superset.mcp_service.auth import create_auth_provider
    from preset.auth.mcp import PresetMCPAuthProvider

    return PresetMCPAuthProvider(
        jwks_uri=app.config["PRESET_JWKS_URI"],
        issuer=app.config["PRESET_JWT_ISSUER"],
        audience=app.config["PRESET_JWT_AUDIENCE"],
        tenant_resolver=preset_tenant_resolver,
        rbac_manager=app.security_manager,
    )

MCP_AUTH_FACTORY = create_preset_mcp_auth
```

### Multi-Tenant RBAC

Extend the base auth hook for tenant-aware permissions:

```python
# preset/mcp/auth.py
from superset.mcp_service.auth import mcp_auth_hook
from functools import wraps

def preset_tenant_auth_hook(required_permissions=None):
    """Preset-specific auth hook with tenant isolation."""
    def decorator(func):
        @wraps(func)
        @mcp_auth_hook(required_permissions)
        def wrapper(*args, **kwargs):
            # Extract tenant from JWT claims
            tenant_id = g.user.tenant_id if hasattr(g.user, 'tenant_id') else None

            # Inject tenant context
            g.mcp_tenant_id = tenant_id
            g.mcp_tenant_context = get_tenant_context(tenant_id)

            return func(*args, **kwargs)
        return wrapper
    return decorator
```

### Custom Permission Scopes

Define Preset-specific permission scopes:

```python
# preset/mcp/permissions.py
PRESET_MCP_SCOPES = {
    # Tenant-level permissions
    "tenant:admin": "Full tenant administration",
    "tenant:read": "Read tenant resources",

    # Workspace-level permissions
    "workspace:admin": "Full workspace administration",
    "workspace:read": "Read workspace resources",

    # Enhanced dashboard permissions
    "dashboard:publish": "Publish dashboards to marketplace",
    "dashboard:embed": "Generate embed tokens",

    # Enhanced chart permissions
    "chart:export": "Export chart data and configs",
    "chart:alerts": "Manage chart alerts and notifications",

    # Dataset permissions with row-level security
    "dataset:rls": "Apply row-level security filters",
    "dataset:pii": "Access PII-flagged columns",
}

def get_preset_required_scopes(tool_name: str, context: dict = None) -> List[str]:
    """Map tool calls to Preset-specific permission requirements."""
    base_scopes = get_base_required_scopes(tool_name)

    # Add tenant-aware scopes
    if context and context.get('tenant_id'):
        base_scopes.append(f"tenant:{context['tenant_id']}")

    # Add workspace-aware scopes
    if context and context.get('workspace_id'):
        base_scopes.append(f"workspace:{context['workspace_id']}")

    return base_scopes
```

### Row-Level Security Integration

Extend data access tools with RLS:

```python
# preset/mcp/rls.py
def apply_preset_rls_filters(query_context: dict, user_context: dict) -> dict:
    """Apply Preset row-level security filters to query context."""

    # Get user's RLS rules from Preset metadata
    rls_rules = get_user_rls_rules(
        user_id=user_context['user_id'],
        tenant_id=user_context['tenant_id'],
        workspace_id=user_context.get('workspace_id')
    )

    # Apply RLS filters to query
    for rule in rls_rules:
        if rule.applies_to_dataset(query_context['datasource']['id']):
            query_context = rule.apply_filter(query_context)

    return query_context

# Usage in custom tools
@mcp.tool
@preset_tenant_auth_hook(['dataset:read', 'dataset:rls'])
def preset_get_chart_data(request: GetChartDataRequest) -> ChartDataResponse:
    """Get chart data with Preset RLS applied."""

    # Apply RLS before executing query
    query_context = build_query_context(request)
    query_context = apply_preset_rls_filters(
        query_context,
        {'user_id': g.user.id, 'tenant_id': g.mcp_tenant_id}
    )

    return execute_chart_data_query(query_context)
```

## OIDC Integration Points

### Preset OIDC Provider

Custom OIDC integration for Preset environments:

```python
# preset/mcp/oidc.py
from superset.mcp_service.auth.providers.bearer import BearerAuthProvider
import requests
from typing import Dict, Any

class PresetOIDCAuthProvider(BearerAuthProvider):
    """OIDC-specific auth provider for Preset.io."""

    def __init__(self,
                 oidc_discovery_url: str,
                 client_id: str,
                 client_secret: str = None,
                 **kwargs):

        # Discover OIDC endpoints
        self.discovery_doc = self._fetch_discovery_document(oidc_discovery_url)

        super().__init__(
            jwks_uri=self.discovery_doc['jwks_uri'],
            issuer=self.discovery_doc['issuer'],
            **kwargs
        )

        self.client_id = client_id
        self.client_secret = client_secret

    def _fetch_discovery_document(self, discovery_url: str) -> Dict[str, Any]:
        """Fetch OIDC discovery document."""
        response = requests.get(discovery_url)
        response.raise_for_status()
        return response.json()

    def validate_token(self, token: str) -> Dict[str, Any]:
        """Validate JWT token with OIDC-specific claims."""
        claims = super().validate_token(token)

        # Validate OIDC-specific claims
        if claims.get('aud') != self.client_id:
            raise ValueError("Invalid audience claim")

        # Extract Preset-specific claims
        claims['preset_tenant_id'] = claims.get('tenant_id')
        claims['preset_workspace_id'] = claims.get('workspace_id')
        claims['preset_roles'] = claims.get('roles', [])

        return claims

    def resolve_user(self, claims: Dict[str, Any]) -> Any:
        """Resolve Superset user from OIDC claims."""
        from preset.auth.user_resolver import resolve_preset_user

        return resolve_preset_user(
            subject=claims['sub'],
            email=claims.get('email'),
            tenant_id=claims.get('preset_tenant_id'),
            roles=claims.get('preset_roles', [])
        )
```

### Configuration for OIDC

```python
# In preset_config.py
def create_preset_oidc_auth(app):
    """Factory for Preset OIDC authentication."""
    from preset.mcp.oidc import PresetOIDCAuthProvider

    return PresetOIDCAuthProvider(
        oidc_discovery_url=app.config["PRESET_OIDC_DISCOVERY_URL"],
        client_id=app.config["PRESET_OIDC_CLIENT_ID"],
        client_secret=app.config["PRESET_OIDC_CLIENT_SECRET"],
        audience=app.config["PRESET_MCP_AUDIENCE"],
        required_scopes=app.config.get("PRESET_MCP_REQUIRED_SCOPES", [])
    )

# MCP Configuration
MCP_AUTH_ENABLED = True
MCP_AUTH_FACTORY = create_preset_oidc_auth

# OIDC Configuration
PRESET_OIDC_DISCOVERY_URL = "https://auth.preset.io/.well-known/openid_configuration"
PRESET_OIDC_CLIENT_ID = "preset-mcp-service"
PRESET_OIDC_CLIENT_SECRET = os.environ.get("PRESET_OIDC_CLIENT_SECRET")
PRESET_MCP_AUDIENCE = "preset-superset-mcp"
PRESET_MCP_REQUIRED_SCOPES = [
    "openid", "profile", "email",
    "superset:read", "superset:write"
]
```

## Preset-Specific Tools

### Tenant Management Tools

```python
# preset/mcp/tools/tenant.py
@mcp.tool
@preset_tenant_auth_hook(['tenant:read'])
def get_tenant_info(request: GetTenantInfoRequest) -> TenantInfoResponse:
    """Get Preset tenant information and quotas."""

    tenant_id = g.mcp_tenant_id
    tenant = get_tenant_by_id(tenant_id)

    return TenantInfoResponse(
        tenant_id=tenant.id,
        name=tenant.name,
        plan=tenant.plan,
        quotas=tenant.quotas,
        usage=get_tenant_usage(tenant_id),
        workspaces=list_tenant_workspaces(tenant_id)
    )

@mcp.tool
@preset_tenant_auth_hook(['workspace:read'])
def list_workspace_assets(request: ListWorkspaceAssetsRequest) -> ListWorkspaceAssetsResponse:
    """List all assets in a Preset workspace."""

    workspace_id = request.workspace_id
    tenant_id = g.mcp_tenant_id

    # Validate workspace belongs to tenant
    validate_workspace_access(workspace_id, tenant_id)

    assets = {
        'dashboards': list_workspace_dashboards(workspace_id),
        'charts': list_workspace_charts(workspace_id),
        'datasets': list_workspace_datasets(workspace_id)
    }

    return ListWorkspaceAssetsResponse(
        workspace_id=workspace_id,
        assets=assets,
        total_count=sum(len(v) for v in assets.values())
    )
```

### Embed Token Generation

```python
# preset/mcp/tools/embed.py
@mcp.tool
@preset_tenant_auth_hook(['dashboard:embed'])
def generate_embed_token(request: GenerateEmbedTokenRequest) -> EmbedTokenResponse:
    """Generate secure embed token for dashboard/chart."""

    # Validate resource access
    resource = validate_embed_resource_access(
        resource_type=request.resource_type,
        resource_id=request.resource_id,
        tenant_id=g.mcp_tenant_id
    )

    # Generate signed embed token
    embed_token = create_embed_token(
        resource=resource,
        user_id=g.user.id,
        tenant_id=g.mcp_tenant_id,
        permissions=request.permissions,
        expiry=request.expiry_hours
    )

    return EmbedTokenResponse(
        embed_token=embed_token,
        embed_url=f"{get_preset_base_url()}/embed/{embed_token}",
        expires_at=embed_token.expires_at
    )
```

## Audit and Compliance Extensions

### Enhanced Audit Logging

```python
# preset/mcp/audit.py
from superset.mcp_service.auth import get_audit_context

def create_preset_audit_context(user_context: dict, tool_name: str,
                               request_data: dict) -> dict:
    """Create Preset-specific audit context."""

    base_context = get_audit_context(user_context, tool_name, request_data)

    # Add Preset-specific fields
    preset_context = {
        **base_context,
        'tenant_id': user_context.get('tenant_id'),
        'workspace_id': user_context.get('workspace_id'),
        'preset_user_role': user_context.get('preset_role'),
        'data_classification': classify_request_data(request_data),
        'compliance_flags': get_compliance_flags(tool_name, request_data)
    }

    return preset_context

def log_preset_mcp_access(audit_context: dict):
    """Log MCP access to Preset audit systems."""

    # Log to Superset's audit system
    log_superset_audit_event(audit_context)

    # Log to Preset's compliance system
    log_preset_compliance_event(audit_context)

    # Log to external SIEM if configured
    if app.config.get('PRESET_SIEM_ENABLED'):
        log_to_siem(audit_context)
```

### Data Classification

```python
# preset/mcp/classification.py
def classify_request_data(request_data: dict) -> dict:
    """Classify data sensitivity in MCP requests."""

    classification = {
        'contains_pii': False,
        'data_level': 'public',
        'retention_policy': 'standard'
    }

    # Check for PII in request
    if contains_pii_fields(request_data):
        classification['contains_pii'] = True
        classification['data_level'] = 'restricted'
        classification['retention_policy'] = 'pii_compliant'

    # Check for sensitive datasets
    if references_sensitive_datasets(request_data):
        classification['data_level'] = 'confidential'

    return classification
```

## Deployment Considerations

### Multi-Region Deployment

```python
# preset/mcp/deployment.py
def get_region_specific_config():
    """Get region-specific MCP configuration."""

    region = os.environ.get('PRESET_REGION', 'us-east-1')

    config_map = {
        'us-east-1': {
            'jwks_uri': 'https://auth-us.preset.io/.well-known/jwks.json',
            'base_url': 'https://app.preset.io',
            'data_residency': 'US'
        },
        'eu-west-1': {
            'jwks_uri': 'https://auth-eu.preset.io/.well-known/jwks.json',
            'base_url': 'https://eu.preset.io',
            'data_residency': 'EU'
        }
    }

    return config_map.get(region, config_map['us-east-1'])

# Usage in config
region_config = get_region_specific_config()
PRESET_JWKS_URI = region_config['jwks_uri']
SUPERSET_WEBSERVER_ADDRESS = region_config['base_url']
```

### Health Check Extensions

```python
# preset/mcp/health.py
@mcp.tool
def preset_health_check() -> HealthCheckResponse:
    """Preset-specific health check for MCP service."""

    checks = {
        'mcp_service': check_mcp_service_health(),
        'database': check_database_health(),
        'auth_provider': check_auth_provider_health(),
        'tenant_isolation': check_tenant_isolation(),
        'rls_engine': check_rls_engine_health()
    }

    overall_status = 'healthy' if all(
        check['status'] == 'healthy' for check in checks.values()
    ) else 'degraded'

    return HealthCheckResponse(
        status=overall_status,
        checks=checks,
        region=os.environ.get('PRESET_REGION'),
        version=get_preset_mcp_version()
    )
```

## Configuration Templates

### Production Configuration

```python
# preset_production_config.py
from preset.mcp.auth import create_preset_oidc_auth
from preset.mcp.audit import create_preset_audit_context

# MCP Service Configuration
MCP_AUTH_ENABLED = True
MCP_AUTH_FACTORY = create_preset_oidc_auth
MCP_AUDIT_CONTEXT_FACTORY = create_preset_audit_context

# Preset OIDC Configuration
PRESET_OIDC_DISCOVERY_URL = "https://auth.preset.io/.well-known/openid_configuration"
PRESET_OIDC_CLIENT_ID = "preset-mcp-production"
PRESET_MCP_AUDIENCE = "preset-superset-mcp"

# Security Configuration
PRESET_MCP_REQUIRED_SCOPES = [
    "openid", "profile", "email",
    "tenant:read", "workspace:read",
    "dashboard:read", "chart:read", "dataset:read"
]

# Audit Configuration
PRESET_AUDIT_ENABLED = True
PRESET_SIEM_ENABLED = True
PRESET_COMPLIANCE_MODE = "SOC2"

# Performance Configuration
PRESET_MCP_CACHE_ENABLED = True
PRESET_MCP_RATE_LIMIT = "1000/hour"
PRESET_MCP_TIMEOUT = 30
```

This integration guide provides the Preset.io team with concrete extension points for implementing enterprise features while maintaining compatibility with the base MCP service architecture.
