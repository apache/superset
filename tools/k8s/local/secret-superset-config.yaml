apiVersion: v1
kind: Secret
metadata:
  name: vault-superset-config
  labels:
    app: vault-superset
type: Opaque
stringData:
  superset_config.py: |


    # ====== Superset imports ======
    import os
    import requests
    import sys
    import json
    import logging
    import subprocess
    from cachelib.redis import RedisCache
    from celery.schedules import crontab

    def env(key, default=None):
        return os.getenv(key, default)

    from typing import Dict, Union, List
    from flask_appbuilder.security.manager import AUTH_OAUTH
    from superset.security import SupersetSecurityManager

    # ====== LOGGING ======
    LOG_LEVELS = {
      "CRITICAL": 50,
      "ERROR": 40,
      "WARNING": 30,
      "INFO": 20,
      "DEBUG": 10,
      "NOTSET": 0,
    }

    LOGGER = logging.getLogger(__name__)
    logging.basicConfig(
        stream=sys.stdout,
        format="%(asctime)s %(levelname)-8s %(message)s",
        level=LOG_LEVELS.get(os.getenv("LOG_LEVEL", "DEBUG")),
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    # ====== Constants ===========
    OAUTH_RET_TYPE = Union[Dict[str, Union[str, List[str]]], None]
    BASE_DIR = os.path.abspath(os.path.dirname(__file__))
    DATA_DIR = os.path.join(os.path.expanduser("~"), ".superset")
    FLASK_SECRET = env('SECRET_KEY', 'thisISaSECRET_1234')

    #    OKTA_BASE_URL = os.getenv("OKTA_BASE_URL", None)
    #    OKTA_KEY = os.getenv("OKTA_KEY", None)
    #    OKTA_SECRET = os.getenv("OKTA_SECRET", None)
    #
    #    if OKTA_BASE_URL is None or OKTA_KEY is None or OKTA_SECRET is None:
    #        raise ValueError(f"OKTA_BASE_URL: {OKTA_BASE_URL}, OKTA_KEY: {OKTA_KEY}, OKTA_SECRET: {OKTA_SECRET}")

    LOG_FORMAT = "%(asctime)s:%(levelname)s:%(name)s:%(message)s"
    LOG_LEVEL = os.getenv("LOG_LEVEL", "DEBUG")
    TIME_ROTATE_LOG_LEVEL = os.getenv("TIME_ROTATE_LOG_LEVEL", "DEBUG")
    ENABLE_TIME_ROTATE = True
    FILENAME_PATH = "/home/superset/.superset/superset.log"

    subprocess.call(["touch", FILENAME_PATH])

    if os.path.exists(FILENAME_PATH):
        LOGGER.info(f"FILENAME_PATH: {FILENAME_PATH}, os.path.exists(FILENAME_PATH): {os.path.exists(FILENAME_PATH)}")
        FILENAME = FILENAME_PATH

    else:
        LOGGER.info(f"FILENAME_PATH: {FILENAME_PATH}, os.path.exists(FILENAME_PATH): {os.path.exists(FILENAME_PATH)}")

    ROLLOVER = "midnight"

    REQUESTS_LOG_LEVEL = LOG_LEVELS.get(os.getenv("REQUESTS_LOG_LEVEL", "CRITICAL"))
    WERKZEUG_LOG_LEVEL = LOG_LEVELS.get(os.getenv("WERKZEUG_LOG_LEVEL", "CRITICAL"))

    # OKTA groups -> Superset Admin
    OKTA_ADMIN_GROUPS = os.getenv("OKTA_ADMIN_GROUPS", "overwrite-me").split(",")
    SUPERSET_ADMIN_VALUES = os.getenv("SUPERSET_ADMIN_VALUES", "overwrite-me").split(",")

    # Okta groups -> Superset Alpha, sql_lab
    OKTA_NON_ADMIN_GROUPS = os.getenv("OKTA_NON_ADMIN_GROUPS", "overwrite-me").split(",")
    SUPERSET_NON_ADMIN_VALUES = os.getenv("SUPERSET_NON_ADMIN_VALUES", "overwrite-me").split(",")

    PUBLIC_ROLE_LIKE_GAMMA=True
    PUBLIC_ROLE_LIKE = "Alpha"

    # ====== Create Directory ===========
    if not os.path.exists(DATA_DIR):
        os.makedirs(DATA_DIR)

    # ====== Superset Persistance ======
    SQLLAB_BACKEND_PERSISTENCE = True

    # ====== Superset misc configuration ======
    FEATURE_FLAGS = {"THUMBNAILS": True, "SQL_VALIDATORS_BY_ENGINE": True, "SQLLAB_BACKEND_PERSISTENCE": True, "ENABLE_TEMPLATE_PROCESSING": True, "DASHBOARD_CROSS_FILTERS": True, "DASHBOARD_RBAC": True, "ESCAPE_MARKDOWN_HTML": True, "LISTVIEWS_DEFAULT_CARD_VIEW": True, "SCHEDULED_QUERIES": True, "ALERT_REPORTS": True, "DYNAMIC_PLUGINS": True, "DASHBOARD_NATIVE_FILTERS": True, "VERSIONED_EXPORT": True, "ENABLE_JAVASCRIPT_CONTROLS": True}
    ROW_LIMIT = 5000
    SUPERSET_WORKERS = 2
    SUPERSET_WEBSERVER_PORT = 8088
    SQLLAB_TIMEOUT = 600
    SUPERSET_WEBSERVER_TIMEOUT = 600
    SQLLAB_ASYNC_TIME_LIMIT_SEC = 60 * 5
    INTERVAL = 1
    BACKUP_COUNT = 30

    # ====== Flask App Builder configuration ======
    SECRET_KEY = FLASK_SECRET

    # The SQLAlchemy connection string to your database backend
    # This connection defines the path to the database that stores your
    # superset metadata (slices, connections, tables, dashboards, ...).
    # Note that the connection information to connect to the datasources
    # you want to explore are managed directly in the web UI
    CACHE_CONFIG = {
        'CACHE_TYPE': 'redis',
        'CACHE_DEFAULT_TIMEOUT': 300,
        'CACHE_KEY_PREFIX': 'superset_',
        'CACHE_REDIS_HOST': env('REDIS_HOST'),
        'CACHE_REDIS_PORT': env('REDIS_PORT'),
        'CACHE_REDIS_PASSWORD': env('REDIS_PASSWORD'),
        'CACHE_REDIS_DB': env('REDIS_DB', 1),
    }
    DATA_CACHE_CONFIG = CACHE_CONFIG
    PREVENT_UNSAFE_DB_CONNECTIONS = False
    SQLALCHEMY_DATABASE_URI = f"postgresql+psycopg2://{env('DB_USER')}:{env('DB_PASS')}@{env('DB_HOST')}:{env('DB_PORT')}/{env('DB_NAME')}"
    SQLALCHEMY_TRACK_MODIFICATIONS = True

    # ====== Flask-WTF flag for CSRF ======
    WTF_CSRF_ENABLED = True
    # Add endpoints that need to be exempt from CSRF protection
    WTF_CSRF_EXEMPT_LIST = ["superset.queries.saved_queries.api.post",
                            "superset.queries.saved_queries.api.delete"]
    # A CSRF token that expires in 1 year
    WTF_CSRF_TIME_LIMIT = 60 * 60 * 24 * 365


    class CeleryConfig:
        broker_url = f"redis://{env('REDIS_HOST')}:{env('REDIS_PORT')}/0"
        imports = ('superset.sql_lab', "superset.tasks", "superset.tasks.thumbnails", )
        result_backend = f"redis://{env('REDIS_HOST')}:{env('REDIS_PORT')}/0"
        worker_prefetch_multiplier = 10
        task_acks_late = True
        task_annotations = {
            'tasks.add': {
                'rate_limit': '10/s'
            },
            'sql_lab.get_sql_results': {
                'rate_limit': '100/s',
            },
            'email_reports.send': {
                'rate_limit': '1/s',
                'time_limit': 600,
                'soft_time_limit': 600,
                'ignore_result': True,
            },
        }
        beat_schedule = {
            'reports.scheduler': {
                'task': 'reports.scheduler',
                'schedule': crontab(minute='*', hour='*'),
            },
            'reports.prune_log': {
                'task': 'reports.prune_log',
                'schedule': crontab(minute=0, hour=0),
            },
        }
        CELERYBEAT_SCHEDULE = beat_schedule

    CELERY_CONFIG = CeleryConfig

    SCREENSHOT_LOCATE_WAIT = 100
    SCREENSHOT_LOAD_WAIT = 600



    # This is for internal use, you can keep http
    WEBDRIVER_BASEURL="http://vault-superset-hl:8088"
    # This is the link sent to the recipient, change to your domain eg. https://superset.mydomain.com
    WEBDRIVER_BASEURL_USER_FRIENDLY="http://localhost:8088"

    SLACK_API_TOKEN = env('SLACK_API_TOKEN')

    RESULTS_BACKEND = RedisCache(
      host=env('REDIS_HOST'),
      port=env('REDIS_PORT'),
      key_prefix='superset_results'
    )

    # ====== Set this API key to enable Mapbox visualizations ======
    MAPBOX_API_KEY = env('MAPBOX_API_KEY')

    #    # ====== Start Okta Login ===========
    #    AUTH_TYPE = AUTH_OAUTH
    #    # allow self-registration (login creates a user)
    #    AUTH_USER_REGISTRATION = True
    #    # default is a Gamma user
    #    AUTH_USER_REGISTRATION_ROLE = "Gamma"

    #    # ====== Okta Oath Providers ===========
    #    OAUTH_PROVIDERS = [{
    #        "name": "okta",
    #        "token_key": "access_token",
    #        "icon": "fa-circle-o",
    #        "remote_app": {
    #            "client_id": OKTA_KEY,
    #            "client_secret": OKTA_SECRET,
    #            "api_base_url": OKTA_BASE_URL,
    #            "client_kwargs": {
    #                "scope": "openid email profile groups"
    #            },
    #            "request_token_url": None,
    #            "access_token_url": f"{OKTA_BASE_URL}token",
    #            "authorize_url": f"{OKTA_BASE_URL}authorize",
    #        }
    #    }]

    #    # ====== OKTA CustomSsoSecurityManager ===========
    #    class CustomSsoSecurityManager(SupersetSecurityManager):
    #
    #        def oauth_user_info(self, provider: str, decode_format: str = "UTF-8", response = None) -> OAUTH_RET_TYPE:
    #            if provider == "okta":
    #                res: requests.models.Response = vars(self.appbuilder.sm.oauth_remotes[provider].get("userinfo"))
    #                status_code = res.get("status_code")
    #
    #                if status_code != 200:
    #                    err_msg = f"Failed To Obtain User Info, Status Code: {status_code}"
    #                    LOGGER.error(err_msg)
    #                    raise ValueError(err_msg)
    #                else:
    #                    LOGGER.debug(f"Success To Obtain User Info, Status Code: {status_code}")
    #
    #                byte_res = res.get("_content")
    #                user_info = json.loads(byte_res)
    #
    #                groups = user_info["groups"]
    #
    #                ## Switch Okta to Superset groups
    #                for group in groups:
    #
    #                    if group in OKTA_ADMIN_GROUPS:
    #                        groups = SUPERSET_ADMIN_VALUES
    #                        break
    #
    #                    elif group in OKTA_NON_ADMIN_GROUPS:
    #                        groups = SUPERSET_NON_ADMIN_VALUES
    #                        break
    #
    #                return {
    #                    "username": user_info["preferred_username"].partition("@")[0],
    #                    "name": user_info["name"],
    #                    "email": user_info["email"],
    #                    "first_name": user_info["given_name"],
    #                    "last_name": user_info["family_name"],
    #                    "roles": groups,
    #                }
    #
    #        def auth_user_oauth(self, userinfo):
    #            user = super(CustomSsoSecurityManager, self).auth_user_oauth(userinfo)
    #            roles = [self.find_role(x) for x in userinfo["roles"]]
    #            roles = [x for x in roles if x is not None]
    #            user.roles = roles
    #
    #            # update user roles
    #            self.update_user(user)
    #
    #            return user
    #
    #    CUSTOM_SECURITY_MANAGER = CustomSsoSecurityManager
    #
    #    # ====== End Okta Login ============


    # ====== Data Sources ============
    if "INIT_JOB" in os.environ:
      with open("import_datasources.yaml", 'w') as f:
        f.write(f"""
        databases:
          - database_name: fixtureapi-dev
            sqlalchemy_uri: postgres://imgarena:{env('FIXTURE_API_PASSWORD')}@fixtureapi-rds-writer.dev.imgarena.internal:5432/fixtureapi-dev
            cache_timeout: null
            expose_in_sqllab: true
            allow_run_async: false
            allow_ctas: false
            allow_cvas: false
            allow_csv_upload: false
        """.strip())

  superset_init.sh: |
    #!/bin/sh
    set -eu
    echo "Upgrading DB schema..."
    superset db upgrade
    echo "Initializing roles..."
    export FLASK_APP="superset.app:create_app()"
    superset init
    
    echo "Creating admin user..."
    superset fab create-admin \
                    --username admin \
                    --firstname Superset \
                    --lastname Admin \
                    --email admin@superset.com \
                    --password admin \
                    || true

    if [ -f "import_datasources.yaml" ]; then
      echo "Importing database connections.... "
      superset import_datasources -p import_datasources.yaml
    fi

  superset_bootstrap.sh: |
    #!/bin/bash
    rm -rf /var/lib/apt/lists/* && \
    pip install \
      psycopg2==2.9.3 \
      redis==3.5.3 && \
    if [ ! -f ~/bootstrap ]; then echo "Running Superset with uid 0" > ~/bootstrap; fi
