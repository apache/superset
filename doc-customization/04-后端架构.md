# Apache Superset 后端架构

## 1. 应用初始化

### 1.1 应用入口

[app.py](../superset/app.py) 是 Flask 应用的入口点：

```python
from flask import Flask
from superset.initialization import SupersetAppInitializer

def create_app(
    superset_config_module: Optional[str] = None,
    superset_app_root: Optional[str] = None,
) -> Flask:
    app = SupersetApp(__name__)

    # 加载配置
    config_module = superset_config_module or os.environ.get(
        "SUPERSET_CONFIG", "superset.config"
    )
    app.config.from_object(config_module)

    # 应用根路径配置
    app_root = superset_app_root or os.environ.get("SUPERSET_APP_ROOT", "/")
    if app_root != "/":
        app.wsgi_app = AppRootMiddleware(app.wsgi_app, app_root)

    # 初始化应用
    app_initializer = app.config.get("APP_INITIALIZER", SupersetAppInitializer)(app)
    app_initializer.init_app()

    # 调试模式下启动本地扩展监视器
    if app.debug:
        start_local_extensions_watcher_thread(app)

    return app
```

### 1.2 应用初始化器

[initialization/__init__.py](../superset/initialization/__init__.py) 中的 `SupersetAppInitializer` 负责应用初始化：

```python
class SupersetAppInitializer:
    def __init__(self, app: SupersetApp) -> None:
        self.superset_app = app
        self.config = app.config
        self.manifest: dict[Any, Any] = {}

    def init_app(self) -> None:
        """初始化应用的所有组件"""
        self.pre_init()
        self.configure_celery()
        self.init_db()
        self.init_views()
        self.init_appbuilder()
        self.init_extensions()
        self.init_security()
        self.init_cache()
        self.init_logging()
        self.init_stats_logger()
        self.init_encryption()
        self.init_migrations()
        self.init_data()
        self.post_init()

    def pre_init(self) -> None:
        """初始化前的准备工作"""
        wtforms_json.init()
        os.makedirs(self.config["DATA_DIR"], exist_ok=True)

    def init_views(self) -> None:
        """初始化视图"""
        from superset.views import register_views
        register_views(appbuilder)

    def init_security(self) -> None:
        """初始化安全"""
        from superset.security import SupersetSecurityManager
        appbuilder.security_manager = SupersetSecurityManager(appbuilder)
```

## 2. 数据模型层

### 2.1 核心模型

[models/core.py](../superset/models/core.py) 定义了核心数据模型：

```python
from sqlalchemy import Column, Integer, String, Text, DateTime
from sqlalchemy.orm import relationship
from flask_appbuilder import Model

class Database(Model):
    """数据库连接模型"""
    __tablename__ = 'dbs'

    id = Column(Integer, primary_key=True)
    database_name = Column(String(250), unique=True, nullable=False)
    sqlalchemy_uri = Column(Text)
    extra = Column(Text, nullable=True)
    impersonate_user = Column(String(255))
    exposed_type = Column(String(50))
    allow_ctas = Column(Boolean, default=False)
    allow_cvas = Column(Boolean, default=False)
    allow_multi_schema_metadata_fetch = Column(Boolean, default=False)
    force_ctas_schema = Column(String(250))
    verbose_name = Column(String(250))
    configuration_method = Column(String(50))
    server_cert = Column(Text, nullable=True)
    ssh_tunnel = Column(Text, nullable=True)

    # 关系
    tables = relationship('SqlaTable', backref='database')
    cached_query = relationship('Query', backref='database')

class Slice(Model):
    """图表模型"""
    __tablename__ = 'slices'

    id = Column(Integer, primary_key=True)
    slice_name = Column(String(250), unique=True, nullable=False)
    viz_type = Column(String(250))
    datasource_type = Column(String(50))
    datasource_id = Column(Integer)
    datasource_name = Column(Text)
    params = Column(Text)
    description_markeddown = Column(Text)
    description = Column(Text)
    owners = relationship('User', secondary=slice_user_table)
    created_by = relationship('User', foreign_keys=[created_by_fk])
    changed_by = relationship('User', foreign_keys=[changed_by_fk])

class Dashboard(Model):
    """仪表板模型"""
    __tablename__ = 'dashboards'

    id = Column(Integer, primary_key=True)
    dashboard_title = Column(String(500), nullable=False)
    position_json = Column(Text)
    json_metadata = Column(Text)
    css = Column(Text)
    slug = Column(String(255), unique=True, nullable=True)
    description_markeddown = Column(Text)
    description = Column(Text)
    owners = relationship('User', secondary=dashboard_user_table)
    created_by = relationship('User', foreign_keys=[created_by_fk])
    changed_by = relationship('User', foreign_keys=[changed_by_fk])
```

### 2.2 数据访问对象 (DAO)

[daos/](../superset/daos/) 目录包含数据访问对象：

```python
# daos/base.py
class BaseDAO:
    """基础 DAO 类"""
    model = None

    @classmethod
    def find_by_id(cls, id: int) -> Optional[Model]:
        """根据 ID 查找对象"""
        return db.session.query(cls.model).filter_by(id=id).one_or_none()

    @classmethod
    def find_all(cls) -> List[Model]:
        """查找所有对象"""
        return db.session.query(cls.model).all()

    @classmethod
    def create(cls, data: dict) -> Model:
        """创建新对象"""
        obj = cls.model(**data)
        db.session.add(obj)
        db.session.commit()
        return obj

    @classmethod
    def update(cls, obj: Model, data: dict) -> Model:
        """更新对象"""
        for key, value in data.items():
            setattr(obj, key, value)
        db.session.commit()
        return obj

    @classmethod
    def delete(cls, obj: Model) -> None:
        """删除对象"""
        db.session.delete(obj)
        db.session.commit()

# daos/chart.py
class ChartDAO(BaseDAO):
    model = Slice

    @staticmethod
    def get_chart_by_id(chart_id: int) -> Optional[Slice]:
        """获取图表"""
        return db.session.query(Slice).filter_by(id=chart_id).one_or_none()

    @staticmethod
    def get_charts_by_user(user_id: int) -> List[Slice]:
        """获取用户的图表"""
        return db.session.query(Slice).filter(
            Slice.owners.any(id=user_id)
        ).all()
```

## 3. 视图层 (API)

### 3.1 基础 API 视图

[views/base_api.py](../superset/views/base_api.py) 定义了基础 API 视图：

```python
from flask_appbuilder.api import BaseApi, expose, protect, safe
from flask import Response

class BaseSupersetApi(BaseApi):
    """Superset 基础 API 视图"""
    method_permission_name = MODEL_API_RW_METHOD_PERMISSION_MAP
    allow_browser_login = True

    def response(self, status_code: int, **kwargs) -> Response:
        """创建 JSON 响应"""
        from flask import jsonify
        return jsonify(kwargs), status_code

    def response_404(self) -> Response:
        """创建 404 响应"""
        from flask import jsonify
        return jsonify({"message": "Not found"}), 404
```

### 3.2 图表 API

[charts/api.py](../superset/charts/api.py) 定义了图表相关的 API：

```python
from flask_appbuilder.api import expose, protect, safe, rison
from flask_appbuilder.models.sqla.interface import SQLAInterface
from superset.views.base_api import BaseSupersetModelRestApi

class ChartRestApi(BaseSupersetModelRestApi):
    """图表 REST API"""
    method_permission_name = MODEL_API_RW_METHOD_PERMISSION_MAP
    allow_browser_login = True
    class_permission_name = "Chart"
    resource_name = "chart"
    openapi_spec_tag = "Chart"

    datamodel = SQLAInterface(Slice)

    @expose("/", methods=("GET",))
    @protect()
    @safe
    @rison()
    def get_list(self, **kwargs: Any) -> Response:
        """获取图表列表"""
        return super().get_list(**kwargs)

    @expose("/<pk>", methods=("GET",))
    @protect()
    @safe
    def get(self, pk: int) -> Response:
        """获取单个图表"""
        return super().get(pk)

    @expose("/", methods=("POST",))
    @protect()
    @safe
    @statsd_metrics
    def post(self) -> Response:
        """创建图表"""
        try:
            item = CreateChartCommand(self._get_post_args()).run()
            return self.response(201, **self._get_item_schema(item))
        except Exception as ex:
            return self.response_422(ex)

    @expose("/<pk>", methods=("PUT",))
    @protect()
    @safe
    @statsd_metrics
    def put(self, pk: int) -> Response:
        """更新图表"""
        try:
            item = UpdateChartCommand([pk], self._get_put_args()).run()
            return self.response(200, **self._get_item_schema(item))
        except Exception as ex:
            return self.response_422(ex)

    @expose("/<pk>", methods=("DELETE",))
    @protect()
    @safe
    @statsd_metrics
    def delete(self, pk: int) -> Response:
        """删除图表"""
        try:
            DeleteChartCommand([pk]).run()
            return self.response(204)
        except Exception as ex:
            return self.response_422(ex)
```

### 3.3 仪表板 API

[dashboards/api.py](../superset/dashboards/api.py) 定义了仪表板相关的 API：

```python
class DashboardRestApi(BaseSupersetModelRestApi):
    """仪表板 REST API"""
    method_permission_name = MODEL_API_RW_METHOD_PERMISSION_MAP
    allow_browser_login = True
    class_permission_name = "Dashboard"
    resource_name = "dashboard"
    openapi_spec_tag = "Dashboard"

    datamodel = SQLAInterface(Dashboard)

    @expose("/", methods=("GET",))
    @protect()
    @safe
    @rison()
    def get_list(self, **kwargs: Any) -> Response:
        """获取仪表板列表"""
        return super().get_list(**kwargs)

    @expose("/<pk>", methods=("GET",))
    @protect()
    @safe
    def get(self, pk: int) -> Response:
        """获取单个仪表板"""
        return super().get(pk)

    @expose("/", methods=("POST",))
    @protect()
    @safe
    @statsd_metrics
    def post(self) -> Response:
        """创建仪表板"""
        try:
            item = CreateDashboardCommand(self._get_post_args()).run()
            return self.response(201, **self._get_item_schema(item))
        except Exception as ex:
            return self.response_422(ex)
```

## 4. 命令模式 (Command Pattern)

### 4.1 基础命令类

[commands/base.py](../superset/commands/base.py) 定义了基础命令类：

```python
from abc import ABC, abstractmethod
from typing import Any, Optional

class BaseCommand(ABC):
    """基础命令类"""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        self._args = args
        self._kwargs = kwargs

    @abstractmethod
    def run(self) -> Any:
        """执行命令"""
        pass

    def validate(self) -> None:
        """验证命令参数"""
        pass

    def __call__(self) -> Any:
        """调用命令"""
        self.validate()
        return self.run()
```

### 4.2 图表命令

[commands/chart/](../superset/commands/chart/) 目录包含图表相关的命令：

```python
# commands/chart/create.py
from superset.commands.base import BaseCommand
from superset.daos.chart import ChartDAO
from superset.models.slice import Slice
from superset.utils.database import get_or_create_db

class CreateChartCommand(BaseCommand):
    """创建图表命令"""

    def __init__(self, data: dict[str, Any]):
        self._properties = data.copy()

    def run(self) -> Slice:
        """执行创建图表"""
        # 获取数据源
        datasource = self._get_datasource()

        # 创建图表
        chart = Slice(
            slice_name=self._properties["slice_name"],
            viz_type=self._properties["viz_type"],
            datasource_type=datasource.type,
            datasource_id=datasource.id,
            params=json.dumps(self._properties.get("query_context", {})),
            description=self._properties.get("description"),
        )

        # 设置所有者
        chart.owners = self._get_owners()

        # 保存到数据库
        db.session.add(chart)
        db.session.commit()

        return chart

    def validate(self) -> None:
        """验证输入"""
        if not self._properties.get("slice_name"):
            raise ChartInvalidError("图表名称不能为空")

        if not self._properties.get("viz_type"):
            raise ChartInvalidError("图表类型不能为空")

    def _get_datasource(self) -> Any:
        """获取数据源"""
        datasource_id = self._properties.get("datasource_id")
        datasource_type = self._properties.get("datasource_type")

        if datasource_type == "table":
            from superset.models.core import SqlaTable
            return db.session.query(SqlaTable).get(datasource_id)
        elif datasource_type == "query":
            # 处理查询数据源
            pass

    def _get_owners(self) -> List[User]:
        """获取所有者"""
        from flask_login import current_user
        return [current_user]

# commands/chart/update.py
class UpdateChartCommand(BaseCommand):
    """更新图表命令"""

    def __init__(self, chart_ids: List[int], data: dict[str, Any]):
        self._chart_ids = chart_ids
        self._properties = data.copy()

    def run(self) -> List[Slice]:
        """执行更新图表"""
        charts = []
        for chart_id in self._chart_ids:
            chart = ChartDAO.get_chart_by_id(chart_id)
            if not chart:
                raise ChartNotFoundError(f"图表 {chart_id} 不存在")

            # 更新图表属性
            if "slice_name" in self._properties:
                chart.slice_name = self._properties["slice_name"]
            if "viz_type" in self._properties:
                chart.viz_type = self._properties["viz_type"]
            if "params" in self._properties:
                chart.params = json.dumps(self._properties["params"])

            db.session.commit()
            charts.append(chart)

        return charts

    def validate(self) -> None:
        """验证输入"""
        if not self._chart_ids:
            raise ChartInvalidError("图表 ID 不能为空")
```

## 5. 查询引擎

### 5.1 查询上下文

[common/query_context.py](../superset/common/query_context.py) 定义了查询上下文：

```python
from typing import Any, ClassVar, TYPE_CHECKING
import pandas as pd
from superset.common.chart_data import ChartDataResultFormat, ChartDataResultType
from superset.common.query_context_processor import QueryContextProcessor
from superset.common.query_object import QueryObject
from superset.explorables.base import Explorable
from superset.models.slice import Slice

class QueryContext:
    """查询上下文"""

    cache_type: ClassVar[str] = "df"
    enforce_numerical_metrics: ClassVar[bool] = True

    datasource: Explorable
    slice_: Slice | None = None
    queries: list[QueryObject]
    form_data: dict[str, Any] | None
    result_type: ChartDataResultType
    result_format: ChartDataResultFormat
    force: bool
    custom_cache_timeout: int | None
    cache_values: dict[str, Any]

    _processor: QueryContextProcessor

    def __init__(
        self,
        *,
        datasource: Explorable,
        queries: list[QueryObject],
        slice_: Slice | None,
        form_data: dict[str, Any] | None,
        result_type: ChartDataResultType,
        result_format: ChartDataResultFormat,
        force: bool = False,
        custom_cache_timeout: int | None = None,
        cache_values: dict[str, Any],
    ) -> None:
        self.datasource = datasource
        self.slice_ = slice_
        self.result_type = result_type
        self.result_format = result_format
        self.queries = queries
        self.form_data = form_data
        self.force = force
        self.custom_cache_timeout = custom_cache_timeout
        self.cache_values = cache_values
        self._processor = QueryContextProcessor(self)

    def get_data(
        self,
        df: pd.DataFrame,
        coltypes: list[GenericDataType],
    ) -> str | list[dict[str, Any]]:
        """获取数据"""
        return self._processor.get_data(df, coltypes)

    def get_payload(
        self,
        cache_query_context: bool | None = False,
        force_cached: bool = False,
    ) -> dict[str, Any]:
        """获取查询结果"""
        return self._processor.get_payload(cache_query_context, force_cached)
```

### 5.2 查询对象

[common/query_object.py](../superset/common/query_object.py) 定义了查询对象：

```python
from typing import Any, Optional

class QueryObject:
    """查询对象"""

    def __init__(
        self,
        metrics: list[Any] | None = None,
        groupby: list[Any] | None = None,
        columns: list[Any] | None = None,
        granularity: Optional[str] = None,
        from_dttm: Optional[str] = None,
        to_dttm: Optional[str] = None,
        filters: list[Any] | None = None,
        orderby: list[Any] | None = None,
        row_limit: Optional[int] = None,
        extras: dict[str, Any] | None = None,
        is_timeseries: bool = False,
        timeseries_limit: Optional[int] = None,
        timeseries_limit_metric: Optional[Any] = None,
        order_desc: bool = True,
        post_processing: list[Any] | None = None,
        custom_sql: Optional[str] = None,
        custom_form_data: Optional[dict[str, Any]] = None,
    ) -> None:
        self.metrics = metrics or []
        self.groupby = groupby or []
        self.columns = columns or []
        self.granularity = granularity
        self.from_dttm = from_dttm
        self.to_dttm = to_dttm
        self.filters = filters or []
        self.orderby = orderby or []
        self.row_limit = row_limit
        self.extras = extras or {}
        self.is_timeseries = is_timeseries
        self.timeseries_limit = timeseries_limit
        self.timeseries_limit_metric = timeseries_limit_metric
        self.order_desc = order_desc
        self.post_processing = post_processing or []
        self.custom_sql = custom_sql
        self.custom_form_data = custom_form_data
```

## 6. 数据库引擎规范

### 6.1 基础引擎规范

[db_engine_specs/base.py](../superset/db_engine_specs/base.py) 定义了基础引擎规范：

```python
from sqlalchemy.engine.url import URL
from typing import Any, Optional, List

class BaseEngineSpec:
    """基础数据库引擎规范"""

    engine = None
    engine_name = None
    default_driver = None

    @classmethod
    def get_dbapi_uri(cls, connection_params: dict[str, Any]) -> str:
        """获取数据库连接 URI"""
        raise NotImplementedError

    @classmethod
    def get_sqla_column_type(cls, sqla_type: Any) -> Any:
        """获取 SQLAlchemy 列类型"""
        raise NotImplementedError

    @classmethod
    def convert_dttm(cls, dttm: datetime) -> str:
        """转换日期时间"""
        raise NotImplementedError

    @classmethod
    def epoch_to_dttm(cls) -> str:
        """获取 epoch 到日期时间的转换 SQL"""
        raise NotImplementedError

    @classmethod
    def epoch_ms_to_dttm(cls) -> str:
        """获取 epoch 毫秒到日期时间的转换 SQL"""
        raise NotImplementedError

    @classmethod
    def get_metrics(cls, metrics: list[Any]) -> list[Any]:
        """获取指标"""
        return metrics

    @classmethod
    def get_groupby(cls, groupby: list[Any]) -> list[Any]:
        """获取分组"""
        return groupby

    @classmethod
    def get_column_spec(cls, column: Any) -> dict[str, Any]:
        """获取列规范"""
        return {
            "type": column.type,
            "label": column.column_name,
            "is_dttm": column.is_temporal,
        }
```

### 6.2 PostgreSQL 引擎规范

[db_engine_specs/postgres.py](../superset/db_engine_specs/postgres.py) 定义了 PostgreSQL 引擎规范：

```python
from superset.db_engine_specs.base import BaseEngineSpec

class PostgresEngineSpec(BaseEngineSpec):
    """PostgreSQL 引擎规范"""

    engine = "postgresql"
    engine_name = "PostgreSQL"
    default_driver = "psycopg2"

    @classmethod
    def get_dbapi_uri(cls, connection_params: dict[str, Any]) -> str:
        """获取 PostgreSQL 连接 URI"""
        from superset.databases.utils import make_url_safe

        return str(
            URL.create(
                drivername=cls.engine,
                username=connection_params.get("username"),
                password=connection_params.get("password"),
                host=connection_params.get("host"),
                port=connection_params.get("port"),
                database=connection_params.get("database"),
            )
        )

    @classmethod
    def get_sqla_column_type(cls, sqla_type: Any) -> Any:
        """获取 PostgreSQL 列类型"""
        from sqlalchemy.dialects.postgresql import (
            INTEGER,
            BIGINT,
            SMALLINT,
            FLOAT,
            NUMERIC,
            VARCHAR,
            TEXT,
            TIMESTAMP,
            DATE,
            BOOLEAN,
        )

        type_mapping = {
            "INTEGER": INTEGER,
            "BIGINT": BIGINT,
            "SMALLINT": SMALLINT,
            "FLOAT": FLOAT,
            "NUMERIC": NUMERIC,
            "VARCHAR": VARCHAR,
            "TEXT": TEXT,
            "TIMESTAMP": TIMESTAMP,
            "DATE": DATE,
            "BOOLEAN": BOOLEAN,
        }

        return type_mapping.get(sqla_type, VARCHAR)

    @classmethod
    def convert_dttm(cls, dttm: datetime) -> str:
        """转换日期时间为 PostgreSQL 格式"""
        return f"'{dttm.strftime('%Y-%m-%d %H:%M:%S')'::timestamp"

    @classmethod
    def epoch_to_dttm(cls) -> str:
        """获取 epoch 到日期时间的转换 SQL"""
        return "to_timestamp({col})"

    @classmethod
    def epoch_ms_to_dttm(cls) -> str:
        """获取 epoch 毫秒到日期时间的转换 SQL"""
        return "to_timestamp({col} / 1000)"
```

## 7. 缓存机制

### 7.1 缓存管理器

[extensions/cache_manager.py](../superset/extensions/cache_manager.py) 定义了缓存管理器：

```python
from flask_caching import Cache
from typing import Any, Optional

class CacheManager:
    """缓存管理器"""

    def __init__(self, cache: Cache):
        self.cache = cache

    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        return self.cache.get(key)

    def set(self, key: str, value: Any, timeout: Optional[int] = None) -> bool:
        """设置缓存"""
        return self.cache.set(key, value, timeout=timeout)

    def delete(self, key: str) -> bool:
        """删除缓存"""
        return self.cache.delete(key)

    def clear(self) -> bool:
        """清空缓存"""
        return self.cache.clear()

    def memoize(self, timeout: Optional[int] = None):
        """缓存装饰器"""
        return self.cache.memoize(timeout=timeout)
```

### 7.2 查询缓存

```python
from superset.extensions import cache_manager

@cache_manager.cache.memoize(timeout=3600)
def get_chart_data(query_context: QueryContext) -> dict[str, Any]:
    """获取图表数据（带缓存）"""
    # 执行查询
    result = query_context.get_payload()
    return result
```

## 8. 安全管理

### 8.1 安全管理器

[security.py](../superset/security.py) 定义了安全管理器：

```python
from flask_appbuilder.security.sqla.manager import SecurityManager
from typing import List

class SupersetSecurityManager(SecurityManager):
    """Superset 安全管理器"""

    def __init__(self, appbuilder):
        super().__init__(appbuilder)

    def get_user_roles(self, user: User) -> List[Role]:
        """获取用户角色"""
        return user.roles

    def has_access(self, permission_name: str, view_name: str) -> bool:
        """检查用户是否有权限"""
        from flask_login import current_user
        return self.is_item_accessible(permission_name, view_name, current_user)

    def is_item_accessible(
        self,
        permission_name: str,
        view_name: str,
        user: User,
    ) -> bool:
        """检查项目是否可访问"""
        # 检查用户权限
        if user.is_anonymous:
            return False

        # 检查角色权限
        for role in user.roles:
            if role.has_permission(permission_name, view_name):
                return True

        return False
```

## 9. 下一步

阅读完本文档后，建议继续学习：

1. [数据模型](./05-数据模型.md) - 学习数据模型设计
2. [核心模块](./06-核心模块.md) - 学习核心业务模块
3. [查询引擎](./07-查询引擎.md) - 学习查询处理机制
