# Apache Superset 插件系统

## 1. 插件系统概述

### 1.1 插件架构

```
插件系统架构
├── 图表插件 (Chart Plugins)
│   ├── ECharts 插件
│   ├── 表格插件
│   ├── 透视表插件
│   ├── AG Grid 插件
│   └── 自定义图表插件
├── 数据源插件 (Data Source Plugins)
│   ├── 数据库引擎规范
│   ├── 自定义数据源
│   └── 数据连接器
├── 认证插件 (Authentication Plugins)
│   ├── OAuth 插件
│   ├── LDAP 插件
│   └── 自定义认证
├── 可视化插件 (Visualization Plugins)
│   ├── D3.js 插件
│   ├── ECharts 插件
│   └── Deck.GL 插件
└── 扩展插件 (Extension Plugins)
    ├── 命令扩展
    ├── API 扩展
    └── UI 扩展
```

### 1.2 插件类型

| 插件类型 | 用途 | 示例 |
|---------|------|------|
| **图表插件** | 扩展可视化类型 | 自定义图表、特殊图表 |
| **数据源插件** | 添加新的数据源 | 新数据库、新 API |
| **认证插件** | 扩展认证方式 | OAuth、LDAP、SSO |
| **可视化插件** | 扩展可视化库 | D3.js、ECharts、Deck.GL |
| **扩展插件** | 扩展系统功能 | 自定义命令、API |

## 2. 图表插件系统

### 2.1 图表插件架构

前端图表插件基于 `@superset-ui/core` 的 `ChartPlugin` 类：

```typescript
import { ChartPlugin, ChartProps } from '@superset-ui/core';

export default new ChartPlugin({
  type: 'my_custom_chart',
  name: 'My Custom Chart',
  description: 'A custom chart plugin',
  thumbnail: 'images/thumbnails/my-chart.png',
  
  // 控制面板配置
  controlPanel: () => import('./controlPanels/MyChartControlPanel'),
  
  // 图表组件
  loadChart: () => import('./MyChart'),
  
  // 元数据
  metadata: {
    canBeUserSpecific: true,
    showNoResults: true,
    isTimeseries: false,
  },
});
```

### 2.2 创建自定义图表

#### 2.2.1 图表组件

```typescript
import React, { PureComponent } from 'react';
import { ChartProps, ChartData } from '@superset-ui/core';

interface MyChartProps extends ChartProps {
  data: ChartData;
  width: number;
  height: number;
}

class MyChart extends PureComponent<MyChartProps> {
  render() {
    const { data, width, height } = this.props;

    return (
      <div style={{ width, height }}>
        <svg width={width} height={height}>
          {/* 自定义 SVG 渲染 */}
          {data.records.map((record, index) => (
            <circle
              key={index}
              cx={record.x}
              cy={record.y}
              r={record.r}
              fill={record.color}
            />
          ))}
        </svg>
      </div>
    );
  }
}

export default MyChart;
```

#### 2.2.2 控制面板

```typescript
import { t } from '@superset-ui/core';

export default {
  controlPanelSections: [
    {
      label: t('Data'),
      expanded: true,
      controlSetRows: [
        ['groupby'],
        ['metrics'],
        ['adhoc_metrics'],
      ],
    },
    {
      label: t('Chart Options'),
      expanded: true,
      controlSetRows: [
        ['color_scheme'],
        ['x_axis_label'],
        ['y_axis_label'],
      ],
    },
    {
      label: t('Custom Options'),
      expanded: true,
      controlSetRows: [
        ['show_legend'],
        ['show_tooltip'],
        ['animation_duration'],
      ],
    },
  ],
};
```

#### 2.2.3 插件注册

```typescript
// plugins/MyChartPlugin.ts
import { ChartPlugin } from '@superset-ui/core';
import MyChart from './MyChart';
import controlPanel from './controlPanels/MyChartControlPanel';

export default new ChartPlugin({
  type: 'my_custom_chart',
  name: 'My Custom Chart',
  description: 'A custom chart plugin',
  thumbnail: 'images/thumbnails/my-chart.png',
  controlPanel: () => Promise.resolve(controlPanel),
  loadChart: () => Promise.resolve(MyChart),
  metadata: {
    canBeUserSpecific: true,
    showNoResults: true,
    isTimeseries: false,
  },
});
```

#### 2.2.4 在应用中注册插件

```typescript
// src/setup/setupPlugins.ts
import { registerChart } from 'src/dashboard/components/nativeFilters/RegisterChart';
import myChartPlugin from './plugins/MyChartPlugin';

export default function setupPlugins() {
  registerChart(myChartPlugin);
}
```

### 2.3 ECharts 图表插件示例

```typescript
import React, { PureComponent } from 'react';
import * as echarts from 'echarts';
import { ChartProps, ChartData } from '@superset-ui/core';

interface EChartsProps extends ChartProps {
  data: ChartData;
  width: number;
  height: number;
  echartOptions: Record<string, unknown>;
}

class EchartsTimeseries extends PureComponent<EChartsProps> {
  chartRef: React.RefObject<HTMLDivElement>;
  chartInstance: echarts.ECharts | null = null;

  constructor(props: EChartsProps) {
    super(props);
    this.chartRef = React.createRef();
  }

  componentDidMount() {
    if (this.chartRef.current) {
      this.chartInstance = echarts.init(this.chartRef.current);
      this.updateChart();
    }
  }

  componentDidUpdate(prevProps: EChartsProps) {
    if (prevProps.data !== this.props.data || prevProps.echartOptions !== this.props.echartOptions) {
      this.updateChart();
    }
  }

  componentWillUnmount() {
    if (this.chartInstance) {
      this.chartInstance.dispose();
    }
  }

  updateChart() {
    if (!this.chartInstance) return;

    const { data, echartOptions } = this.props;
    const option = this.getOption(data, echartOptions);

    this.chartInstance.setOption(option);
  }

  getOption(data: ChartData, echartOptions: Record<string, unknown>) {
    const { records } = data;
    const xData = records.map(r => r.x);
    const yData = records.map(r => r.y);

    return {
      ...echartOptions,
      xAxis: {
        type: 'category',
        data: xData,
      },
      yAxis: {
        type: 'value',
      },
      series: [{
        data: yData,
        type: 'line',
      }],
    };
  }

  render() {
    const { width, height } = this.props;

    return (
      <div
        ref={this.chartRef}
        style={{ width, height }}
      />
    );
  }
}

export default EchartsTimeseries;
```

## 3. 数据源插件系统

### 3.1 数据库引擎规范

后端数据源插件基于 `BaseEngineSpec` 类：

```python
from superset.db_engine_specs.base import BaseEngineSpec
from typing import Any, Optional, List
from datetime import datetime

class MyDatabaseEngineSpec(BaseEngineSpec):
    """自定义数据库引擎规范"""

    engine = "mydb"
    engine_name = "My Database"
    default_driver = "mydb-driver"

    @classmethod
    def get_dbapi_uri(cls, connection_params: dict[str, Any]) -> str:
        """获取数据库连接 URI"""
        from sqlalchemy.engine.url import URL

        return str(
            URL.create(
                drivername=cls.engine,
                username=connection_params.get("username"),
                password=connection_params.get("password"),
                host=connection_params.get("host"),
                port=connection_params.get("port"),
                database=connection_params.get("database"),
            )
        )

    @classmethod
    def get_sqla_column_type(cls, sqla_type: Any) -> Any:
        """获取 SQLAlchemy 列类型"""
        from sqlalchemy import Integer, String, DateTime

        type_mapping = {
            "INTEGER": Integer,
            "VARCHAR": String,
            "TIMESTAMP": DateTime,
        }

        return type_mapping.get(sqla_type, String)

    @classmethod
    def convert_dttm(cls, dttm: datetime) -> str:
        """转换日期时间为数据库格式"""
        return f"'{dttm.strftime('%Y-%m-%d %H:%M:%S')}'"

    @classmethod
    def epoch_to_dttm(cls) -> str:
        """获取 epoch 到日期时间的转换 SQL"""
        return "FROM_UNIXTIME({col})"

    @classmethod
    def get_table_names(cls, database: Any, schema: Optional[str] = None) -> List[str]:
        """获取表名列表"""
        from sqlalchemy import inspect

        engine = database.get_sqla_engine()
        inspector = inspect(engine)

        if schema:
            return inspector.get_table_names(schema=schema)
        else:
            return inspector.get_table_names()

    @classmethod
    def get_columns(cls, database: Any, table_name: str, schema: Optional[str] = None) -> List[dict[str, Any]]:
        """获取表的列信息"""
        from sqlalchemy import inspect

        engine = database.get_sqla_engine()
        inspector = inspect(engine)

        columns = inspector.get_columns(table_name, schema=schema)

        return [
            {
                "name": col["name"],
                "type": str(col["type"]),
                "is_dttm": cls.is_temporal_type(col["type"]),
            }
            for col in columns
        ]

    @classmethod
    def is_temporal_type(cls, col_type: Any) -> bool:
        """检查是否是时间类型"""
        temporal_types = ["DATE", "TIMESTAMP", "TIME"]
        return any(t in str(col_type).upper() for t in temporal_types)
```

### 3.2 注册自定义引擎

```python
# superset/db_engine_specs/mydb.py
from superset.db_engine_specs.base import BaseEngineSpec
from superset.db_engine_specs import register_engine_spec

class MyDatabaseEngineSpec(BaseEngineSpec):
    engine = "mydb"
    engine_name = "My Database"
    default_driver = "mydb-driver"

    # 实现所有必要的方法...

# 注册引擎
register_engine_spec(MyDatabaseEngineSpec)
```

### 3.3 添加自定义数据源

```python
from superset.models.core import Database
from superset.extensions import db

# 创建自定义数据源
database = Database(
    database_name='My Custom Database',
    sqlalchemy_uri='mydb://user:password@localhost:5432/mydb',
    verbose_name='我的自定义数据库',
    allow_ctas=True,
    allow_cvas=True,
)

db.session.add(database)
db.session.commit()
```

## 4. 认证插件系统

### 4.1 自定义认证后端

```python
from flask_appbuilder.security.sqla.manager import SecurityManager
from flask_login import login_user
from typing import Optional

class CustomSecurityManager(SecurityManager):
    """自定义安全管理器"""

    def __init__(self, appbuilder):
        super().__init__(appbuilder)

    def authenticate(self, username: str, password: str) -> Optional[User]:
        """自定义认证逻辑"""
        # 调用外部认证服务
        user_info = self._call_external_auth_service(username, password)

        if not user_info:
            return None

        # 查找或创建用户
        user = self.find_user(username=username)

        if not user:
            user = self.create_user(user_info)

        return user

    def _call_external_auth_service(self, username: str, password: str) -> Optional[dict]:
        """调用外部认证服务"""
        import requests

        response = requests.post(
            'https://auth.example.com/api/login',
            json={'username': username, 'password': password},
        )

        if response.status_code == 200:
            return response.json()

        return None

    def create_user(self, user_info: dict) -> User:
        """创建用户"""
        from superset.models.core import User

        user = User(
            username=user_info['username'],
            email=user_info['email'],
            first_name=user_info.get('first_name', ''),
            last_name=user_info.get('last_name', ''),
            active=True,
        )

        # 设置默认角色
        role = self.find_role('Gamma')
        if role:
            user.roles.append(role)

        db.session.add(user)
        db.session.commit()

        return user
```

### 4.2 OAuth 认证

```python
from flask_appbuilder.security.sqla.manager import SecurityManager
from authlib.integrations.flask_client import OAuth

class OAuthSecurityManager(SecurityManager):
    """OAuth 安全管理器"""

    def __init__(self, appbuilder):
        super().__init__(appbuilder)
        self.oauth = OAuth(appbuilder.get_app)
        self._init_oauth()

    def _init_oauth(self):
        """初始化 OAuth"""
        oauth_config = self.appbuilder.get_app.config.get('OAUTH_PROVIDERS', {})

        for provider, config in oauth_config.items():
            self.oauth.register(
                provider,
                client_id=config['client_id'],
                client_secret=config['client_secret'],
                server_metadata_url=config.get('server_metadata_url'),
                client_kwargs={'scope': 'openid profile email'},
            )

    def oauth_login(self, provider: str):
        """OAuth 登录"""
        client = self.oauth.create_client(provider)
        redirect_uri = self.appbuilder.get_app.config.get(
            'OAUTH_REDIRECT_URI',
            f'http://localhost:8088/oauth-authorized/{provider}'
        )

        return client.authorize_redirect(redirect_uri)

    def oauth_callback(self, provider: str):
        """OAuth 回调"""
        client = self.oauth.create_client(provider)
        token = client.authorize_access_token()

        # 获取用户信息
        user_info = client.parse_id_token(token)

        # 查找或创建用户
        user = self.find_user(username=user_info['email'])

        if not user:
            user = self.create_user({
                'username': user_info['email'],
                'email': user_info['email'],
                'first_name': user_info.get('given_name', ''),
                'last_name': user_info.get('family_name', ''),
            })

        # 登录用户
        login_user(user, remember=True)

        return user
```

### 4.3 LDAP 认证

```python
from flask_appbuilder.security.sqla.manager import SecurityManager
import ldap

class LDAPSecurityManager(SecurityManager):
    """LDAP 安全管理器"""

    def __init__(self, appbuilder):
        super().__init__(appbuilder)
        self.ldap_config = self.appbuilder.get_app.config.get('LDAP_CONFIG', {})

    def authenticate(self, username: str, password: str) -> Optional[User]:
        """LDAP 认证"""
        try:
            # 连接 LDAP 服务器
            conn = ldap.initialize(self.ldap_config['uri'])
            conn.simple_bind_s(
                self.ldap_config['bind_dn'],
                self.ldap_config['bind_password']
            )

            # 搜索用户
            search_filter = f"(uid={username})"
            result = conn.search_s(
                self.ldap_config['base_dn'],
                ldap.SCOPE_SUBTREE,
                search_filter
            )

            if not result:
                return None

            # 验证密码
            user_dn = result[0][0]
            conn.simple_bind_s(user_dn, password)

            # 获取用户信息
            user_info = self._parse_ldap_user(result[0][1])

            # 查找或创建用户
            user = self.find_user(username=username)

            if not user:
                user = self.create_user(user_info)

            return user

        except ldap.INVALID_CREDENTIALS:
            return None
        except Exception as e:
            logger.error(f"LDAP 认证失败: {e}")
            return None

    def _parse_ldap_user(self, ldap_user: dict) -> dict:
        """解析 LDAP 用户信息"""
        return {
            'username': ldap_user.get('uid', [b''])[0].decode(),
            'email': ldap_user.get('mail', [b''])[0].decode(),
            'first_name': ldap_user.get('givenName', [b''])[0].decode(),
            'last_name': ldap_user.get('sn', [b''])[0].decode(),
        }
```

## 5. 可视化插件系统

### 5.1 D3.js 可视化

```typescript
import React, { PureComponent } from 'react';
import * as d3 from 'd3';
import { ChartProps, ChartData } from '@superset-ui/core';

interface D3ChartProps extends ChartProps {
  data: ChartData;
  width: number;
  height: number;
}

class D3Chart extends PureComponent<D3ChartProps> {
  svgRef: React.RefObject<SVGSVGElement>;

  constructor(props: D3ChartProps) {
    super(props);
    this.svgRef = React.createRef();
  }

  componentDidMount() {
    this.renderChart();
  }

  componentDidUpdate() {
    this.renderChart();
  }

  renderChart() {
    if (!this.svgRef.current) return;

    const { data, width, height } = this.props;
    const { records } = data;

    // 清空 SVG
    d3.select(this.svgRef.current).selectAll('*').remove();

    // 创建比例尺
    const xScale = d3.scaleLinear()
      .domain([0, d3.max(records, (d: any) => d.x)])
      .range([0, width]);

    const yScale = d3.scaleLinear()
      .domain([0, d3.max(records, (d: any) => d.y)])
      .range([height, 0]);

    // 创建 SVG 元素
    const svg = d3.select(this.svgRef.current);

    // 绘制数据点
    svg.selectAll('circle')
      .data(records)
      .enter()
      .append('circle')
      .attr('cx', (d: any) => xScale(d.x))
      .attr('cy', (d: any) => yScale(d.y))
      .attr('r', (d: any) => d.r)
      .attr('fill', (d: any) => d.color);
  }

  render() {
    const { width, height } = this.props;

    return (
      <svg
        ref={this.svgRef}
        width={width}
        height={height}
      />
    );
  }
}

export default D3Chart;
```

### 5.2 Deck.GL 地图可视化

```typescript
import React, { PureComponent } from 'react';
import { Map } from 'react-map-gl';
import { ScatterplotLayer } from '@deck.gl/layers';
import { ChartProps, ChartData } from '@superset-ui/core';

interface DeckGLChartProps extends ChartProps {
  data: ChartData;
  width: number;
  height: number;
}

class DeckGLChart extends PureComponent<DeckGLChartProps> {
  render() {
    const { data, width, height } = this.props;
    const { records } = data;

    const layers = [
      new ScatterplotLayer({
        id: 'scatterplot-layer',
        data: records,
        getPosition: (d: any) => [d.longitude, d.latitude],
        getRadius: (d: any) => d.radius,
        getFillColor: (d: any) => d.color,
      }),
    ];

    return (
      <Map
        mapboxAccessToken={process.env.MAPBOX_TOKEN}
        initialViewState={{
          longitude: -122.4,
          latitude: 37.8,
          zoom: 12,
        }}
        style={{ width, height }}
      >
        <DeckGL
          layers={layers}
          width={width}
          height={height}
        />
      </Map>
    );
  }
}

export default DeckGLChart;
```

## 6. 扩展插件系统

### 6.1 自定义命令

```python
from superset.commands.base import BaseCommand
from typing import Any

class MyCustomCommand(BaseCommand):
    """自定义命令"""

    def __init__(self, data: dict[str, Any]):
        self._data = data

    def run(self) -> Any:
        """执行自定义逻辑"""
        # 实现自定义业务逻辑
        result = self._process_data(self._data)
        return result

    def validate(self) -> None:
        """验证输入"""
        if not self._data.get('required_field'):
            raise ValueError('required_field 不能为空')

    def _process_data(self, data: dict[str, Any]) -> Any:
        """处理数据"""
        # 实现数据处理逻辑
        return {'status': 'success', 'data': data}
```

### 6.2 自定义 API

```python
from flask_appbuilder.api import expose, protect, safe
from superset.views.base_api import BaseSupersetApi
from superset.commands.my_custom import MyCustomCommand

class MyCustomRestApi(BaseSupersetApi):
    """自定义 REST API"""
    method_permission_name = MODEL_API_RW_METHOD_PERMISSION_MAP
    allow_browser_login = True
    class_permission_name = "MyCustom"
    resource_name = "my_custom"
    openapi_spec_tag = "My Custom"

    @expose("/process", methods=("POST",))
    @protect()
    @safe
    def process(self) -> Response:
        """处理自定义请求"""
        try:
            data = self._get_post_args()
            command = MyCustomCommand(data)
            result = command.run()
            return self.response(200, **result)
        except Exception as ex:
            return self.response_422(ex)
```

### 6.3 自定义 UI 组件

```typescript
import React, { PureComponent } from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { Button, Modal, Form, Input } from 'antd';

interface MyCustomComponentProps {
  visible: boolean;
  onClose: () => void;
  onSubmit: (data: any) => void;
}

class MyCustomComponent extends PureComponent<MyCustomComponentProps> {
  handleSubmit = (values: any) => {
    this.props.onSubmit(values);
    this.props.onClose();
  };

  render() {
    const { visible, onClose } = this.props;

    return (
      <Modal
        title="自定义组件"
        visible={visible}
        onCancel={onClose}
        footer={null}
      >
        <Form onFinish={this.handleSubmit}>
          <Form.Item
            name="name"
            label="名称"
            rules={[{ required: true, message: '请输入名称' }]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="description"
            label="描述"
          >
            <Input.TextArea />
          </Form.Item>
          <Form.Item>
            <Button type="primary" htmlType="submit">
              提交
            </Button>
          </Form.Item>
        </Form>
      </Modal>
    );
  }
}

export default MyCustomComponent;
```

## 7. 插件最佳实践

### 7.1 图表插件最佳实践

1. **性能优化**
   - 使用虚拟滚动处理大数据集
   - 实现数据分页和懒加载
   - 使用 Web Workers 处理复杂计算

2. **响应式设计**
   - 支持不同屏幕尺寸
   - 实现自适应布局
   - 处理窗口大小变化

3. **错误处理**
   - 提供友好的错误提示
   - 实现降级方案
   - 记录错误日志

4. **可访问性**
   - 支持键盘导航
   - 提供屏幕阅读器支持
   - 遵循 WCAG 标准

### 7.2 数据源插件最佳实践

1. **连接池管理**
   - 合理配置连接池大小
   - 实现连接超时和重试
   - 监控连接状态

2. **查询优化**
   - 生成高效的 SQL
   - 实现查询缓存
   - 支持分页查询

3. **错误处理**
   - 捕获和处理数据库错误
   - 提供有意义的错误信息
   - 实现错误恢复机制

### 7.3 认证插件最佳实践

1. **安全性**
   - 使用 HTTPS
   - 实现密码加密
   - 防止暴力破解

2. **用户体验**
   - 提供清晰的错误提示
   - 实现记住登录状态
   - 支持密码重置

3. **集成性**
   - 支持多种认证方式
   - 实现单点登录（SSO）
   - 支持多因素认证

## 8. 下一步

阅读完本文档后，建议继续学习：

1. [自定义图表](./12-自定义图表.md) - 学习如何创建自定义图表
2. [自定义数据源](./13-自定义数据源.md) - 学习如何添加自定义数据源
3. [部署配置](./15-部署配置.md) - 学习部署和配置
