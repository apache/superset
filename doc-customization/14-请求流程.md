# Apache Superset 请求流程

## 1. 请求处理架构

### 1.1 整体流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    Client Request                      │
└────────────────────────┬────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                  Nginx (Optional)                    │
│              Reverse Proxy / Load Balancer             │
└────────────────────────┬────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                  Flask Application                    │
│  ┌──────────────────────────────────────────────────┐  │
│  │  1. Request Routing (Flask Router)        │  │
│  └────────────────┬─────────────────────────────┘  │
│                   │                                 │
│  ┌────────────────▼─────────────────────────────┐  │
│  │  2. Authentication & Authorization        │  │
│  │     (Flask-AppBuilder Security)          │  │
│  └────────────────┬─────────────────────────────┘  │
│                   │                                 │
│  ┌────────────────▼─────────────────────────────┐  │
│  │  3. Request Validation (Marshmallow)      │  │
│  └────────────────┬─────────────────────────────┘  │
│                   │                                 │
│  ┌────────────────▼─────────────────────────────┐  │
│  │  4. Command Execution (Command Pattern)  │  │
│  │     - Create/Update/Delete Operations     │  │
│  │     - Business Logic                  │  │
│  └────────────────┬─────────────────────────────┘  │
│                   │                                 │
│  ┌────────────────▼─────────────────────────────┐  │
│  │  5. Data Access (DAO/ORM)              │  │
│  │     - SQLAlchemy ORM                    │  │
│  │     - Database Queries                 │  │
│  └────────────────┬─────────────────────────────┘  │
│                   │                                 │
│  ┌────────────────▼─────────────────────────────┐  │
│  │  6. Response Serialization (Marshmallow)  │  │
│  └────────────────┬─────────────────────────────┘  │
│                   │                                 │
│  ┌────────────────▼─────────────────────────────┐  │
│  │  7. Caching (Optional)                  │  │
│  │     - Redis Cache                      │  │
│  └────────────────┬─────────────────────────────┘  │
│                   │                                 │
└───────────────────┼─────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│                  JSON Response                        │
└─────────────────────────────────────────────────────────────┘
```

## 2. 图表数据查询流程

### 2.1 前端发起查询

```typescript
// 前端发起图表数据查询
import { getChartData } from 'src/utils/api';
import { fetchChartData } from 'src/explore/actions/exploreActions';

const ChartComponent = ({ chartId, formData }) => {
  useEffect(() => {
    // 发起查询
    fetchChartData({
      chartId,
      formData,
    });
  }, [chartId, formData]);

  return <div>{/* 渲染图表 */}</div>;
};

// Redux Action
export function fetchChartData({ chartId, formData }) {
  return async (dispatch) => {
    dispatch(setChartStatus('loading'));

    try {
      const response = await getChartData({
        datasource: formData.datasource,
        queries: formData.queries,
        result_format: 'json',
        result_type: 'full',
      });

      dispatch(setChartData(response.data));
      dispatch(setChartStatus('success'));
    } catch (error) {
      dispatch(setChartError(error.message));
      dispatch(setChartStatus('error'));
    }
  };
}
```

### 2.2 后端处理查询

```python
# 后端 API 端点
from flask_appbuilder.api import expose, protect, safe
from superset.commands.explore.get import GetExploreCommand
from superset.explore.schemas import ExploreContextSchema

class ExploreRestApi(BaseSupersetApi):
    @expose("/data", methods=("POST",))
    @protect()
    @safe
    def data(self) -> Response:
        """获取图表数据"""
        try:
            # 解析请求参数
            form_data = self._get_form_data()

            # 执行命令
            command = GetExploreCommand(form_data)
            result = command.run()

            # 返回响应
            return self.response(200, **result)
        except Exception as ex:
            return self.response_422(ex)
```

### 2.3 命令执行

```python
# 命令执行
from superset.commands.base import BaseCommand
from superset.common.query_context_factory import QueryContextFactory

class GetExploreCommand(BaseCommand):
    def __init__(self, form_data: dict[str, Any]):
        self._form_data = form_data

    def run(self) -> dict[str, Any]:
        """执行查询"""
        # 获取数据源
        datasource = self._get_datasource()

        # 构建查询对象
        queries = self._build_queries()

        # 创建查询上下文
        query_context = QueryContextFactory.create(
            datasource=datasource,
            queries=queries,
            form_data=self._form_data,
            result_type='full',
            result_format='json',
        )

        # 获取查询结果
        payload = query_context.get_payload()

        return payload

    def _get_datasource(self) -> Explorable:
        """获取数据源"""
        datasource_id = self._form_data.get('datasource_id')
        datasource_type = self._form_data.get('datasource_type')

        if datasource_type == 'table':
            from superset.models.core import SqlaTable
            return db.session.query(SqlaTable).get(datasource_id)
        elif datasource_type == 'query':
            # 处理查询数据源
            pass

    def _build_queries(self) -> list[QueryObject]:
        """构建查询对象"""
        from superset.common.query_object import QueryObject

        query = QueryObject(
            metrics=self._form_data.get('metrics', []),
            groupby=self._form_data.get('groupby', []),
            columns=self._form_data.get('columns', []),
            granularity=self._form_data.get('granularity'),
            from_dttm=self._form_data.get('from_dttm'),
            to_dttm=self._form_data.get('to_dttm'),
            filters=self._form_data.get('filters', []),
            orderby=self._form_data.get('orderby', []),
            row_limit=self._form_data.get('row_limit'),
        )

        return [query]
```

### 2.4 查询上下文处理

```python
# 查询上下文处理
from superset.common.query_context_processor import QueryContextProcessor

class QueryContextProcessor:
    def __init__(self, query_context: QueryContext):
        self.query_context = query_context

    def get_payload(
        self,
        cache_query_context: bool | None = False,
        force_cached: bool = False,
    ) -> dict[str, Any]:
        """获取查询结果"""
        # 检查缓存
        if not force_cached:
            cached_result = self._get_cached_result()
            if cached_result:
                return cached_result

        # 执行查询
        result = self._execute_query()

        # 缓存结果
        if cache_query_context:
            self._cache_result(result)

        return result

    def _get_cached_result(self) -> dict[str, Any] | None:
        """获取缓存结果"""
        from superset.extensions import cache_manager

        cache_key = self._get_cache_key()
        return cache_manager.get(cache_key)

    def _execute_query(self) -> dict[str, Any]:
        """执行查询"""
        # 生成 SQL
        sql = self._generate_sql()

        # 执行 SQL
        df = self._execute_sql(sql)

        # 处理结果
        result = self._process_result(df)

        return result

    def _generate_sql(self) -> str:
        """生成 SQL"""
        from superset.db_engine_specs.base import BaseEngineSpec

        engine_spec = self.query_context.datasource.get_engine_spec()
        sql = engine_spec.get_sql(
            self.query_context.queries,
            self.query_context.datasource,
        )

        return sql

    def _execute_sql(self, sql: str) -> pd.DataFrame:
        """执行 SQL"""
        from superset.models.core import Database

        database = self.query_context.datasource.database
        engine = database.get_sqla_engine()

        with engine.connect() as connection:
            df = pd.read_sql_query(sql, connection)

        return df

    def _process_result(self, df: pd.DataFrame) -> dict[str, Any]:
        """处理结果"""
        # 转换为前端需要的格式
        result = {
            'data': df.to_dict('records'),
            'coltypes': self._get_coltypes(df),
            'rowcount': len(df),
        }

        return result

    def _get_cache_key(self) -> str:
        """获取缓存键"""
        import hashlib
        import json

        cache_data = {
            'datasource_id': self.query_context.datasource.id,
            'queries': [q.to_dict() for q in self.query_context.queries],
        }

        cache_string = json.dumps(cache_data, sort_keys=True)
        cache_key = hashlib.md5(cache_string.encode()).hexdigest()

        return f"chart_data:{cache_key}"

    def _cache_result(self, result: dict[str, Any]) -> None:
        """缓存结果"""
        from superset.extensions import cache_manager

        cache_key = self._get_cache_key()
        cache_timeout = self.query_context.custom_cache_timeout or 3600

        cache_manager.set(cache_key, result, timeout=cache_timeout)
```

## 3. 仪表板加载流程

### 3.1 前端加载仪表板

```typescript
// 前端加载仪表板
import { getDashboard } from 'src/utils/api';
import { fetchDashboard } from 'src/dashboard/actions/dashboardActions';

const DashboardComponent = ({ dashboardId }) => {
  useEffect(() => {
    // 加载仪表板元数据
    fetchDashboard(dashboardId);
  }, [dashboardId]);

  const { dashboardInfo, charts, layout } = useSelector(state => state.dashboard);

  if (!dashboardInfo) {
    return <Loading />;
  }

  return (
    <DashboardBuilder
      dashboardInfo={dashboardInfo}
      charts={charts}
      layout={layout}
    />
  );
};

// Redux Action
export function fetchDashboard(dashboardId: number) {
  return async (dispatch) => {
    dispatch(setDashboardStatus('loading'));

    try {
      const response = await getDashboard(dashboardId);
      const { dashboard, charts, layout } = response.data;

      dispatch(setDashboardInfo(dashboard));
      dispatch(setCharts(charts));
      dispatch(setLayout(layout));
      dispatch(setDashboardStatus('success'));

      // 并行加载图表数据
      charts.forEach(chart => {
        dispatch(fetchChartData({
          chartId: chart.id,
          formData: chart.formData,
        }));
      });
    } catch (error) {
      dispatch(setDashboardError(error.message));
      dispatch(setDashboardStatus('error'));
    }
  };
}
```

### 3.2 后端处理仪表板请求

```python
# 后端 API 端点
from flask_appbuilder.api import expose, protect, safe
from superset.commands.dashboard.get import GetDashboardCommand
from superset.dashboards.schemas import DashboardGetResponseSchema

class DashboardRestApi(BaseSupersetModelRestApi):
    @expose("/<pk>", methods=("GET",))
    @protect()
    @safe
    def get(self, pk: int) -> Response:
        """获取仪表板"""
        try:
            # 执行命令
            command = GetDashboardCommand([pk])
            result = command.run()

            # 返回响应
            return self.response(200, **result)
        except Exception as ex:
            return self.response_422(ex)
```

### 3.3 命令执行

```python
# 命令执行
from superset.commands.base import BaseCommand
from superset.daos.dashboard import DashboardDAO

class GetDashboardCommand(BaseCommand):
    def __init__(self, dashboard_ids: list[int]):
        self._dashboard_ids = dashboard_ids

    def run(self) -> dict[str, Any]:
        """执行获取仪表板"""
        # 获取仪表板
        dashboard = DashboardDAO.get_dashboard_by_id(self._dashboard_ids[0])

        # 获取仪表板图表
        charts = self._get_dashboard_charts(dashboard)

        # 获取仪表板布局
        layout = self._get_dashboard_layout(dashboard)

        # 构建响应
        result = {
            'dashboard': self._serialize_dashboard(dashboard),
            'charts': [self._serialize_chart(chart) for chart in charts],
            'layout': layout,
        }

        return result

    def _get_dashboard_charts(self, dashboard: Dashboard) -> list[Slice]:
        """获取仪表板图表"""
        from superset.models.slice import Slice

        chart_ids = [chart.id for chart in dashboard.slices]
        return db.session.query(Slice).filter(
            Slice.id.in_(chart_ids)
        ).all()

    def _get_dashboard_layout(self, dashboard: Dashboard) -> dict[str, Any]:
        """获取仪表板布局"""
        import json

        if dashboard.position_json:
            return json.loads(dashboard.position_json)

        return {}

    def _serialize_dashboard(self, dashboard: Dashboard) -> dict[str, Any]:
        """序列化仪表板"""
        return {
            'id': dashboard.id,
            'dashboard_title': dashboard.dashboard_title,
            'description': dashboard.description,
            'json_metadata': dashboard.json_metadata,
            'css': dashboard.css,
        }

    def _serialize_chart(self, chart: Slice) -> dict[str, Any]:
        """序列化图表"""
        import json

        return {
            'id': chart.id,
            'slice_name': chart.slice_name,
            'viz_type': chart.viz_type,
            'params': json.loads(chart.params) if chart.params else {},
        }
```

## 4. 创建图表流程

### 4.1 前端创建图表

```typescript
// 前端创建图表
import { createChart } from 'src/utils/api';
import { saveChart } from 'src/explore/actions/exploreActions';

const ChartCreationComponent = ({ formData }) => {
  const handleSave = async () => {
    try {
      await saveChart({
        slice_name: formData.slice_name,
        viz_type: formData.viz_type,
        datasource_id: formData.datasource_id,
        datasource_type: formData.datasource_type,
        params: formData.query_context,
      });
    } catch (error) {
      console.error('创建图表失败:', error);
    }
  };

  return <Button onClick={handleSave}>保存图表</Button>;
};

// Redux Action
export function saveChart(chartData: Record<string, unknown>) {
  return async (dispatch) => {
    dispatch(setSaveStatus('saving'));

    try {
      const response = await createChart(chartData);
      dispatch(setChart(response.data));
      dispatch(setSaveStatus('success'));
    } catch (error) {
      dispatch(setSaveError(error.message));
      dispatch(setSaveStatus('error'));
    }
  };
}
```

### 4.2 后端处理创建图表

```python
# 后端 API 端点
from flask_appbuilder.api import expose, protect, safe
from superset.commands.chart.create import CreateChartCommand
from superset.charts.schemas import ChartPostSchema

class ChartRestApi(BaseSupersetModelRestApi):
    @expose("/", methods=("POST",))
    @protect()
    @safe
    @statsd_metrics
    def post(self) -> Response:
        """创建图表"""
        try:
            # 解析请求参数
            data = self._get_post_args()

            # 执行命令
            command = CreateChartCommand(data)
            chart = command.run()

            # 返回响应
            return self.response(201, **self._get_item_schema(chart))
        except Exception as ex:
            return self.response_422(ex)
```

### 4.3 命令执行

```python
# 命令执行
from superset.commands.base import BaseCommand
from superset.models.slice import Slice
from superset.daos.chart import ChartDAO

class CreateChartCommand(BaseCommand):
    def __init__(self, data: dict[str, Any]):
        self._properties = data.copy()

    def run(self) -> Slice:
        """执行创建图表"""
        # 获取数据源
        datasource = self._get_datasource()

        # 创建图表
        chart = Slice(
            slice_name=self._properties["slice_name"],
            viz_type=self._properties["viz_type"],
            datasource_type=datasource.type,
            datasource_id=datasource.id,
            params=json.dumps(self._properties.get("params", {})),
            description=self._properties.get("description"),
        )

        # 设置所有者
        chart.owners = self._get_owners()

        # 保存到数据库
        db.session.add(chart)
        db.session.commit()

        return chart

    def validate(self) -> None:
        """验证输入"""
        if not self._properties.get("slice_name"):
            raise ChartInvalidError("图表名称不能为空")

        if not self._properties.get("viz_type"):
            raise ChartInvalidError("图表类型不能为空")

        if not self._properties.get("datasource_id"):
            raise ChartInvalidError("数据源 ID 不能为空")

    def _get_datasource(self) -> Any:
        """获取数据源"""
        datasource_id = self._properties.get("datasource_id")
        datasource_type = self._properties.get("datasource_type")

        if datasource_type == "table":
            from superset.models.core import SqlaTable
            return db.session.query(SqlaTable).get(datasource_id)
        elif datasource_type == "query":
            # 处理查询数据源
            pass

    def _get_owners(self) -> list[User]:
        """获取所有者"""
        from flask_login import current_user
        return [current_user]
```

## 5. SQL Lab 查询流程

### 5.1 前端执行 SQL

```typescript
// 前端执行 SQL
import { executeQuery } from 'src/utils/api';
import { runQuery } from 'src/SqlLab/actions/sqlLabActions';

const SqlEditorComponent = ({ sql, databaseId }) => {
  const handleRun = async () => {
    try {
      await runQuery({
        sql,
        database_id: databaseId,
        schema: 'public',
        limit: 1000,
      });
    } catch (error) {
      console.error('执行 SQL 失败:', error);
    }
  };

  return <Button onClick={handleRun}>运行</Button>;
};

// Redux Action
export function runQuery(queryData: Record<string, unknown>) {
  return async (dispatch) => {
    dispatch(setQueryStatus('running'));

    try {
      const response = await executeQuery(queryData);
      dispatch(setQueryResult(response.data));
      dispatch(setQueryStatus('success'));
    } catch (error) {
      dispatch(setQueryError(error.message));
      dispatch(setQueryStatus('error'));
    }
  };
}
```

### 5.2 后端处理 SQL 查询

```python
# 后端 API 端点
from flask_appbuilder.api import expose, protect, safe
from superset.commands.sql_lab.execute import ExecuteQueryCommand
from superset.sqllab.schemas import SqlLabQuerySchema

class SqlLabRestApi(BaseSupersetApi):
    @expose("/sql_json", methods=("POST",))
    @protect()
    @safe
    @statsd_metrics
    def sql_json(self) -> Response:
        """执行 SQL 查询"""
        try:
            # 解析请求参数
            data = self._get_post_args()

            # 执行命令
            command = ExecuteQueryCommand(data)
            result = command.run()

            # 返回响应
            return self.response(200, **result)
        except Exception as ex:
            return self.response_422(ex)
```

### 5.3 命令执行

```python
# 命令执行
from superset.commands.base import BaseCommand
from superset.models.sql_lab import Query
from superset.models.core import Database

class ExecuteQueryCommand(BaseCommand):
    def __init__(self, data: dict[str, Any]):
        self._properties = data.copy()

    def run(self) -> dict[str, Any]:
        """执行 SQL 查询"""
        # 获取数据库
        database = self._get_database()

        # 执行 SQL
        df = self._execute_sql(database)

        # 保存查询记录
        query = self._save_query(database, df)

        # 构建响应
        result = {
            'data': df.to_dict('records'),
            'columns': list(df.columns),
            'rowcount': len(df),
            'query_id': query.id,
        }

        return result

    def _get_database(self) -> Database:
        """获取数据库"""
        database_id = self._properties.get("database_id")
        return db.session.query(Database).get(database_id)

    def _execute_sql(self, database: Database) -> pd.DataFrame:
        """执行 SQL"""
        sql = self._properties.get("sql")
        limit = self._properties.get("limit", 1000)

        # 添加 LIMIT
        if limit:
            sql = f"SELECT * FROM ({sql}) AS subquery LIMIT {limit}"

        # 执行 SQL
        engine = database.get_sqla_engine()
        with engine.connect() as connection:
            df = pd.read_sql_query(sql, connection)

        return df

    def _save_query(self, database: Database, df: pd.DataFrame) -> Query:
        """保存查询记录"""
        from flask_login import current_user

        query = Query(
            database_id=database.id,
            sql=self._properties.get("sql"),
            schema=self._properties.get("schema"),
            status="success",
            rows=len(df),
            user_id=current_user.id,
        )

        db.session.add(query)
        db.session.commit()

        return query
```

## 6. 认证和授权流程

### 6.1 登录流程

```python
# 登录流程
from flask_appbuilder.security.sqla.manager import SecurityManager
from flask_login import login_user

class SupersetSecurityManager(SecurityManager):
    def login(self, username: str, password: str) -> User:
        """用户登录"""
        # 查找用户
        user = self.find_user(username=username)

        if not user:
            raise AuthenticationFailed("用户不存在")

        # 验证密码
        if not self.verify_password(password, user.password):
            raise AuthenticationFailed("密码错误")

        # 登录用户
        login_user(user, remember=True)

        return user
```

### 6.2 权限检查

```python
# 权限检查
from flask_appbuilder.api import protect
from superset.security import SupersetSecurityManager

class ChartRestApi(BaseSupersetModelRestApi):
    @expose("/<pk>", methods=("GET",))
    @protect()  # 检查用户是否登录
    @safe
    def get(self, pk: int) -> Response:
        """获取图表"""
        # 检查用户是否有权限访问该图表
        chart = ChartDAO.get_chart_by_id(pk)

        if not chart:
            raise ChartNotFoundError(f"图表 {pk} 不存在")

        # 检查访问权限
        if not self._can_access_chart(chart):
            raise ChartForbiddenError("无权访问该图表")

        return super().get(pk)

    def _can_access_chart(self, chart: Slice) -> bool:
        """检查是否有权访问图表"""
        from flask_login import current_user

        # 管理员可以访问所有图表
        if current_user.is_admin():
            return True

        # 检查用户是否是图表的所有者
        if current_user in chart.owners:
            return True

        # 检查用户是否有图表的读取权限
        from superset.security import SupersetSecurityManager
        security_manager = current_app.appbuilder.sm

        return security_manager.has_access(
            "can_read",
            "Chart",
            current_user,
        )
```

## 7. 错误处理流程

### 7.1 异常处理

```python
# 异常处理
from flask_appbuilder.api import safe
from werkzeug.exceptions import HTTPException

class ChartRestApi(BaseSupersetModelRestApi):
    @expose("/", methods=("POST",))
    @protect()
    @safe  # 自动捕获异常并返回错误响应
    @statsd_metrics
    def post(self) -> Response:
        """创建图表"""
        try:
            data = self._get_post_args()
            command = CreateChartCommand(data)
            chart = command.run()
            return self.response(201, **self._get_item_schema(chart))
        except ChartInvalidError as ex:
            # 自定义异常
            return self.response_400(ex.message)
        except ChartNotFoundError as ex:
            return self.response_404(ex.message)
        except ChartForbiddenError as ex:
            return self.response_403(ex.message)
        except Exception as ex:
            # 未知异常
            logger.exception("创建图表失败")
            return self.response_500("服务器内部错误")
```

## 8. 下一步

阅读完本文档后，建议继续学习：

1. [部署配置](./15-部署配置.md) - 学习部署和配置
2. [缓存机制](./16-缓存机制.md) - 学习缓存策略
3. [调试指南](./17-调试指南.md) - 学习调试方法
