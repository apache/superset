# Apache Superset 缓存机制

## 1. 缓存概述

### 1.1 缓存类型

Apache Superset 使用多种缓存策略：

| 缓存类型 | 用途 | 存储位置 | 过期时间 |
|---------|------|---------|---------|
| **查询结果缓存** | 缓存查询结果 | Redis | 可配置 |
| **元数据缓存** | 缓存数据库元数据 | Redis | 1 小时 |
| **图表数据缓存** | 缓存图表数据 | Redis | 可配置 |
| **前端缓存** | 缓存静态资源 | 浏览器 | 1 年 |
| **API 响应缓存** | 缓存 API 响应 | Redis | 可配置 |

### 1.2 缓存架构

```
缓存架构
├── 应用层缓存
│   ├── Flask-Caching
│   ├── 函数缓存
│   └── 视图缓存
├── 数据层缓存
│   ├── 查询结果缓存
│   ├── 元数据缓存
│   └── 图表数据缓存
├── 前端缓存
│   ├── 静态资源缓存
│   ├── API 响应缓存
│   └── 组件缓存
└── 分布式缓存
    ├── Redis 集群
    ├── 缓存分片
    └── 缓存复制
```

## 2. Flask-Caching

### 2.1 配置 Flask-Caching

```python
# config.py
from flask_caching import Cache

# 缓存配置
CACHE_CONFIG = {
    'CACHE_TYPE': 'redis',
    'CACHE_REDIS_URL': 'redis://localhost:6379/0',
    'CACHE_DEFAULT_TIMEOUT': 3600,
    'CACHE_KEY_PREFIX': 'superset_',
    'CACHE_REDIS_DB': 0,
    'CACHE_REDIS_HOST': 'localhost',
    'CACHE_REDIS_PORT': 6379,
    'CACHE_REDIS_PASSWORD': None,
    'CACHE_OPTIONS': {
        'max_connections': 50,
    },
}

# 创建缓存实例
cache = Cache()
```

### 2.2 函数缓存

```python
from flask import current_app
from flask_caching import cache

@cache.memoize(timeout=3600)
def get_chart_data(chart_id: int, form_data: dict) -> dict:
    """获取图表数据（带缓存）"""
    # 执行查询
    result = execute_query(chart_id, form_data)
    return result

@cache.memoize(timeout=1800)
def get_dashboard_metadata(dashboard_id: int) -> dict:
    """获取仪表板元数据（带缓存）"""
    dashboard = Dashboard.query.get(dashboard_id)
    return dashboard.to_dict()

@cache.memoize(timeout=7200)
def get_database_tables(database_id: int) -> list:
    """获取数据库表列表（带缓存）"""
    database = Database.query.get(database_id)
    return database.get_table_names()
```

### 2.3 视图缓存

```python
from flask_appbuilder.api import expose, protect, safe
from flask_caching import cache

class ChartRestApi(BaseSupersetModelRestApi):
    @expose("/<pk>", methods=("GET",))
    @protect()
    @safe
    @cache.cached(timeout=300, key_prefix='chart_view')
    def get(self, pk: int) -> Response:
        """获取图表（带缓存）"""
        chart = ChartDAO.get_chart_by_id(pk)
        return self.response(200, **self._get_item_schema(chart))

    @expose("/<pk>/data", methods=("GET",))
    @protect()
    @safe
    @cache.memoize(timeout=600)
    def get_data(self, pk: int) -> Response:
        """获取图表数据（带缓存）"""
        chart = ChartDAO.get_chart_by_id(pk)
        data = chart.get_data()
        return self.response(200, data=data)
```

## 3. 查询结果缓存

### 3.1 查询缓存管理器

```python
from typing import Any, Optional
import hashlib
import json
import pandas as pd
from superset.extensions import cache_manager

class QueryCacheManager:
    """查询缓存管理器"""

    def __init__(self):
        self.cache = cache_manager

    def get_cache_key(self, query: str, datasource_id: int) -> str:
        """获取缓存键"""
        cache_data = {
            'datasource_id': datasource_id,
            'query': query,
        }

        cache_string = json.dumps(cache_data, sort_keys=True)
        cache_key = hashlib.md5(cache_string.encode()).hexdigest()

        return f"query:{datasource_id}:{cache_key}"

    def get_cached_result(self, query: str, datasource_id: int) -> Optional[pd.DataFrame]:
        """获取缓存结果"""
        cache_key = self.get_cache_key(query, datasource_id)
        result = self.cache.get(cache_key)

        if result:
            return pd.DataFrame(result)

        return None

    def cache_result(self, query: str, datasource_id: int, df: pd.DataFrame, timeout: int = 3600) -> None:
        """缓存结果"""
        cache_key = self.get_cache_key(query, datasource_id)
        self.cache.set(cache_key, df.to_dict('records'), timeout=timeout)

    def invalidate_cache(self, query: str, datasource_id: int) -> None:
        """使缓存失效"""
        cache_key = self.get_cache_key(query, datasource_id)
        self.cache.delete(cache_key)

    def clear_all_cache(self) -> None:
        """清空所有缓存"""
        self.cache.clear()

    def get_cache_stats(self) -> dict[str, Any]:
        """获取缓存统计"""
        return {
            'total_keys': len(self.cache._client.keys('query:*')),
            'memory_usage': self.cache._client.info()['used_memory_human'],
        }
```

### 3.2 使用查询缓存

```python
from superset.common.query_context import QueryContext
from superset.common.query_cache_manager import QueryCacheManager

class QueryContextProcessor:
    def __init__(self, query_context: QueryContext):
        self.query_context = query_context
        self.cache_manager = QueryCacheManager()

    def get_payload(self, cache_query_context: bool = False, force_cached: bool = False) -> dict[str, Any]:
        """获取查询结果"""
        # 检查缓存
        if not force_cached:
            cached_result = self._get_cached_result()
            if cached_result:
                return cached_result

        # 执行查询
        result = self._execute_query()

        # 缓存结果
        if cache_query_context:
            self._cache_result(result)

        return result

    def _get_cached_result(self) -> dict[str, Any] | None:
        """获取缓存结果"""
        query = self._generate_sql()
        datasource_id = self.query_context.datasource.id

        df = self.cache_manager.get_cached_result(query, datasource_id)

        if df is not None:
            return {
                'data': df.to_dict('records'),
                'coltypes': self._get_coltypes(df),
                'rowcount': len(df),
            }

        return None

    def _cache_result(self, result: dict[str, Any]) -> None:
        """缓存结果"""
        query = self._generate_sql()
        datasource_id = self.query_context.datasource.id
        timeout = self.query_context.custom_cache_timeout or 3600

        df = pd.DataFrame(result['data'])
        self.cache_manager.cache_result(query, datasource_id, df, timeout)
```

## 4. 元数据缓存

### 4.1 元数据缓存管理器

```python
from typing import Any, Optional, List
import hashlib
import json
from superset.extensions import cache_manager

class MetadataCacheManager:
    """元数据缓存管理器"""

    def __init__(self):
        self.cache = cache_manager

    def get_cache_key(self, database_id: int, table_name: str) -> str:
        """获取缓存键"""
        cache_data = {
            'database_id': database_id,
            'table_name': table_name,
        }

        cache_string = json.dumps(cache_data, sort_keys=True)
        cache_key = hashlib.md5(cache_string.encode()).hexdigest()

        return f"metadata:{database_id}:{cache_key}"

    def get_cached_columns(self, database_id: int, table_name: str) -> Optional[List[dict]]:
        """获取缓存的列信息"""
        cache_key = self.get_cache_key(database_id, table_name)
        return self.cache.get(cache_key)

    def cache_columns(self, database_id: int, table_name: str, columns: List[dict], timeout: int = 3600) -> None:
        """缓存列信息"""
        cache_key = self.get_cache_key(database_id, table_name)
        self.cache.set(cache_key, columns, timeout=timeout)

    def invalidate_cache(self, database_id: int, table_name: str) -> None:
        """使缓存失效"""
        cache_key = self.get_cache_key(database_id, table_name)
        self.cache.delete(cache_key)

    def clear_all_cache(self) -> None:
        """清空所有缓存"""
        self.cache.clear()
```

### 4.2 使用元数据缓存

```python
from superset.common.metadata_cache_manager import MetadataCacheManager

class DatabaseService:
    def __init__(self):
        self.cache_manager = MetadataCacheManager()

    def get_columns(self, database_id: int, table_name: str) -> List[dict]:
        """获取表的列信息"""
        # 检查缓存
        cached_columns = self.cache_manager.get_cached_columns(database_id, table_name)
        if cached_columns:
            return cached_columns

        # 从数据库获取
        database = Database.query.get(database_id)
        columns = database.get_columns(table_name)

        # 缓存结果
        self.cache_manager.cache_columns(database_id, table_name, columns)

        return columns

    def invalidate_table_cache(self, database_id: int, table_name: str) -> None:
        """使表的缓存失效"""
        self.cache_manager.invalidate_cache(database_id, table_name)
```

## 5. 图表数据缓存

### 5.1 图表数据缓存管理器

```python
from typing import Any, Optional
import hashlib
import json
from superset.extensions import cache_manager

class ChartDataCacheManager:
    """图表数据缓存管理器"""

    def __init__(self):
        self.cache = cache_manager

    def get_cache_key(self, chart_id: int, form_data: dict) -> str:
        """获取缓存键"""
        cache_data = {
            'chart_id': chart_id,
            'form_data': form_data,
        }

        cache_string = json.dumps(cache_data, sort_keys=True)
        cache_key = hashlib.md5(cache_string.encode()).hexdigest()

        return f"chart_data:{chart_id}:{cache_key}"

    def get_cached_data(self, chart_id: int, form_data: dict) -> Optional[dict]:
        """获取缓存的图表数据"""
        cache_key = self.get_cache_key(chart_id, form_data)
        return self.cache.get(cache_key)

    def cache_data(self, chart_id: int, form_data: dict, data: dict, timeout: int = 3600) -> None:
        """缓存图表数据"""
        cache_key = self.get_cache_key(chart_id, form_data)
        self.cache.set(cache_key, data, timeout=timeout)

    def invalidate_cache(self, chart_id: int, form_data: dict) -> None:
        """使缓存失效"""
        cache_key = self.get_cache_key(chart_id, form_data)
        self.cache.delete(cache_key)

    def invalidate_chart_cache(self, chart_id: int) -> None:
        """使图表的所有缓存失效"""
        pattern = f"chart_data:{chart_id}:*"
        keys = self.cache._client.keys(pattern)
        if keys:
            self.cache._client.delete(*keys)

    def clear_all_cache(self) -> None:
        """清空所有缓存"""
        self.cache.clear()
```

### 5.2 使用图表数据缓存

```python
from superset.common.chart_data_cache_manager import ChartDataCacheManager

class ChartService:
    def __init__(self):
        self.cache_manager = ChartDataCacheManager()

    def get_chart_data(self, chart_id: int, form_data: dict, force_refresh: bool = False) -> dict:
        """获取图表数据"""
        # 检查缓存
        if not force_refresh:
            cached_data = self.cache_manager.get_cached_data(chart_id, form_data)
            if cached_data:
                return cached_data

        # 执行查询
        chart = Chart.query.get(chart_id)
        data = chart.get_data(form_data)

        # 缓存结果
        self.cache_manager.cache_data(chart_id, form_data, data)

        return data

    def invalidate_chart_cache(self, chart_id: int) -> None:
        """使图表的缓存失效"""
        self.cache_manager.invalidate_chart_cache(chart_id)

    def update_chart(self, chart_id: int, data: dict) -> None:
        """更新图表"""
        chart = Chart.query.get(chart_id)
        chart.update(data)

        # 使缓存失效
        self.invalidate_chart_cache(chart_id)
```

## 6. 前端缓存

### 6.1 静态资源缓存

```typescript
// nginx.conf
server {
    location /static/ {
        alias /app/superset/static/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    location /assets/ {
        alias /app/superset/static/assets/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

### 6.2 API 响应缓存

```typescript
// utils/apiCache.ts
class APICache {
    private cache: Map<string, { data: any; timestamp: number }> = new Map();
    private defaultTimeout: number = 60000; // 1 分钟

    get(key: string): any | null {
        const cached = this.cache.get(key);
        if (!cached) return null;

        const now = Date.now();
        if (now - cached.timestamp > this.defaultTimeout) {
            this.cache.delete(key);
            return null;
        }

        return cached.data;
    }

    set(key: string, data: any, timeout: number = this.defaultTimeout): void {
        this.cache.set(key, {
            data,
            timestamp: Date.now(),
        });

        // 自动过期
        setTimeout(() => {
            this.cache.delete(key);
        }, timeout);
    }

    delete(key: string): void {
        this.cache.delete(key);
    }

    clear(): void {
        this.cache.clear();
    }
}

export const apiCache = new APICache();

// 使用示例
export async function fetchWithCache(url: string): Promise<any> {
    const cached = apiCache.get(url);
    if (cached) {
        return cached;
    }

    const response = await fetch(url);
    const data = await response.json();

    apiCache.set(url, data);

    return data;
}
```

### 6.3 组件缓存

```typescript
import React, { PureComponent } from 'react';
import { memoize } from 'lodash';

interface ChartProps {
    chartId: number;
    formData: Record<string, unknown>;
}

class Chart extends PureComponent<ChartProps> {
    private memoizedData = memoize((chartId: number, formData: Record<string, unknown>) => {
        return this.fetchChartData(chartId, formData);
    });

    async fetchChartData(chartId: number, formData: Record<string, unknown>) {
        const response = await fetch(`/api/v1/chart/${chartId}/data`, {
            method: 'POST',
            body: JSON.stringify(formData),
        });

        return response.json();
    }

    render() {
        const { chartId, formData } = this.props;
        const data = this.memoizedData(chartId, formData);

        return <div>{/* 渲染图表 */}</div>;
    }
}

export default Chart;
```

## 7. 分布式缓存

### 7.1 Redis 集群配置

```python
# config.py
CACHE_CONFIG = {
    'CACHE_TYPE': 'redis',
    'CACHE_REDIS_URL': 'redis://localhost:6379/0',
    'CACHE_REDIS_CLUSTER': [
        {'host': 'redis1', 'port': 6379},
        {'host': 'redis2', 'port': 6379},
        {'host': 'redis3', 'port': 6379},
    ],
    'CACHE_DEFAULT_TIMEOUT': 3600,
    'CACHE_KEY_PREFIX': 'superset_',
}
```

### 7.2 缓存分片

```python
from typing import Any, Optional
import hashlib
import json
from superset.extensions import cache_manager

class ShardedCacheManager:
    """分片缓存管理器"""

    def __init__(self, shards: int = 4):
        self.shards = shards
        self.caches = [
            cache_manager.cache._client
            for _ in range(shards)
        ]

    def _get_shard(self, key: str) -> int:
        """获取分片索引"""
        hash_value = hashlib.md5(key.encode()).hexdigest()
        return int(hash_value, 16) % self.shards

    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        shard_index = self._get_shard(key)
        cache = self.caches[shard_index]
        return cache.get(key)

    def set(self, key: str, value: Any, timeout: int = 3600) -> None:
        """设置缓存"""
        shard_index = self._get_shard(key)
        cache = self.caches[shard_index]
        cache.set(key, value, ex=timeout)

    def delete(self, key: str) -> None:
        """删除缓存"""
        shard_index = self._get_shard(key)
        cache = self.caches[shard_index]
        cache.delete(key)

    def clear(self) -> None:
        """清空所有缓存"""
        for cache in self.caches:
            cache.flushdb()
```

### 7.3 缓存复制

```python
from typing import Any, Optional
import json
from superset.extensions import cache_manager

class ReplicatedCacheManager:
    """复制缓存管理器"""

    def __init__(self, primary: Any, replicas: list[Any]):
        self.primary = primary
        self.replicas = replicas

    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        return self.primary.get(key)

    def set(self, key: str, value: Any, timeout: int = 3600) -> None:
        """设置缓存"""
        # 写入主节点
        self.primary.set(key, value, ex=timeout)

        # 异步复制到从节点
        for replica in self.replicas:
            try:
                replica.set(key, value, ex=timeout)
            except Exception:
                pass

    def delete(self, key: str) -> None:
        """删除缓存"""
        self.primary.delete(key)

        # 异步删除从节点
        for replica in self.replicas:
            try:
                replica.delete(key)
            except Exception:
                pass

    def clear(self) -> None:
        """清空所有缓存"""
        self.primary.flushdb()

        for replica in self.replicas:
            try:
                replica.flushdb()
            except Exception:
                pass
```

## 8. 缓存最佳实践

### 8.1 缓存策略

1. **选择合适的缓存键**
   - 使用唯一标识符
   - 包含所有影响结果的参数
   - 避免过长的键名

2. **设置合理的过期时间**
   - 根据数据更新频率设置
   - 避免过期时间过长
   - 使用分层过期策略

3. **缓存预热**
   - 在应用启动时预加载热点数据
   - 使用后台任务更新缓存
   - 实现缓存自动刷新

### 8.2 缓存失效

1. **主动失效**
   - 在数据更新时使缓存失效
   - 使用事件驱动的失效机制
   - 实现批量失效

2. **被动失效**
   - 设置合理的过期时间
   - 使用 TTL 机制
   - 实现缓存自动清理

3. **失效策略**
   - 精确失效：删除特定键
   - 模糊失效：删除匹配模式的键
   - 全量失效：清空所有缓存

### 8.3 缓存监控

1. **监控指标**
   - 缓存命中率
   - 缓存大小
   - 缓存响应时间

2. **告警机制**
   - 缓存命中率过低
   - 缓存大小超限
   - 缓存响应时间过长

3. **性能优化**
   - 优化缓存键设计
   - 调整缓存过期时间
   - 优化缓存存储结构

## 9. 下一步

阅读完本文档后，建议继续学习：

1. [调试指南](./17-调试指南.md) - 学习调试方法
2. [性能优化](./18-性能优化.md) - 学习性能优化
3. [部署配置](./15-部署配置.md) - 学习部署和配置
