# Apache Superset 核心模块

## 1. 模块概述

### 1.1 核心模块架构

```
核心模块层次结构
├── 数据库引擎 (Database Engine Specs)
│   ├── BaseEngineSpec - 基础引擎规范
│   ├── PostgresEngineSpec - PostgreSQL 引擎
│   ├── MySQLEngineSpec - MySQL 引擎
│   ├── SQLiteEngineSpec - SQLite 引擎
│   └── ... 其他数据库引擎
├── 查询处理 (Query Processing)
│   ├── QueryContext - 查询上下文
│   ├── QueryObject - 查询对象
│   ├── QueryContextFactory - 查询上下文工厂
│   └── QueryContextProcessor - 查询上下文处理器
├── 数据访问 (Data Access)
│   ├── DAO - 数据访问对象
│   ├── DatabaseDAO - 数据库 DAO
│   ├── ChartDAO - 图表 DAO
│   └── DashboardDAO - 仪表板 DAO
├── 命令模式 (Command Pattern)
│   ├── BaseCommand - 基础命令
│   ├── CreateCommand - 创建命令
│   ├── UpdateCommand - 更新命令
│   └── DeleteCommand - 删除命令
└── 缓存管理 (Cache Management)
    ├── CacheManager - 缓存管理器
    ├── QueryCache - 查询缓存
    └── ChartDataCache - 图表数据缓存
```

## 2. 数据库引擎规范

### 2.1 基础引擎规范

[db_engine_specs/base.py](../superset/db_engine_specs/base.py) 定义了基础引擎规范：

```python
from sqlalchemy.engine.url import URL
from typing import Any, Optional, List, Type
from datetime import datetime

class BaseEngineSpec:
    """基础数据库引擎规范"""

    engine = None
    engine_name = None
    default_driver = None

    @classmethod
    def get_dbapi_uri(cls, connection_params: dict[str, Any]) -> str:
        """获取数据库连接 URI"""
        raise NotImplementedError

    @classmethod
    def get_sqla_column_type(cls, sqla_type: Any) -> Any:
        """获取 SQLAlchemy 列类型"""
        raise NotImplementedError

    @classmethod
    def convert_dttm(cls, dttm: datetime) -> str:
        """转换日期时间为数据库格式"""
        raise NotImplementedError

    @classmethod
    def epoch_to_dttm(cls) -> str:
        """获取 epoch 到日期时间的转换 SQL"""
        raise NotImplementedError

    @classmethod
    def epoch_ms_to_dttm(cls) -> str:
        """获取 epoch 毫秒到日期时间的转换 SQL"""
        raise NotImplementedError

    @classmethod
    def get_metrics(cls, metrics: list[Any]) -> list[Any]:
        """获取指标"""
        return metrics

    @classmethod
    def get_groupby(cls, groupby: list[Any]) -> list[Any]:
        """获取分组"""
        return groupby

    @classmethod
    def get_column_spec(cls, column: Any) -> dict[str, Any]:
        """获取列规范"""
        return {
            "type": column.type,
            "label": column.column_name,
            "is_dttm": column.is_temporal,
        }

    @classmethod
    def get_table_names(cls, database: Any, schema: Optional[str] = None) -> list[str]:
        """获取表名列表"""
        raise NotImplementedError

    @classmethod
    def get_columns(cls, database: Any, table_name: str, schema: Optional[str] = None) -> list[dict[str, Any]]:
        """获取表的列信息"""
        raise NotImplementedError

    @classmethod
    def get_sql(cls, query_object: Any, datasource: Any) -> str:
        """生成 SQL"""
        raise NotImplementedError

    @classmethod
    def execute_sql(cls, database: Any, sql: str) -> pd.DataFrame:
        """执行 SQL"""
        engine = database.get_sqla_engine()
        with engine.connect() as connection:
            df = pd.read_sql_query(sql, connection)
        return df

    @classmethod
    def get_engine_spec_by_uri(cls, uri: str) -> Type['BaseEngineSpec']:
        """根据 URI 获取引擎规范"""
        from superset.db_engine_specs import get_engine_spec_by_name

        engine_name = URL.create(uri).drivername
        return get_engine_spec_by_name(engine_name)
```

### 2.2 PostgreSQL 引擎规范

[db_engine_specs/postgres.py](../superset/db_engine_specs/postgres.py) 定义了 PostgreSQL 引擎规范：

```python
from superset.db_engine_specs.base import BaseEngineSpec
from sqlalchemy.dialects.postgresql import (
    INTEGER, BIGINT, SMALLINT, FLOAT, NUMERIC,
    VARCHAR, TEXT, TIMESTAMP, DATE, BOOLEAN, ARRAY
)

class PostgresEngineSpec(BaseEngineSpec):
    """PostgreSQL 引擎规范"""

    engine = "postgresql"
    engine_name = "PostgreSQL"
    default_driver = "psycopg2"

    @classmethod
    def get_dbapi_uri(cls, connection_params: dict[str, Any]) -> str:
        """获取 PostgreSQL 连接 URI"""
        from superset.databases.utils import make_url_safe

        return str(
            URL.create(
                drivername=cls.engine,
                username=connection_params.get("username"),
                password=connection_params.get("password"),
                host=connection_params.get("host"),
                port=connection_params.get("port"),
                database=connection_params.get("database"),
            )
        )

    @classmethod
    def get_sqla_column_type(cls, sqla_type: Any) -> Any:
        """获取 PostgreSQL 列类型"""
        type_mapping = {
            "INTEGER": INTEGER,
            "BIGINT": BIGINT,
            "SMALLINT": SMALLINT,
            "FLOAT": FLOAT,
            "NUMERIC": NUMERIC,
            "VARCHAR": VARCHAR,
            "TEXT": TEXT,
            "TIMESTAMP": TIMESTAMP,
            "DATE": DATE,
            "BOOLEAN": BOOLEAN,
            "ARRAY": ARRAY,
        }

        return type_mapping.get(sqla_type, VARCHAR)

    @classmethod
    def convert_dttm(cls, dttm: datetime) -> str:
        """转换日期时间为 PostgreSQL 格式"""
        return f"'{dttm.strftime('%Y-%m-%d %H:%M:%S')}'::timestamp"

    @classmethod
    def epoch_to_dttm(cls) -> str:
        """获取 epoch 到日期时间的转换 SQL"""
        return "to_timestamp({col})"

    @classmethod
    def epoch_ms_to_dttm(cls) -> str:
        """获取 epoch 毫秒到日期时间的转换 SQL"""
        return "to_timestamp({col} / 1000)"

    @classmethod
    def get_table_names(cls, database: Any, schema: Optional[str] = None) -> list[str]:
        """获取表名列表"""
        from sqlalchemy import inspect

        engine = database.get_sqla_engine()
        inspector = inspect(engine)

        if schema:
            return inspector.get_table_names(schema=schema)
        else:
            return inspector.get_table_names()

    @classmethod
    def get_columns(cls, database: Any, table_name: str, schema: Optional[str] = None) -> list[dict[str, Any]]:
        """获取表的列信息"""
        from sqlalchemy import inspect

        engine = database.get_sqla_engine()
        inspector = inspect(engine)

        columns = inspector.get_columns(table_name, schema=schema)

        return [
            {
                "name": col["name"],
                "type": str(col["type"]),
                "is_dttm": cls.is_temporal_type(col["type"]),
            }
            for col in columns
        ]

    @classmethod
    def is_temporal_type(cls, col_type: Any) -> bool:
        """检查是否是时间类型"""
        temporal_types = ["DATE", "TIMESTAMP", "TIME"]
        return any(t in str(col_type).upper() for t in temporal_types)

    @classmethod
    def get_sql(cls, query_object: Any, datasource: Any) -> str:
        """生成 SQL"""
        from sqlalchemy import select, func

        # 构建基础查询
        table = datasource.get_sqla_table()
        query = select()

        # 添加指标
        for metric in query_object.metrics:
            if hasattr(metric, 'get_sqla_expression'):
                query = query.add_columns(metric.get_sqla_expression())
            else:
                query = query.add_columns(func.sum(metric))

        # 添加分组
        if query_object.groupby:
            for group in query_object.groupby:
                query = query.group_by(group)

        # 添加时间范围
        if query_object.from_dttm and query_object.to_dttm:
            time_col = datasource.main_dttm_col
            query = query.where(
                table.c[time_col] >= query_object.from_dttm,
                table.c[time_col] <= query_object.to_dttm,
            )

        # 添加过滤
        for filter_ in query_object.filters:
            query = query.where(filter_)

        # 添加排序
        if query_object.orderby:
            for order in query_object.orderby:
                query = query.order_by(order)

        # 添加限制
        if query_object.row_limit:
            query = query.limit(query_object.row_limit)

        return str(query)
```

### 2.3 MySQL 引擎规范

```python
from superset.db_engine_specs.base import BaseEngineSpec
from sqlalchemy.dialects.mysql import (
    INTEGER, BIGINT, SMALLINT, FLOAT, DECIMAL,
    VARCHAR, TEXT, DATETIME, DATE, BOOLEAN
)

class MySQLEngineSpec(BaseEngineSpec):
    """MySQL 引擎规范"""

    engine = "mysql"
    engine_name = "MySQL"
    default_driver = "pymysql"

    @classmethod
    def get_dbapi_uri(cls, connection_params: dict[str, Any]) -> str:
        """获取 MySQL 连接 URI"""
        return str(
            URL.create(
                drivername=cls.engine,
                username=connection_params.get("username"),
                password=connection_params.get("password"),
                host=connection_params.get("host"),
                port=connection_params.get("port"),
                database=connection_params.get("database"),
            )
        )

    @classmethod
    def get_sqla_column_type(cls, sqla_type: Any) -> Any:
        """获取 MySQL 列类型"""
        type_mapping = {
            "INTEGER": INTEGER,
            "BIGINT": BIGINT,
            "SMALLINT": SMALLINT,
            "FLOAT": FLOAT,
            "NUMERIC": DECIMAL,
            "VARCHAR": VARCHAR,
            "TEXT": TEXT,
            "TIMESTAMP": DATETIME,
            "DATE": DATE,
            "BOOLEAN": BOOLEAN,
        }

        return type_mapping.get(sqla_type, VARCHAR)

    @classmethod
    def convert_dttm(cls, dttm: datetime) -> str:
        """转换日期时间为 MySQL 格式"""
        return f"'{dttm.strftime('%Y-%m-%d %H:%M:%S')}'"

    @classmethod
    def epoch_to_dttm(cls) -> str:
        """获取 epoch 到日期时间的转换 SQL"""
        return "FROM_UNIXTIME({col})"

    @classmethod
    def epoch_ms_to_dttm(cls) -> str:
        """获取 epoch 毫秒到日期时间的转换 SQL"""
        return "FROM_UNIXTIME({col} / 1000)"

    @classmethod
    def get_table_names(cls, database: Any, schema: Optional[str] = None) -> list[str]:
        """获取表名列表"""
        from sqlalchemy import inspect

        engine = database.get_sqla_engine()
        inspector = inspect(engine)

        return inspector.get_table_names()

    @classmethod
    def get_columns(cls, database: Any, table_name: str, schema: Optional[str] = None) -> list[dict[str, Any]]:
        """获取表的列信息"""
        from sqlalchemy import inspect

        engine = database.get_sqla_engine()
        inspector = inspect(engine)

        columns = inspector.get_columns(table_name)

        return [
            {
                "name": col["name"],
                "type": str(col["type"]),
                "is_dttm": cls.is_temporal_type(col["type"]),
            }
            for col in columns
        ]

    @classmethod
    def is_temporal_type(cls, col_type: Any) -> bool:
        """检查是否是时间类型"""
        temporal_types = ["DATE", "DATETIME", "TIMESTAMP", "TIME"]
        return any(t in str(col_type).upper() for t in temporal_types)
```

## 3. 查询处理

### 3.1 查询上下文工厂

[common/query_context_factory.py](../superset/common/query_context_factory.py) 定义了查询上下文工厂：

```python
from typing import Any, TYPE_CHECKING
from superset.common.query_context import QueryContext
from superset.common.query_object import QueryObject
from superset.common.chart_data import ChartDataResultFormat, ChartDataResultType

if TYPE_CHECKING:
    from superset.explorables.base import Explorable

class QueryContextFactory:
    """查询上下文工厂"""

    @staticmethod
    def create(
        *,
        datasource: Explorable,
        queries: list[QueryObject],
        slice_: Any | None = None,
        form_data: dict[str, Any] | None = None,
        result_type: ChartDataResultType = ChartDataResultType.FULL,
        result_format: ChartDataResultFormat = ChartDataResultFormat.JSON,
        force: bool = False,
        custom_cache_timeout: int | None = None,
        cache_values: dict[str, Any] | None = None,
    ) -> QueryContext:
        """创建查询上下文"""
        return QueryContext(
            datasource=datasource,
            queries=queries,
            slice_=slice_,
            form_data=form_data,
            result_type=result_type,
            result_format=result_format,
            force=force,
            custom_cache_timeout=custom_cache_timeout,
            cache_values=cache_values or {},
        )

    @staticmethod
    def create_from_slice(slice_: Any) -> QueryContext:
        """从图表创建查询上下文"""
        datasource = slice_.get_datasource()
        params = slice_.get_params()

        queries = [
            QueryObject(
                metrics=params.get('metrics', []),
                groupby=params.get('groupby', []),
                columns=params.get('columns', []),
                granularity=params.get('granularity'),
                from_dttm=params.get('from_dttm'),
                to_dttm=params.get('to_dttm'),
                filters=params.get('filters', []),
                orderby=params.get('orderby', []),
                row_limit=params.get('row_limit'),
            )
        ]

        return QueryContextFactory.create(
            datasource=datasource,
            queries=queries,
            slice_=slice_,
            form_data=params,
        )
```

### 3.2 查询对象

[common/query_object.py](../superset/common/query_object.py) 定义了查询对象：

```python
from typing import Any, Optional, List
from dataclasses import dataclass

@dataclass
class QueryObject:
    """查询对象"""

    metrics: list[Any] | None = None
    groupby: list[Any] | None = None
    columns: list[Any] | None = None
    granularity: Optional[str] = None
    from_dttm: Optional[str] = None
    to_dttm: Optional[str] = None
    filters: list[Any] | None = None
    orderby: list[Any] | None = None
    row_limit: Optional[int] = None
    extras: dict[str, Any] | None = None
    is_timeseries: bool = False
    timeseries_limit: Optional[int] = None
    timeseries_limit_metric: Optional[Any] = None
    order_desc: bool = True
    post_processing: list[Any] | None = None
    custom_sql: Optional[str] = None
    custom_form_data: Optional[dict[str, Any]] = None

    def __post_init__(self):
        if self.metrics is None:
            self.metrics = []
        if self.groupby is None:
            self.groupby = []
        if self.columns is None:
            self.columns = []
        if self.filters is None:
            self.filters = []
        if self.orderby is None:
            self.orderby = []
        if self.extras is None:
            self.extras = {}
        if self.post_processing is None:
            self.post_processing = []

    def to_dict(self) -> dict[str, Any]:
        """转换为字典"""
        return {
            'metrics': self.metrics,
            'groupby': self.groupby,
            'columns': self.columns,
            'granularity': self.granularity,
            'from_dttm': self.from_dttm,
            'to_dttm': self.to_dttm,
            'filters': self.filters,
            'orderby': self.orderby,
            'row_limit': self.row_limit,
            'extras': self.extras,
            'is_timeseries': self.is_timeseries,
            'timeseries_limit': self.timeseries_limit,
            'timeseries_limit_metric': self.timeseries_limit_metric,
            'order_desc': self.order_desc,
            'post_processing': self.post_processing,
            'custom_sql': self.custom_sql,
            'custom_form_data': self.custom_form_data,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> 'QueryObject':
        """从字典创建"""
        return cls(**data)
```

### 3.3 查询上下文处理器

[common/query_context_processor.py](../superset/common/query_context_processor.py) 定义了查询上下文处理器：

```python
from typing import Any, Optional
import pandas as pd
from superset.common.query_context import QueryContext
from superset.common.chart_data import ChartDataResultFormat, ChartDataResultType

class QueryContextProcessor:
    """查询上下文处理器"""

    def __init__(self, query_context: QueryContext):
        self.query_context = query_context

    def get_payload(
        self,
        cache_query_context: bool | None = False,
        force_cached: bool = False,
    ) -> dict[str, Any]:
        """获取查询结果"""
        # 检查缓存
        if not force_cached:
            cached_result = self._get_cached_result()
            if cached_result:
                return cached_result

        # 执行查询
        result = self._execute_query()

        # 缓存结果
        if cache_query_context:
            self._cache_result(result)

        return result

    def _get_cached_result(self) -> dict[str, Any] | None:
        """获取缓存结果"""
        from superset.extensions import cache_manager

        cache_key = self._get_cache_key()
        return cache_manager.get(cache_key)

    def _execute_query(self) -> dict[str, Any]:
        """执行查询"""
        # 生成 SQL
        sql = self._generate_sql()

        # 执行 SQL
        df = self._execute_sql(sql)

        # 处理结果
        result = self._process_result(df)

        return result

    def _generate_sql(self) -> str:
        """生成 SQL"""
        from superset.db_engine_specs.base import BaseEngineSpec

        engine_spec = self.query_context.datasource.get_engine_spec()
        sql = engine_spec.get_sql(
            self.query_context.queries[0],
            self.query_context.datasource,
        )

        return sql

    def _execute_sql(self, sql: str) -> pd.DataFrame:
        """执行 SQL"""
        from superset.models.core import Database

        database = self.query_context.datasource.database
        engine = database.get_sqla_engine()

        with engine.connect() as connection:
            df = pd.read_sql_query(sql, connection)

        return df

    def _process_result(self, df: pd.DataFrame) -> dict[str, Any]:
        """处理结果"""
        # 转换为前端需要的格式
        result = {
            'data': df.to_dict('records'),
            'coltypes': self._get_coltypes(df),
            'rowcount': len(df),
        }

        return result

    def _get_coltypes(self, df: pd.DataFrame) -> list[Any]:
        """获取列类型"""
        from superset.utils.database import GenericDataType

        coltypes = []

        for col in df.columns:
            dtype = df[col].dtype

            if pd.api.types.is_integer_dtype(dtype):
                coltypes.append(GenericDataType.NUMERIC)
            elif pd.api.types.is_float_dtype(dtype):
                coltypes.append(GenericDataType.NUMERIC)
            elif pd.api.types.is_datetime64_any_dtype(dtype):
                coltypes.append(GenericDataType.TEMPORAL)
            elif pd.api.types.is_bool_dtype(dtype):
                coltypes.append(GenericDataType.BOOLEAN)
            else:
                coltypes.append(GenericDataType.STRING)

        return coltypes

    def _get_cache_key(self) -> str:
        """获取缓存键"""
        import hashlib
        import json

        cache_data = {
            'datasource_id': self.query_context.datasource.id,
            'queries': [q.to_dict() for q in self.query_context.queries],
        }

        cache_string = json.dumps(cache_data, sort_keys=True)
        cache_key = hashlib.md5(cache_string.encode()).hexdigest()

        return f"chart_data:{cache_key}"

    def _cache_result(self, result: dict[str, Any]) -> None:
        """缓存结果"""
        from superset.extensions import cache_manager

        cache_key = self._get_cache_key()
        cache_timeout = self.query_context.custom_cache_timeout or 3600

        cache_manager.set(cache_key, result, timeout=cache_timeout)
```

## 4. 数据访问对象

### 4.1 基础 DAO

[daos/base.py](../superset/daos/base.py) 定义了基础 DAO：

```python
from typing import Any, Optional, List
from sqlalchemy.orm import Query
from superset.extensions import db

class BaseDAO:
    """基础 DAO 类"""
    model = None

    @classmethod
    def find_by_id(cls, id: int) -> Optional[Any]:
        """根据 ID 查找对象"""
        return db.session.query(cls.model).filter_by(id=id).one_or_none()

    @classmethod
    def find_all(cls) -> List[Any]:
        """查找所有对象"""
        return db.session.query(cls.model).all()

    @classmethod
    def find_by(cls, **kwargs) -> List[Any]:
        """根据条件查找对象"""
        return db.session.query(cls.model).filter_by(**kwargs).all()

    @classmethod
    def find_one_by(cls, **kwargs) -> Optional[Any]:
        """根据条件查找单个对象"""
        return db.session.query(cls.model).filter_by(**kwargs).one_or_none()

    @classmethod
    def create(cls, data: dict[str, Any]) -> Any:
        """创建新对象"""
        obj = cls.model(**data)
        db.session.add(obj)
        db.session.commit()
        return obj

    @classmethod
    def update(cls, obj: Any, data: dict[str, Any]) -> Any:
        """更新对象"""
        for key, value in data.items():
            setattr(obj, key, value)
        db.session.commit()
        return obj

    @classmethod
    def delete(cls, obj: Any) -> None:
        """删除对象"""
        db.session.delete(obj)
        db.session.commit()

    @classmethod
    def query(cls) -> Query:
        """获取查询对象"""
        return db.session.query(cls.model)

    @classmethod
    def count(cls) -> int:
        """统计数量"""
        return db.session.query(cls.model).count()
```

### 4.2 图表 DAO

[daos/chart.py](../superset/daos/chart.py) 定义了图表 DAO：

```python
from typing import Any, Optional, List
from superset.daos.base import BaseDAO
from superset.models.slice import Slice

class ChartDAO(BaseDAO):
    """图表 DAO"""
    model = Slice

    @staticmethod
    def get_chart_by_id(chart_id: int) -> Optional[Slice]:
        """获取图表"""
        return db.session.query(Slice).filter_by(id=chart_id).one_or_none()

    @staticmethod
    def get_charts_by_user(user_id: int) -> List[Slice]:
        """获取用户的图表"""
        return db.session.query(Slice).filter(
            Slice.owners.any(id=user_id)
        ).all()

    @staticmethod
    def get_charts_by_dashboard(dashboard_id: int) -> List[Slice]:
        """获取仪表板的图表"""
        from superset.models.core import Dashboard

        dashboard = db.session.query(Dashboard).get(dashboard_id)
        return dashboard.slices if dashboard else []

    @staticmethod
    def get_charts_by_datasource(datasource_id: int, datasource_type: str) -> List[Slice]:
        """获取数据源的图表"""
        return db.session.query(Slice).filter(
            Slice.datasource_id == datasource_id,
            Slice.datasource_type == datasource_type,
        ).all()

    @staticmethod
    def search_charts(query: str, user_id: Optional[int] = None) -> List[Slice]:
        """搜索图表"""
        charts_query = db.session.query(Slice).filter(
            Slice.slice_name.ilike(f"%{query}%")
        )

        if user_id:
            charts_query = charts_query.filter(
                Slice.owners.any(id=user_id)
            )

        return charts_query.all()
```

### 4.3 仪表板 DAO

[daos/dashboard.py](../superset/daos/dashboard.py) 定义了仪表板 DAO：

```python
from typing import Any, Optional, List
from superset.daos.base import BaseDAO
from superset.models.core import Dashboard

class DashboardDAO(BaseDAO):
    """仪表板 DAO"""
    model = Dashboard

    @staticmethod
    def get_dashboard_by_id(dashboard_id: int) -> Optional[Dashboard]:
        """获取仪表板"""
        return db.session.query(Dashboard).filter_by(id=dashboard_id).one_or_none()

    @staticmethod
    def get_dashboard_by_slug(slug: str) -> Optional[Dashboard]:
        """根据 slug 获取仪表板"""
        return db.session.query(Dashboard).filter_by(slug=slug).one_or_none()

    @staticmethod
    def get_dashboards_by_user(user_id: int) -> List[Dashboard]:
        """获取用户的仪表板"""
        return db.session.query(Dashboard).filter(
            Dashboard.owners.any(id=user_id)
        ).all()

    @staticmethod
    def search_dashboards(query: str, user_id: Optional[int] = None) -> List[Dashboard]:
        """搜索仪表板"""
        dashboards_query = db.session.query(Dashboard).filter(
            Dashboard.dashboard_title.ilike(f"%{query}%")
        )

        if user_id:
            dashboards_query = dashboards_query.filter(
                Dashboard.owners.any(id=user_id)
            )

        return dashboards_query.all()
```

### 4.4 数据库 DAO

[daos/database.py](../superset/daos/database.py) 定义了数据库 DAO：

```python
from typing import Any, Optional, List
from superset.daos.base import BaseDAO
from superset.models.core import Database

class DatabaseDAO(BaseDAO):
    """数据库 DAO"""
    model = Database

    @staticmethod
    def get_database_by_id(database_id: int) -> Optional[Database]:
        """获取数据库"""
        return db.session.query(Database).filter_by(id=database_id).one_or_none()

    @staticmethod
    def get_database_by_name(database_name: str) -> Optional[Database]:
        """根据名称获取数据库"""
        return db.session.query(Database).filter_by(database_name=database_name).one_or_none()

    @staticmethod
    def get_all_databases() -> List[Database]:
        """获取所有数据库"""
        return db.session.query(Database).all()

    @staticmethod
    def search_databases(query: str) -> List[Database]:
        """搜索数据库"""
        return db.session.query(Database).filter(
            Database.database_name.ilike(f"%{query}%")
        ).all()
```

## 5. 命令模式

### 5.1 基础命令

[commands/base.py](../superset/commands/base.py) 定义了基础命令：

```python
from abc import ABC, abstractmethod
from typing import Any, Optional

class BaseCommand(ABC):
    """基础命令类"""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        self._args = args
        self._kwargs = kwargs

    @abstractmethod
    def run(self) -> Any:
        """执行命令"""
        pass

    def validate(self) -> None:
        """验证命令参数"""
        pass

    def __call__(self) -> Any:
        """调用命令"""
        self.validate()
        return self.run()
```

### 5.2 创建命令

[commands/chart/create.py](../superset/commands/chart/create.py) 定义了创建图表命令：

```python
from superset.commands.base import BaseCommand
from superset.daos.chart import ChartDAO
from superset.models.slice import Slice
from superset.utils.database import get_or_create_db

class CreateChartCommand(BaseCommand):
    """创建图表命令"""

    def __init__(self, data: dict[str, Any]):
        self._properties = data.copy()

    def run(self) -> Slice:
        """执行创建图表"""
        # 获取数据源
        datasource = self._get_datasource()

        # 创建图表
        chart = Slice(
            slice_name=self._properties["slice_name"],
            viz_type=self._properties["viz_type"],
            datasource_type=datasource.type,
            datasource_id=datasource.id,
            params=json.dumps(self._properties.get("query_context", {})),
            description=self._properties.get("description"),
        )

        # 设置所有者
        chart.owners = self._get_owners()

        # 保存到数据库
        db.session.add(chart)
        db.session.commit()

        return chart

    def validate(self) -> None:
        """验证输入"""
        if not self._properties.get("slice_name"):
            raise ChartInvalidError("图表名称不能为空")

        if not self._properties.get("viz_type"):
            raise ChartInvalidError("图表类型不能为空")

    def _get_datasource(self) -> Any:
        """获取数据源"""
        datasource_id = self._properties.get("datasource_id")
        datasource_type = self._properties.get("datasource_type")

        if datasource_type == "table":
            from superset.models.core import SqlaTable
            return db.session.query(SqlaTable).get(datasource_id)
        elif datasource_type == "query":
            # 处理查询数据源
            pass

    def _get_owners(self) -> List[Any]:
        """获取所有者"""
        from flask_login import current_user
        return [current_user]
```

### 5.3 更新命令

[commands/chart/update.py](../superset/commands/chart/update.py) 定义了更新图表命令：

```python
from superset.commands.base import BaseCommand
from superset.daos.chart import ChartDAO
from superset.models.slice import Slice

class UpdateChartCommand(BaseCommand):
    """更新图表命令"""

    def __init__(self, chart_ids: List[int], data: dict[str, Any]):
        self._chart_ids = chart_ids
        self._properties = data.copy()

    def run(self) -> List[Slice]:
        """执行更新图表"""
        charts = []
        for chart_id in self._chart_ids:
            chart = ChartDAO.get_chart_by_id(chart_id)
            if not chart:
                raise ChartNotFoundError(f"图表 {chart_id} 不存在")

            # 更新图表属性
            if "slice_name" in self._properties:
                chart.slice_name = self._properties["slice_name"]
            if "viz_type" in self._properties:
                chart.viz_type = self._properties["viz_type"]
            if "params" in self._properties:
                chart.params = json.dumps(self._properties["params"])

            db.session.commit()
            charts.append(chart)

        return charts

    def validate(self) -> None:
        """验证输入"""
        if not self._chart_ids:
            raise ChartInvalidError("图表 ID 不能为空")
```

### 5.4 删除命令

[commands/chart/delete.py](../superset/commands/chart/delete.py) 定义了删除图表命令：

```python
from superset.commands.base import BaseCommand
from superset.daos.chart import ChartDAO

class DeleteChartCommand(BaseCommand):
    """删除图表命令"""

    def __init__(self, chart_ids: List[int]):
        self._chart_ids = chart_ids

    def run(self) -> None:
        """执行删除图表"""
        for chart_id in self._chart_ids:
            chart = ChartDAO.get_chart_by_id(chart_id)
            if not chart:
                raise ChartNotFoundError(f"图表 {chart_id} 不存在")

            db.session.delete(chart)

        db.session.commit()

    def validate(self) -> None:
        """验证输入"""
        if not self._chart_ids:
            raise ChartInvalidError("图表 ID 不能为空")
```

## 6. 缓存管理

### 6.1 缓存管理器

[extensions/cache_manager.py](../superset/extensions/cache_manager.py) 定义了缓存管理器：

```python
from flask_caching import Cache
from typing import Any, Optional

class CacheManager:
    """缓存管理器"""

    def __init__(self, cache: Cache):
        self.cache = cache

    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        return self.cache.get(key)

    def set(self, key: str, value: Any, timeout: Optional[int] = None) -> bool:
        """设置缓存"""
        return self.cache.set(key, value, timeout=timeout)

    def delete(self, key: str) -> bool:
        """删除缓存"""
        return self.cache.delete(key)

    def clear(self) -> bool:
        """清空缓存"""
        return self.cache.clear()

    def memoize(self, timeout: Optional[int] = None):
        """缓存装饰器"""
        return self.cache.memoize(timeout=timeout)
```

### 6.2 查询缓存

```python
from superset.extensions import cache_manager

@cache_manager.cache.memoize(timeout=3600)
def get_chart_data(query_context: QueryContext) -> dict[str, Any]:
    """获取图表数据（带缓存）"""
    # 执行查询
    result = query_context.get_payload()
    return result
```

## 7. 下一步

阅读完本文档后，建议继续学习：

1. [查询引擎](./07-查询引擎.md) - 学习查询处理机制
2. [后端架构](./04-后端架构.md) - 学习后端架构设计
3. [请求流程](./14-请求流程.md) - 了解请求处理流程
