# Apache Superset 可视化组件

## 1. 可视化组件概述

### 1.1 组件类型

Apache Superset 提供了多种可视化组件：

| 组件类型 | 描述 | 可视化库 |
|---------|------|---------|
| **ECharts 组件** | 基于 ECharts 的图表 | ECharts |
| **D3.js 组件** | 基于 D3.js 的图表 | D3.js |
| **Deck.GL 组件** | 地图和空间可视化 | Deck.GL |
| **表格组件** | 数据表格展示 | AG Grid |
| **透视表组件** | 数据透视分析 | React-Pivot-Table |
| **词云组件** | 文本词频可视化 | D3-cloud |

### 1.2 组件架构

```
可视化组件架构
├── 基础组件
│   ├── ChartRenderer
│   ├── ChartContainer
│   └── ChartProvider
├── 图表组件
│   ├── ECharts 组件
│   ├── D3.js 组件
│   └── Deck.GL 组件
├── 数据组件
│   ├── 表格组件
│   ├── 透视表组件
│   └── 数据网格组件
└── 工具组件
    ├── Tooltip 组件
    ├── Legend 组件
    └── ControlPanel 组件
```

## 2. 基础组件

### 2.1 ChartRenderer

[components/Chart/ChartRenderer.tsx](../superset-frontend/src/components/Chart/ChartRenderer.tsx) 是图表渲染器：

```typescript
import React, { PureComponent } from 'react';
import { ChartProps, ChartData } from '@superset-ui/core';

interface ChartRendererProps extends ChartProps {
  chartType: string;
  data: ChartData;
  width: number;
  height: number;
}

class ChartRenderer extends PureComponent<ChartRendererProps> {
  render() {
    const { chartType, data, width, height } = this.props;

    switch (chartType) {
      case 'echarts_timeseries':
        return <EchartsTimeseries data={data} width={width} height={height} />;
      case 'echarts_bar':
        return <EchartsBar data={data} width={width} height={height} />;
      case 'echarts_pie':
        return <EchartsPie data={data} width={width} height={height} />;
      case 'd3_scatter':
        return <D3Scatter data={data} width={width} height={height} />;
      case 'deckgl_map':
        return <DeckGLMap data={data} width={width} height={height} />;
      case 'table':
        return <TableComponent data={data} width={width} height={height} />;
      case 'pivot_table':
        return <PivotTable data={data} width={width} height={height} />;
      default:
        return <div>Unknown chart type: {chartType}</div>;
    }
  }
}

export default ChartRenderer;
```

### 2.2 ChartContainer

[components/Chart/ChartContainer.tsx](../superset-frontend/src/components/Chart/ChartContainer.tsx) 是图表容器：

```typescript
import React, { PureComponent } from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import ChartRenderer from './ChartRenderer';
import * as chartActions from 'src/explore/actions/exploreActions';

interface ChartContainerProps {
  chartId: number;
  chartType: string;
  formData: Record<string, unknown>;
  width: number;
  height: number;
  chartData: Record<string, unknown> | null;
  chartStatus: 'loading' | 'success' | 'error';
  fetchChartData: (formData: Record<string, unknown>) => void;
}

class ChartContainer extends PureComponent<ChartContainerProps> {
  componentDidMount() {
    const { chartId, formData, fetchChartData } = this.props;
    fetchChartData({ chartId, ...formData });
  }

  componentDidUpdate(prevProps: ChartContainerProps) {
    const { formData, fetchChartData } = this.props;

    if (prevProps.formData !== formData) {
      fetchChartData(formData);
    }
  }

  render() {
    const { chartType, chartData, chartStatus, width, height } = this.props;

    if (chartStatus === 'loading') {
      return <Loading />;
    }

    if (chartStatus === 'error') {
      return <ErrorMessage />;
    }

    return (
      <ChartRenderer
        chartType={chartType}
        data={chartData}
        width={width}
        height={height}
      />
    );
  }
}

function mapStateToProps(state: RootState) {
  return {
    chartData: state.explore.chartData,
    chartStatus: state.explore.chartStatus,
  };
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators(chartActions, dispatch);
}

export default connect(mapStateToProps, mapDispatchToProps)(ChartContainer);
```

### 2.3 ChartProvider

```typescript
import React, { createContext, useContext, ReactNode } from 'react';

interface ChartContextType {
  chartId: number;
  chartType: string;
  formData: Record<string, unknown>;
  updateFormData: (data: Record<string, unknown>) => void;
}

const ChartContext = createContext<ChartContextType | null>(null);

interface ChartProviderProps {
  chartId: number;
  chartType: string;
  formData: Record<string, unknown>;
  children: ReactNode;
}

export function ChartProvider({
  chartId,
  chartType,
  formData,
  children,
}: ChartProviderProps) {
  const updateFormData = (data: Record<string, unknown>) => {
    // 更新表单数据
  };

  return (
    <ChartContext.Provider value={{ chartId, chartType, formData, updateFormData }}>
      {children}
    </ChartContext.Provider>
  );
}

export function useChart() {
  const context = useContext(ChartContext);
  if (!context) {
    throw new Error('useChart must be used within a ChartProvider');
  }
  return context;
}
```

## 3. ECharts 组件

### 3.1 ECharts 基础组件

```typescript
import React, { PureComponent } from 'react';
import * as echarts from 'echarts';
import { ChartData } from '@superset-ui/core';

interface EChartsProps {
  data: ChartData;
  width: number;
  height: number;
  echartOptions: Record<string, unknown>;
}

class EchartsBase extends PureComponent<EChartsProps> {
  chartRef: React.RefObject<HTMLDivElement>;
  chartInstance: echarts.ECharts | null = null;

  constructor(props: EChartsProps) {
    super(props);
    this.chartRef = React.createRef();
  }

  componentDidMount() {
    if (this.chartRef.current) {
      this.chartInstance = echarts.init(this.chartRef.current);
      this.updateChart();

      // 响应窗口大小变化
      window.addEventListener('resize', this.handleResize);
    }
  }

  componentDidUpdate(prevProps: EChartsProps) {
    if (
      prevProps.data !== this.props.data ||
      prevProps.echartOptions !== this.props.echartOptions ||
      prevProps.width !== this.props.width ||
      prevProps.height !== this.props.height
    ) {
      this.updateChart();
    }
  }

  componentWillUnmount() {
    if (this.chartInstance) {
      this.chartInstance.dispose();
      window.removeEventListener('resize', this.handleResize);
    }
  }

  handleResize = () => {
    if (this.chartInstance) {
      this.chartInstance.resize();
    }
  };

  updateChart() {
    if (!this.chartInstance) return;

    const { data, echartOptions, width, height } = this.props;
    const option = this.getOption(data, echartOptions);

    this.chartInstance.setOption(option, true);
    this.chartInstance.resize({ width, height });
  }

  getOption(data: ChartData, echartOptions: Record<string, unknown>) {
    return {
      ...echartOptions,
      tooltip: {
        trigger: 'axis',
      },
      xAxis: {
        type: 'category',
        data: data.records.map(r => r.x),
      },
      yAxis: {
        type: 'value',
      },
      series: [{
        data: data.records.map(r => r.y),
        type: 'line',
      }],
    };
  }

  render() {
    const { width, height } = this.props;

    return (
      <div
        ref={this.chartRef}
        style={{ width, height }}
      />
    );
  }
}

export default EchartsBase;
```

### 3.2 ECharts 时间序列图表

```typescript
import React, { PureComponent } from 'react';
import * as echarts from 'echarts';
import { ChartData } from '@superset-ui/core';

interface EchartsTimeseriesProps {
  data: ChartData;
  width: number;
  height: number;
  echartOptions: Record<string, unknown>;
}

class EchartsTimeseries extends PureComponent<EchartsTimeseriesProps> {
  chartRef: React.RefObject<HTMLDivElement>;
  chartInstance: echarts.ECharts | null = null;

  constructor(props: EchartsTimeseriesProps) {
    super(props);
    this.chartRef = React.createRef();
  }

  componentDidMount() {
    if (this.chartRef.current) {
      this.chartInstance = echarts.init(this.chartRef.current);
      this.updateChart();
    }
  }

  componentDidUpdate(prevProps: EchartsTimeseriesProps) {
    if (
      prevProps.data !== this.props.data ||
      prevProps.echartOptions !== this.props.echartOptions
    ) {
      this.updateChart();
    }
  }

  componentWillUnmount() {
    if (this.chartInstance) {
      this.chartInstance.dispose();
    }
  }

  updateChart() {
    if (!this.chartInstance) return;

    const { data, echartOptions } = this.props;
    const option = this.getOption(data, echartOptions);

    this.chartInstance.setOption(option);
  }

  getOption(data: ChartData, echartOptions: Record<string, unknown>) {
    const { records } = data;
    const xData = records.map(r => r.x);
    const yData = records.map(r => r.y);

    return {
      ...echartOptions,
      tooltip: {
        trigger: 'axis',
        axisPointer: {
          type: 'cross',
        },
      },
      xAxis: {
        type: 'category',
        data: xData,
        axisLabel: {
          rotate: 45,
        },
      },
      yAxis: {
        type: 'value',
        name: 'Value',
      },
      series: [{
        name: 'Series 1',
        type: 'line',
        data: yData,
        smooth: true,
        areaStyle: {
          opacity: 0.3,
        },
      }],
    };
  }

  render() {
    const { width, height } = this.props;

    return (
      <div
        ref={this.chartRef}
        style={{ width, height }}
      />
    );
  }
}

export default EchartsTimeseries;
```

### 3.3 ECharts 柱状图

```typescript
import React, { PureComponent } from 'react';
import * as echarts from 'echarts';
import { ChartData } from '@superset-ui/core';

interface EchartsBarProps {
  data: ChartData;
  width: number;
  height: number;
  echartOptions: Record<string, unknown>;
}

class EchartsBar extends PureComponent<EchartsBarProps> {
  chartRef: React.RefObject<HTMLDivElement>;
  chartInstance: echarts.ECharts | null = null;

  constructor(props: EchartsBarProps) {
    super(props);
    this.chartRef = React.createRef();
  }

  componentDidMount() {
    if (this.chartRef.current) {
      this.chartInstance = echarts.init(this.chartRef.current);
      this.updateChart();
    }
  }

  componentDidUpdate(prevProps: EchartsBarProps) {
    if (
      prevProps.data !== this.props.data ||
      prevProps.echartOptions !== this.props.echartOptions
    ) {
      this.updateChart();
    }
  }

  componentWillUnmount() {
    if (this.chartInstance) {
      this.chartInstance.dispose();
    }
  }

  updateChart() {
    if (!this.chartInstance) return;

    const { data, echartOptions } = this.props;
    const option = this.getOption(data, echartOptions);

    this.chartInstance.setOption(option);
  }

  getOption(data: ChartData, echartOptions: Record<string, unknown>) {
    const { records } = data;
    const xData = records.map(r => r.x);
    const yData = records.map(r => r.y);

    return {
      ...echartOptions,
      tooltip: {
        trigger: 'axis',
        axisPointer: {
          type: 'shadow',
        },
      },
      xAxis: {
        type: 'category',
        data: xData,
        axisLabel: {
          rotate: 45,
        },
      },
      yAxis: {
        type: 'value',
        name: 'Value',
      },
      series: [{
        name: 'Series 1',
        type: 'bar',
        data: yData,
        itemStyle: {
          color: (params: any) => {
            const colors = ['#5AC189', '#5BA4CF', '#FFA94D', '#F8746B', '#9D5AC9'];
            return colors[params.dataIndex % colors.length];
          },
        },
      }],
    };
  }

  render() {
    const { width, height } = this.props;

    return (
      <div
        ref={this.chartRef}
        style={{ width, height }}
      />
    );
  }
}

export default EchartsBar;
```

## 4. D3.js 组件

### 4.1 D3.js 散点图

```typescript
import React, { PureComponent } from 'react';
import * as d3 from 'd3';
import { ChartData } from '@superset-ui/core';

interface D3ScatterProps {
  data: ChartData;
  width: number;
  height: number;
  margin: { top: number; right: number; bottom: number; left: number };
}

class D3Scatter extends PureComponent<D3ScatterProps> {
  svgRef: React.RefObject<SVGSVGElement>;
  tooltipRef: React.RefObject<HTMLDivElement>;

  constructor(props: D3ScatterProps) {
    super(props);
    this.svgRef = React.createRef();
    this.tooltipRef = React.createRef();
  }

  componentDidMount() {
    this.renderChart();
  }

  componentDidUpdate() {
    this.renderChart();
  }

  renderChart() {
    if (!this.svgRef.current) return;

    const { data, width, height, margin } = this.props;
    const { records } = data;

    // 清空 SVG
    d3.select(this.svgRef.current).selectAll('*').remove();

    // 计算绘图区域
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    // 创建比例尺
    const xScale = d3.scaleLinear()
      .domain([0, d3.max(records, (d: any) => d.x) || 0])
      .range([0, innerWidth]);

    const yScale = d3.scaleLinear()
      .domain([0, d3.max(records, (d: any) => d.y) || 0])
      .range([innerHeight, 0]);

    const radiusScale = d3.scaleSqrt()
      .domain([0, d3.max(records, (d: any) => d.r) || 0])
      .range([5, 20]);

    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

    // 创建 SVG 元素
    const svg = d3.select(this.svgRef.current)
      .attr('width', width)
      .attr('height', height);

    // 创建绘图区域
    const g = svg.append('g')
      .attr('transform', `translate(${margin.left}, ${margin.top})`);

    // 绘制坐标轴
    g.append('g')
      .attr('transform', `translate(0, ${innerHeight})`)
      .call(d3.axisBottom(xScale));

    g.append('g')
      .call(d3.axisLeft(yScale));

    // 绘制数据点
    g.selectAll('circle')
      .data(records)
      .enter()
      .append('circle')
      .attr('cx', (d: any) => xScale(d.x))
      .attr('cy', (d: any) => yScale(d.y))
      .attr('r', (d: any) => radiusScale(d.r))
      .attr('fill', (d: any, i: number) => colorScale(i.toString()))
      .attr('opacity', 0.7)
      .on('mouseover', (event: any, d: any) => this.showTooltip(event, d))
      .on('mouseout', () => this.hideTooltip());
  }

  showTooltip(event: any, data: any) {
    if (!this.tooltipRef.current) return;

    const tooltip = d3.select(this.tooltipRef.current);
    tooltip
      .style('left', `${event.pageX + 10}px`)
      .style('top', `${event.pageY - 10}px`)
      .style('opacity', 1)
      .html(`
        <div><strong>X:</strong> ${data.x}</div>
        <div><strong>Y:</strong> ${data.y}</div>
        <div><strong>Radius:</strong> ${data.r}</div>
      `);
  }

  hideTooltip() {
    if (!this.tooltipRef.current) return;

    d3.select(this.tooltipRef.current)
      .style('opacity', 0);
  }

  render() {
    const { width, height } = this.props;

    return (
      <div style={{ position: 'relative' }}>
        <svg
          ref={this.svgRef}
          width={width}
          height={height}
        />
        <div
          ref={this.tooltipRef}
          style={{
            position: 'absolute',
            padding: '10px',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: '4px',
            pointerEvents: 'none',
            opacity: 0,
            transition: 'opacity 0.2s',
          }}
        />
      </div>
    );
  }
}

export default D3Scatter;
```

## 5. Deck.GL 组件

### 5.1 Deck.GL 地图组件

```typescript
import React, { PureComponent } from 'react';
import { Map } from 'react-map-gl';
import { ScatterplotLayer } from '@deck.gl/layers';
import { ChartData } from '@superset-ui/core';

interface DeckGLMapProps {
  data: ChartData;
  width: number;
  height: number;
  mapboxAccessToken: string;
}

class DeckGLMap extends PureComponent<DeckGLMapProps> {
  render() {
    const { data, width, height, mapboxAccessToken } = this.props;
    const { records } = data;

    const layers = [
      new ScatterplotLayer({
        id: 'scatterplot-layer',
        data: records,
        getPosition: (d: any) => [d.longitude, d.latitude],
        getRadius: (d: any) => d.radius,
        getFillColor: (d: any) => d.color,
        pickable: true,
        onHover: (info: any) => this.handleHover(info),
      }),
    ];

    return (
      <Map
        mapboxAccessToken={mapboxAccessToken}
        initialViewState={{
          longitude: -122.4,
          latitude: 37.8,
          zoom: 12,
        }}
        style={{ width, height }}
      >
        <DeckGL
          layers={layers}
          width={width}
          height={height}
        />
      </Map>
    );
  }

  handleHover(info: any) {
    if (info.object) {
      console.log('Hovered object:', info.object);
    }
  }
}

export default DeckGLMap;
```

## 6. 表格组件

### 6.1 AG Grid 表格组件

```typescript
import React, { PureComponent } from 'react';
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-alpine.css';
import { ChartData } from '@superset-ui/core';

interface TableComponentProps {
  data: ChartData;
  width: number;
  height: number;
}

interface TableComponentState {
  columnDefs: any[];
  rowData: any[];
}

class TableComponent extends PureComponent<TableComponentProps, TableComponentState> {
  gridRef: React.RefObject<AgGridReact>;

  constructor(props: TableComponentProps) {
    super(props);
    this.gridRef = React.createRef();
    this.state = {
      columnDefs: [],
      rowData: [],
    };
  }

  componentDidMount() {
    this.loadData();
  }

  componentDidUpdate(prevProps: TableComponentProps) {
    if (prevProps.data !== this.props.data) {
      this.loadData();
    }
  }

  loadData() {
    const { data } = this.props;
    const { records, columns } = data;

    // 构建列定义
    const columnDefs = columns.map((col: string) => ({
      field: col,
      headerName: col,
      sortable: true,
      filter: true,
      resizable: true,
    }));

    this.setState({
      columnDefs,
      rowData: records,
    });
  }

  onGridReady = (params: any) => {
    params.api.sizeColumnsToFit();
  };

  render() {
    const { width, height } = this.props;
    const { columnDefs, rowData } = this.state;

    return (
      <div
        className="ag-theme-alpine"
        style={{ width, height }}
      >
        <AgGridReact
          ref={this.gridRef}
          columnDefs={columnDefs}
          rowData={rowData}
          onGridReady={this.onGridReady}
          domLayout="autoHeight"
        />
      </div>
    );
  }
}

export default TableComponent;
```

## 7. 工具组件

### 7.1 Tooltip 组件

```typescript
import React, { PureComponent } from 'react';

interface TooltipProps {
  x: number;
  y: number;
  content: React.ReactNode;
  visible: boolean;
}

class Tooltip extends PureComponent<TooltipProps> {
  render() {
    const { x, y, content, visible } = this.props;

    if (!visible) return null;

    return (
      <div
        style={{
          position: 'absolute',
          left: x,
          top: y,
          padding: '10px',
          backgroundColor: 'white',
          border: '1px solid #ccc',
          borderRadius: '4px',
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
          zIndex: 1000,
        }}
      >
        {content}
      </div>
    );
  }
}

export default Tooltip;
```

### 7.2 Legend 组件

```typescript
import React, { PureComponent } from 'react';

interface LegendProps {
  items: Array<{
    label: string;
    color: string;
    onClick: () => void;
  }>;
  position: 'top' | 'bottom' | 'left' | 'right';
}

class Legend extends PureComponent<LegendProps> {
  render() {
    const { items, position } = this.props;

    const style: React.CSSProperties = {
      display: 'flex',
      flexDirection: position === 'top' || position === 'bottom' ? 'row' : 'column',
      gap: '10px',
      padding: '10px',
    };

    return (
      <div style={style}>
        {items.map((item, index) => (
          <div
            key={index}
            style={{
              display: 'flex',
              alignItems: 'center',
              cursor: 'pointer',
            }}
            onClick={item.onClick}
          >
            <div
              style={{
                width: '20px',
                height: '20px',
                backgroundColor: item.color,
                marginRight: '5px',
              }}
            />
            <span>{item.label}</span>
          </div>
        ))}
      </div>
    );
  }
}

export default Legend;
```

## 8. 组件最佳实践

### 8.1 性能优化

1. **虚拟化渲染**
   - 使用虚拟滚动处理大数据集
   - 实现数据分页和懒加载
   - 使用 Web Workers 处理复杂计算

2. **内存管理**
   - 及时清理不需要的 DOM 元素
   - 避免内存泄漏
   - 使用对象池复用对象

3. **渲染优化**
   - 使用 React.memo 避免不必要的重渲染
   - 使用 useMemo 和 useCallback 缓存计算结果
   - 使用 requestAnimationFrame 优化动画

### 8.2 可访问性

1. **键盘导航**
   - 支持键盘快捷键
   - 实现焦点管理
   - 提供键盘操作提示

2. **屏幕阅读器**
   - 添加 ARIA 属性
   - 提供文本替代
   - 支持屏幕阅读器导航

3. **对比度**
   - 确保足够的颜色对比度
   - 支持高对比度模式
   - 提供颜色主题切换

### 8.3 响应式设计

1. **自适应布局**
   - 支持不同屏幕尺寸
   - 实现自适应布局
   - 处理窗口大小变化

2. **触摸支持**
   - 支持触摸事件
   - 实现手势操作
   - 优化触摸响应

3. **移动端优化**
   - 优化移动端性能
   - 减少移动端资源消耗
   - 提供移动端特定功能

## 9. 下一步

阅读完本文档后，建议继续学习：

1. [自定义图表](./12-自定义图表.md) - 学习如何创建自定义图表
2. [插件系统](./11-插件系统.md) - 学习插件系统架构
3. [前端架构](./08-前端架构.md) - 学习前端架构
