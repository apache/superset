"use strict";

exports.__esModule = true;
exports.default = void 0;

var _d3Array = require("d3-array");

var _ChannelDef = require("../typeGuards/ChannelDef");

var _Channel = require("../typeGuards/Channel");

var _ChannelEncoderAxis = _interopRequireDefault(require("./ChannelEncoderAxis"));

var _createGetterFromChannelDef = _interopRequireDefault(require("../parsers/createGetterFromChannelDef"));

var _completeChannelDef = _interopRequireDefault(require("../fillers/completeChannelDef"));

var _createFormatterFromChannelDef = _interopRequireDefault(require("../parsers/format/createFormatterFromChannelDef"));

var _createScaleFromScaleConfig = _interopRequireDefault(require("../parsers/scale/createScaleFromScaleConfig"));

var _identity = _interopRequireDefault(require("../utils/identity"));

var _applyDomain = _interopRequireDefault(require("../parsers/scale/applyDomain"));

var _applyZero = _interopRequireDefault(require("../parsers/scale/applyZero"));

var _applyNice = _interopRequireDefault(require("../parsers/scale/applyNice"));

var _CompleteChannelDef = require("../typeGuards/CompleteChannelDef");

var _Scale = require("../typeGuards/Scale");

var _applyRange = _interopRequireDefault(require("../parsers/scale/applyRange"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ChannelEncoder {
  constructor({
    name,
    channelType,
    definition: originalDefinition
  }) {
    this.name = void 0;
    this.channelType = void 0;
    this.originalDefinition = void 0;
    this.definition = void 0;
    this.scale = void 0;
    this.axis = void 0;
    this.getValue = void 0;
    this.encodeFunc = void 0;
    this.formatValue = void 0;

    this.encodeValue = (value, otherwise) => {
      if (typeof otherwise !== 'undefined' && (value === null || typeof value === 'undefined')) {
        return otherwise;
      } // eslint-disable-next-line @typescript-eslint/no-explicit-any


      return this.encodeFunc(value);
    };

    this.encodeDatum = (datum, otherwise) => typeof otherwise === 'undefined' ? this.encodeValue(this.getValueFromDatum(datum)) : this.encodeValue(this.getValueFromDatum(datum), otherwise);

    this.formatDatum = datum => this.formatValue(this.getValueFromDatum(datum));

    this.getValueFromDatum = (datum, otherwise) => {
      const value = this.getValue(datum);
      return otherwise !== undefined && (value === null || value === undefined) ? otherwise : value;
    };

    this.getDomainFromDataset = data => {
      if ((0, _ChannelDef.isValueDef)(this.definition)) {
        const {
          value
        } = this.definition;
        return [value];
      }

      const {
        type
      } = this.definition;

      if (type === 'nominal' || type === 'ordinal') {
        return Array.from(new Set(data.map(d => this.getValueFromDatum(d))));
      }

      if (type === 'quantitative') {
        // Quantile scale needs all items
        // because it treats domain as a discrete set of sample values
        // for computing the quantiles
        if (this.definition.scale && this.definition.scale.type === 'quantile') {
          return data.map(d => this.getValueFromDatum(d));
        }

        const extent = (0, _d3Array.extent)(data, d => this.getValueFromDatum(d));
        return typeof extent[0] === 'undefined' ? [0, 1] : extent;
      }

      if (type === 'temporal') {
        const extent = (0, _d3Array.extent)(data, d => this.getValueFromDatum(d));
        return typeof extent[0] === 'undefined' ? [0, 1] : extent;
      }

      return [];
    };

    this.name = name;
    this.channelType = channelType;
    this.originalDefinition = originalDefinition;
    this.definition = (0, _completeChannelDef.default)(this.channelType, originalDefinition);
    this.getValue = (0, _createGetterFromChannelDef.default)(this.definition);
    this.formatValue = (0, _createFormatterFromChannelDef.default)(this.definition);

    if (this.definition.scale) {
      const scale = (0, _createScaleFromScaleConfig.default)(this.definition.scale); // eslint-disable-next-line @typescript-eslint/no-explicit-any

      this.encodeFunc = value => scale(value);

      this.scale = scale;
    } else {
      const {
        definition
      } = this;
      this.encodeFunc = (0, _CompleteChannelDef.isCompleteValueDef)(definition) ? () => definition.value : _identity.default;
    }

    if (this.definition.axis) {
      this.axis = new _ChannelEncoderAxis.default(this);
    }
  }

  getDomain() {
    if (this.scale && 'domain' in this.scale) {
      return this.scale.domain();
    }

    return [];
  }

  setDomain(domain) {
    if (this.definition.scale !== false && this.scale && !(0, _Scale.isCategoricalColorScale)(this.scale) && 'domain' in this.scale) {
      const config = this.definition.scale;
      (0, _applyDomain.default)(config, this.scale, domain);
      (0, _applyRange.default)(config, this.scale);
      (0, _applyZero.default)(config, this.scale);
      (0, _applyNice.default)(config, this.scale);
    }

    return this;
  }

  setDomainFromDataset(data) {
    return this.scale && 'domain' in this.scale ? this.setDomain(this.getDomainFromDataset(data)) : this;
  }

  getTitle() {
    return this.definition.title;
  }

  isGroupBy() {
    if ((0, _ChannelDef.isTypedFieldDef)(this.definition)) {
      const {
        type
      } = this.definition;
      return this.channelType === 'Category' || this.channelType === 'Text' || this.channelType === 'Color' && (type === 'nominal' || type === 'ordinal') || (0, _Channel.isXOrY)(this.channelType) && (type === 'nominal' || type === 'ordinal');
    }

    return false;
  }

  isX() {
    return (0, _Channel.isX)(this.channelType);
  }

  isXOrY() {
    return (0, _Channel.isXOrY)(this.channelType);
  }

  isY() {
    return (0, _Channel.isY)(this.channelType);
  }

  hasLegend() {
    return this.definition.legend !== false;
  }

  hasValueDefinition() {
    return (0, _CompleteChannelDef.isCompleteValueDef)(this.definition);
  }

  hasFieldDefinition() {
    return (0, _CompleteChannelDef.isCompleteFieldDef)(this.definition);
  }

}

exports.default = ChannelEncoder;