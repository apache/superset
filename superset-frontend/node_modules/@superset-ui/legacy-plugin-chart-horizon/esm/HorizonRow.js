"use strict";

exports.__esModule = true;
exports.default = exports.DEFAULT_COLORS = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _d3Array = require("d3-array");

var _d3Scale = require("d3-scale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const DEFAULT_COLORS = ['#313695', '#4575b4', '#74add1', '#abd9e9', '#fee090', '#fdae61', '#f46d43', '#d73027'];
exports.DEFAULT_COLORS = DEFAULT_COLORS;
const propTypes = {
  className: _propTypes.default.string,
  width: _propTypes.default.number,
  height: _propTypes.default.number,
  data: _propTypes.default.arrayOf(_propTypes.default.shape({
    y: _propTypes.default.number
  })).isRequired,
  bands: _propTypes.default.number,
  colors: _propTypes.default.arrayOf(_propTypes.default.string),
  colorScale: _propTypes.default.string,
  mode: _propTypes.default.string,
  offsetX: _propTypes.default.number,
  title: _propTypes.default.string,
  yDomain: _propTypes.default.arrayOf(_propTypes.default.number)
};
const defaultProps = {
  className: '',
  width: 800,
  height: 20,
  bands: DEFAULT_COLORS.length >> 1,
  colors: DEFAULT_COLORS,
  colorScale: 'series',
  mode: 'offset',
  offsetX: 0,
  title: '',
  yDomain: undefined
};

class HorizonRow extends _react.default.PureComponent {
  componentDidMount() {
    this.drawChart();
  }

  componentDidUpdate() {
    this.drawChart();
  }

  componentWillUnmount() {
    this.canvas = null;
  }

  drawChart() {
    if (this.canvas) {
      const {
        data: rawData,
        yDomain,
        width,
        height,
        bands,
        colors,
        colorScale,
        offsetX,
        mode
      } = this.props;
      const data = colorScale === 'change' ? rawData.map(d => _extends({}, d, {
        y: d.y - rawData[0].y
      })) : rawData;
      const context = this.canvas.getContext('2d');
      context.imageSmoothingEnabled = false;
      context.clearRect(0, 0, width, height); // Reset transform

      context.setTransform(1, 0, 0, 1, 0, 0);
      context.translate(0.5, 0.5);
      const step = width / data.length; // the data frame currently being shown:

      const startIndex = Math.floor(Math.max(0, -(offsetX / step)));
      const endIndex = Math.floor(Math.min(data.length, startIndex + width / step)); // skip drawing if there's no data to be drawn

      if (startIndex > data.length) {
        return;
      } // Create y-scale


      const [min, max] = yDomain || (0, _d3Array.extent)(data, d => d.y);
      const y = (0, _d3Scale.scaleLinear)().domain([0, Math.max(-min, max)]).range([0, height]); // we are drawing positive & negative bands separately to avoid mutating canvas state
      // http://www.html5rocks.com/en/tutorials/canvas/performance/

      let hasNegative = false; // draw positive bands

      let value;
      let bExtents;

      for (let b = 0; b < bands; b += 1) {
        context.fillStyle = colors[bands + b]; // Adjust the range based on the current band index.

        bExtents = (b + 1 - bands) * height;
        y.range([bands * height + bExtents, bExtents]); // only the current data frame is being drawn i.e. what's visible:

        for (let i = startIndex; i < endIndex; i++) {
          value = data[i].y;

          if (value <= 0) {
            hasNegative = true;
            continue;
          }

          if (value !== undefined) {
            context.fillRect(offsetX + i * step, y(value), step + 1, y(0) - y(value));
          }
        }
      } // draw negative bands


      if (hasNegative) {
        // mirror the negative bands, by flipping the canvas
        if (mode === 'offset') {
          context.translate(0, height);
          context.scale(1, -1);
        }

        for (let b = 0; b < bands; b++) {
          context.fillStyle = colors[bands - b - 1]; // Adjust the range based on the current band index.

          bExtents = (b + 1 - bands) * height;
          y.range([bands * height + bExtents, bExtents]); // only the current data frame is being drawn i.e. what's visible:

          for (let ii = startIndex; ii < endIndex; ii++) {
            value = data[ii].y;

            if (value >= 0) {
              continue;
            }

            context.fillRect(offsetX + ii * step, y(-value), step + 1, y(0) - y(-value));
          }
        }
      }
    }
  }

  render() {
    const {
      className,
      title,
      width,
      height
    } = this.props;
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "horizon-row " + className
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "title"
    }, title), /*#__PURE__*/_react.default.createElement("canvas", {
      ref: c => {
        this.canvas = c;
      },
      width: width,
      height: height
    }));
  }

}

HorizonRow.propTypes = propTypes;
HorizonRow.defaultProps = defaultProps;
var _default = HorizonRow;
exports.default = _default;