"use strict";

exports.__esModule = true;
exports.default = void 0;

var _types = require("../types");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Registry class
 *
 * Can use generic to specify type of item in the registry
 * @type V Type of value
 * @type W Type of value returned from loader function when using registerLoader().
 * W can be either V, Promise<V> or V | Promise<V>
 * Set W=V when does not support asynchronous loader.
 * By default W is set to V | Promise<V> to support
 * both synchronous and asynchronous loaders.
 */
class Registry {
  constructor(config = {}) {
    _defineProperty(this, "name", void 0);

    _defineProperty(this, "overwritePolicy", void 0);

    _defineProperty(this, "items", void 0);

    _defineProperty(this, "promises", void 0);

    const {
      name = '',
      overwritePolicy = _types.OverwritePolicy.ALLOW
    } = config;
    this.name = name;
    this.overwritePolicy = overwritePolicy;
    this.items = {};
    this.promises = {};
  }

  clear() {
    this.items = {};
    this.promises = {};
    return this;
  }

  has(key) {
    const item = this.items[key];
    return item !== null && item !== undefined;
  }

  registerValue(key, value) {
    const item = this.items[key];
    const willOverwrite = this.has(key) && ('value' in item && item.value !== value || 'loader' in item);

    if (willOverwrite) {
      if (this.overwritePolicy === _types.OverwritePolicy.WARN) {
        console.warn("Item with key \"" + key + "\" already exists. You are assigning a new value.");
      } else if (this.overwritePolicy === _types.OverwritePolicy.PROHIBIT) {
        throw new Error("Item with key \"" + key + "\" already exists. Cannot overwrite.");
      }
    }

    if (!item || willOverwrite) {
      this.items[key] = {
        value
      };
      delete this.promises[key];
    }

    return this;
  }

  registerLoader(key, loader) {
    const item = this.items[key];
    const willOverwrite = this.has(key) && ('loader' in item && item.loader !== loader || 'value' in item);

    if (willOverwrite) {
      if (this.overwritePolicy === _types.OverwritePolicy.WARN) {
        console.warn("Item with key \"" + key + "\" already exists. You are assigning a new value.");
      } else if (this.overwritePolicy === _types.OverwritePolicy.PROHIBIT) {
        throw new Error("Item with key \"" + key + "\" already exists. Cannot overwrite.");
      }
    }

    if (!item || willOverwrite) {
      this.items[key] = {
        loader
      };
      delete this.promises[key];
    }

    return this;
  }

  get(key) {
    const item = this.items[key];

    if (item !== undefined) {
      if ('loader' in item) {
        return item.loader && item.loader();
      }

      return item.value;
    }

    return undefined;
  }

  getAsPromise(key) {
    const promise = this.promises[key];

    if (typeof promise !== 'undefined') {
      return promise;
    }

    const item = this.get(key);

    if (item !== undefined) {
      const newPromise = Promise.resolve(item);
      this.promises[key] = newPromise;
      return newPromise;
    }

    return Promise.reject(new Error("Item with key \"" + key + "\" is not registered."));
  }

  getMap() {
    return this.keys().reduce((prev, key) => {
      const map = prev;
      map[key] = this.get(key);
      return map;
    }, {});
  }

  getMapAsPromise() {
    const keys = this.keys();
    return Promise.all(keys.map(key => this.getAsPromise(key))).then(values => values.reduce((prev, value, i) => {
      const map = prev;
      map[keys[i]] = value;
      return map;
    }, {}));
  }

  keys() {
    return Object.keys(this.items);
  }

  values() {
    return this.keys().map(key => this.get(key));
  }

  valuesAsPromise() {
    return Promise.all(this.keys().map(key => this.getAsPromise(key)));
  }

  entries() {
    return this.keys().map(key => ({
      key,
      value: this.get(key)
    }));
  }

  entriesAsPromise() {
    const keys = this.keys();
    return Promise.all(keys.map(key => this.getAsPromise(key))).then(values => values.map((value, i) => ({
      key: keys[i],
      value
    })));
  }

  remove(key) {
    delete this.items[key];
    delete this.promises[key];
    return this;
  }

}

exports.default = Registry;